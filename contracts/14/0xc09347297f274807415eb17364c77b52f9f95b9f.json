{
  "address": "0xc09347297f274807415eb17364c77b52f9f95b9f",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "BattleProvider",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-04-20\n*/\n\npragma solidity ^0.4.19;\n\ncontract ERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n    function getBeneficiary() external view returns(address);\n}\n\ncontract SanctuaryInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isSanctuary() public pure returns (bool);\n\n    /// @dev generate new warrior genes\n    /// @param _heroGenes Genes of warrior that have completed dungeon\n    /// @param _heroLevel Level of the warrior\n    /// @return the genes that are supposed to be passed down to newly arisen warrior\n    function generateWarrior(uint256 _heroGenes, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) public returns (uint256);\n}\n\ncontract PVPInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isPVPProvider() external pure returns (bool);\n    \n    function addTournamentContender(address _owner, uint256[] _tournamentData) external payable;\n    function getTournamentThresholdFee() public view returns(uint256);\n    \n    function addPVPContender(address _owner, uint256 _packedWarrior) external payable;\n    function getPVPEntranceFee(uint256 _levelPoints) external view returns(uint256);\n}\n\ncontract PVPListenerInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isPVPListener() public pure returns (bool);\n    function getBeneficiary() external view returns(address);\n    \n    function pvpFinished(uint256[] warriorData, uint256 matchingCount) public;\n    function pvpContenderRemoved(uint256 _warriorId) public;\n    function tournamentFinished(uint256[] packedContenders) public;\n}\n\ncontract PermissionControll {\n    // This facet controls access to contract that implements it. There are four roles managed here:\n    //\n    // - The Admin: The Admin can reassign admin and issuer roles and change the addresses of our dependent smart\n    // contracts. It is also the only role that can unpause the smart contract. It is initially\n    // set to the address that created the smart contract in the CryptoWarriorCore constructor.\n    //\n    // - The Bank: The Bank can withdraw funds from CryptoWarriorCore and its auction and battle contracts, and change admin role.\n    //\n    // - The Issuer: The Issuer can release gen0 warriors to auction.\n    //\n    // / @dev Emited when contract is upgraded\n    event ContractUpgrade(address newContract);\n    \n    // Set in case the core contract is broken and an upgrade is required\n    address public newContractAddress;\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public adminAddress;\n    address public bankAddress;\n    address public issuerAddress; \n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public paused = false;\n    \n\n    // / @dev Access modifier for Admin-only functionality\n    modifier onlyAdmin(){\n        require(msg.sender == adminAddress);\n        _;\n    }\n\n    // / @dev Access modifier for Bank-only functionality\n    modifier onlyBank(){\n        require(msg.sender == bankAddress);\n        _;\n    }\n    \n    /// @dev Access modifier for Issuer-only functionality\n    modifier onlyIssuer(){\n    \t\trequire(msg.sender == issuerAddress);\n        _;\n    }\n    \n    modifier onlyAuthorized(){\n        require(msg.sender == issuerAddress ||\n            msg.sender == adminAddress ||\n            msg.sender == bankAddress);\n        _;\n    }\n\n\n    // / @dev Assigns a new address to act as the Bank. Only available to the current Bank.\n    // / @param _newBank The address of the new Bank\n    function setBank(address _newBank) external onlyBank {\n        require(_newBank != address(0));\n        bankAddress = _newBank;\n    }\n\n    // / @dev Assigns a new address to act as the Admin. Only available to the current Admin.\n    // / @param _newAdmin The address of the new Admin\n    function setAdmin(address _newAdmin) external {\n        require(msg.sender == adminAddress || msg.sender == bankAddress);\n        require(_newAdmin != address(0));\n        adminAddress = _newAdmin;\n    }\n    \n    // / @dev Assigns a new address to act as the Issuer. Only available to the current Issuer.\n    // / @param _newIssuer The address of the new Issuer\n    function setIssuer(address _newIssuer) external onlyAdmin{\n        require(_newIssuer != address(0));\n        issuerAddress = _newIssuer;\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n    // / @dev Modifier to allow actions only when the contract IS NOT paused\n    modifier whenNotPaused(){\n        require(!paused);\n        _;\n    }\n\n    // / @dev Modifier to allow actions only when the contract IS paused\n    modifier whenPaused{\n        require(paused);\n        _;\n    }\n\n    // / @dev Called by any \"Authorized\" role to pause the contract. Used only when\n    // /  a bug or exploit is detected and we need to limit damage.\n    function pause() external onlyAuthorized whenNotPaused{\n        paused = true;\n    }\n\n    // / @dev Unpauses the smart contract. Can only be called by the Admin.\n    // / @notice This is public rather than external so it can be called by\n    // /  derived contracts.\n    function unpause() public onlyAdmin whenPaused{\n        // can't unpause if contract was upgraded\n        paused = false;\n    }\n    \n    \n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n    ///  breaking bug. This method does nothing but keep track of the new contract and\n    ///  emit a message indicating that the new address is set. It's up to clients of this\n    ///  contract to update to the new contract address in that case. (This contract will\n    ///  be paused indefinitely if such an upgrade takes place.)\n    /// @param _v2Address new address\n    function setNewAddress(address _v2Address) external onlyAdmin whenPaused {\n        newContractAddress = _v2Address;\n        ContractUpgrade(_v2Address);\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function Ownable() public{\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner(){\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner{\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n\ncontract PausableBattle is Ownable {\n    event PausePVP(bool paused);\n    event PauseTournament(bool paused);\n    \n    bool public pvpPaused = false;\n    bool public tournamentPaused = false;\n    \n    /** PVP */\n    modifier PVPNotPaused(){\n        require(!pvpPaused);\n        _;\n    }\n\n    modifier PVPPaused{\n        require(pvpPaused);\n        _;\n    }\n\n    function pausePVP() public onlyOwner PVPNotPaused {\n        pvpPaused = true;\n        PausePVP(true);\n    }\n\n    function unpausePVP() public onlyOwner PVPPaused {\n        pvpPaused = false;\n        PausePVP(false);\n    }\n    \n    /** Tournament */\n    modifier TournamentNotPaused(){\n        require(!tournamentPaused);\n        _;\n    }\n\n    modifier TournamentPaused{\n        require(tournamentPaused);\n        _;\n    }\n\n    function pauseTournament() public onlyOwner TournamentNotPaused {\n        tournamentPaused = true;\n        PauseTournament(true);\n    }\n\n    function unpauseTournament() public onlyOwner TournamentPaused {\n        tournamentPaused = false;\n        PauseTournament(false);\n    }\n    \n}\n\ncontract Pausable is Ownable {\n    event Pause();\n\n    event Unpause();\n\n    bool public paused = false;\n\n    /**\n     * @dev modifier to allow actions only when the contract IS paused\n     */\n    modifier whenNotPaused(){\n        require(!paused);\n        _;\n    }\n\n    /**\n     * @dev modifier to allow actions only when the contract IS NOT paused\n     */\n    modifier whenPaused{\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        Unpause();\n    }\n}\n\nlibrary CryptoUtils {\n   \n    /* CLASSES */\n    uint256 internal constant WARRIOR = 0;\n    uint256 internal constant ARCHER = 1;\n    uint256 internal constant MAGE = 2;\n    /* RARITIES */\n    uint256 internal constant COMMON = 1;\n    uint256 internal constant UNCOMMON = 2;\n    uint256 internal constant RARE = 3;\n    uint256 internal constant MYTHIC = 4;\n    uint256 internal constant LEGENDARY = 5;\n    uint256 internal constant UNIQUE = 6;\n    /* LIMITS */\n    uint256 internal constant CLASS_MECHANICS_MAX = 3;\n    uint256 internal constant RARITY_MAX = 6;\n    /*@dev range used for rarity chance computation */\n    uint256 internal constant RARITY_CHANCE_RANGE = 10000000;\n    uint256 internal constant POINTS_TO_LEVEL = 10;\n    /* ATTRIBUTE MASKS */\n    /*@dev range 0-9999 */\n    uint256 internal constant UNIQUE_MASK_0 = 1;\n    /*@dev range 0-9 */\n    uint256 internal constant RARITY_MASK_1 = UNIQUE_MASK_0 * 10000;\n    /*@dev range 0-999 */\n    uint256 internal constant CLASS_VIEW_MASK_2 = RARITY_MASK_1 * 10;\n    /*@dev range 0-999 */\n    uint256 internal constant BODY_COLOR_MASK_3 = CLASS_VIEW_MASK_2 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant EYES_MASK_4 = BODY_COLOR_MASK_3 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant MOUTH_MASK_5 = EYES_MASK_4 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant HEIR_MASK_6 = MOUTH_MASK_5 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant HEIR_COLOR_MASK_7 = HEIR_MASK_6 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant ARMOR_MASK_8 = HEIR_COLOR_MASK_7 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant WEAPON_MASK_9 = ARMOR_MASK_8 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant HAT_MASK_10 = WEAPON_MASK_9 * 1000;\n    /*@dev range 0-99 */\n    uint256 internal constant RUNES_MASK_11 = HAT_MASK_10 * 1000;\n    /*@dev range 0-99 */\n    uint256 internal constant WINGS_MASK_12 = RUNES_MASK_11 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant PET_MASK_13 = WINGS_MASK_12 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant BORDER_MASK_14 = PET_MASK_13 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant BACKGROUND_MASK_15 = BORDER_MASK_14 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant INTELLIGENCE_MASK_16 = BACKGROUND_MASK_15 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant AGILITY_MASK_17 = INTELLIGENCE_MASK_16 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant STRENGTH_MASK_18 = AGILITY_MASK_17 * 100;\n    /*@dev range 0-9 */\n    uint256 internal constant CLASS_MECH_MASK_19 = STRENGTH_MASK_18 * 100;\n    /*@dev range 0-999 */\n    uint256 internal constant RARITY_BONUS_MASK_20 = CLASS_MECH_MASK_19 * 10;\n    /*@dev range 0-9 */\n    uint256 internal constant SPECIALITY_MASK_21 = RARITY_BONUS_MASK_20 * 1000;\n    /*@dev range 0-99 */\n    uint256 internal constant DAMAGE_MASK_22 = SPECIALITY_MASK_21 * 10;\n    /*@dev range 0-99 */\n    uint256 internal constant AURA_MASK_23 = DAMAGE_MASK_22 * 100;\n    /*@dev 20 decimals left */\n    uint256 internal constant BASE_MASK_24 = AURA_MASK_23 * 100;\n    \n    \n    /* SPECIAL PERKS */\n    uint256 internal constant MINER_PERK = 1;\n    \n    \n    /* PARAM INDEXES */\n    uint256 internal constant BODY_COLOR_MAX_INDEX_0 = 0;\n    uint256 internal constant EYES_MAX_INDEX_1 = 1;\n    uint256 internal constant MOUTH_MAX_2 = 2;\n    uint256 internal constant HAIR_MAX_3 = 3;\n    uint256 internal constant HEIR_COLOR_MAX_4 = 4;\n    uint256 internal constant ARMOR_MAX_5 = 5;\n    uint256 internal constant WEAPON_MAX_6 = 6;\n    uint256 internal constant HAT_MAX_7 = 7;\n    uint256 internal constant RUNES_MAX_8 = 8;\n    uint256 internal constant WINGS_MAX_9 = 9;\n    uint256 internal constant PET_MAX_10 = 10;\n    uint256 internal constant BORDER_MAX_11 = 11;\n    uint256 internal constant BACKGROUND_MAX_12 = 12;\n    uint256 internal constant UNIQUE_INDEX_13 = 13;\n    uint256 internal constant LEGENDARY_INDEX_14 = 14;\n    uint256 internal constant MYTHIC_INDEX_15 = 15;\n    uint256 internal constant RARE_INDEX_16 = 16;\n    uint256 internal constant UNCOMMON_INDEX_17 = 17;\n    uint256 internal constant UNIQUE_TOTAL_INDEX_18 = 18;\n    \n     /* PACK PVP DATA LOGIC */\n    //pvp data\n    uint256 internal constant CLASS_PACK_0 = 1;\n    uint256 internal constant RARITY_BONUS_PACK_1 = CLASS_PACK_0 * 10;\n    uint256 internal constant RARITY_PACK_2 = RARITY_BONUS_PACK_1 * 1000;\n    uint256 internal constant EXPERIENCE_PACK_3 = RARITY_PACK_2 * 10;\n    uint256 internal constant INTELLIGENCE_PACK_4 = EXPERIENCE_PACK_3 * 1000;\n    uint256 internal constant AGILITY_PACK_5 = INTELLIGENCE_PACK_4 * 100;\n    uint256 internal constant STRENGTH_PACK_6 = AGILITY_PACK_5 * 100;\n    uint256 internal constant BASE_DAMAGE_PACK_7 = STRENGTH_PACK_6 * 100;\n    uint256 internal constant PET_PACK_8 = BASE_DAMAGE_PACK_7 * 100;\n    uint256 internal constant AURA_PACK_9 = PET_PACK_8 * 100;\n    uint256 internal constant WARRIOR_ID_PACK_10 = AURA_PACK_9 * 100;\n    uint256 internal constant PVP_CYCLE_PACK_11 = WARRIOR_ID_PACK_10 * 10**10;\n    uint256 internal constant RATING_PACK_12 = PVP_CYCLE_PACK_11 * 10**10;\n    uint256 internal constant PVP_BASE_PACK_13 = RATING_PACK_12 * 10**10;//NB rating must be at the END!\n    \n    //tournament data\n    uint256 internal constant HP_PACK_0 = 1;\n    uint256 internal constant DAMAGE_PACK_1 = HP_PACK_0 * 10**12;\n    uint256 internal constant ARMOR_PACK_2 = DAMAGE_PACK_1 * 10**12;\n    uint256 internal constant DODGE_PACK_3 = ARMOR_PACK_2 * 10**12;\n    uint256 internal constant PENETRATION_PACK_4 = DODGE_PACK_3 * 10**12;\n    uint256 internal constant COMBINE_BASE_PACK_5 = PENETRATION_PACK_4 * 10**12;\n    \n    /* MISC CONSTANTS */\n    uint256 internal constant MAX_ID_SIZE = 10000000000;\n    int256 internal constant PRECISION = 1000000;\n    \n    uint256 internal constant BATTLES_PER_CONTENDER = 10;//10x100\n    uint256 internal constant BATTLES_PER_CONTENDER_SUM = BATTLES_PER_CONTENDER * 100;//10x100\n    \n    uint256 internal constant LEVEL_BONUSES = 98898174676155504541373431282523211917151413121110;\n    \n    //ucommon bonuses\n    uint256 internal constant BONUS_NONE = 0;\n    uint256 internal constant BONUS_HP = 1;\n    uint256 internal constant BONUS_ARMOR = 2;\n    uint256 internal constant BONUS_CRIT_CHANCE = 3;\n    uint256 internal constant BONUS_CRIT_MULT = 4;\n    uint256 internal constant BONUS_PENETRATION = 5;\n    //rare bonuses\n    uint256 internal constant BONUS_STR = 6;\n    uint256 internal constant BONUS_AGI = 7;\n    uint256 internal constant BONUS_INT = 8;\n    uint256 internal constant BONUS_DAMAGE = 9;\n    \n    //bonus value database, \n    uint256 internal constant BONUS_DATA = 16060606140107152000;\n    //pets database\n    uint256 internal constant PETS_DATA = 287164235573728325842459981692000;\n    \n    uint256 internal constant PET_AURA = 2;\n    uint256 internal constant PET_PARAM_1 = 1;\n    uint256 internal constant PET_PARAM_2 = 0;\n\n    /* GETTERS */\n\tfunction getUniqueValue(uint256 identity) internal pure returns(uint256){\n\t\treturn identity % RARITY_MASK_1;\n\t}\n\n    function getRarityValue(uint256 identity) internal pure returns(uint256){\n        return (identity % CLASS_VIEW_MASK_2) / RARITY_MASK_1;\n    }\n\n\tfunction getClassViewValue(uint256 identity) internal pure returns(uint256){\n\t\treturn (identity % BODY_COLOR_MASK_3) / CLASS_VIEW_MASK_2;\n\t}\n\n\tfunction getBodyColorValue(uint256 identity) internal pure returns(uint256){\n        return (identity % EYES_MASK_4) / BODY_COLOR_MASK_3;\n    }\n\n    function getEyesValue(uint256 identity) internal pure returns(uint256){\n        return (identity % MOUTH_MASK_5) / EYES_MASK_4;\n    }\n\n    function getMouthValue(uint256 identity) internal pure returns(uint256){\n        return (identity % HEIR_MASK_6) / MOUTH_MASK_5;\n    }\n\n    function getHairValue(uint256 identity) internal pure returns(uint256){\n        return (identity % HEIR_COLOR_MASK_7) / HEIR_MASK_6;\n    }\n\n    function getHairColorValue(uint256 identity) internal pure returns(uint256){\n        return (identity % ARMOR_MASK_8) / HEIR_COLOR_MASK_7;\n    }\n\n    function getArmorValue(uint256 identity) internal pure returns(uint256){\n        return (identity % WEAPON_MASK_9) / ARMOR_MASK_8;\n    }\n\n    function getWeaponValue(uint256 identity) internal pure returns(uint256){\n        return (identity % HAT_MASK_10) / WEAPON_MASK_9;\n    }\n\n    function getHatValue(uint256 identity) internal pure returns(uint256){\n        return (identity % RUNES_MASK_11) / HAT_MASK_10;\n    }\n\n    function getRunesValue(uint256 identity) internal pure returns(uint256){\n        return (identity % WINGS_MASK_12) / RUNES_MASK_11;\n    }\n\n    function getWingsValue(uint256 identity) internal pure returns(uint256){\n        return (identity % PET_MASK_13) / WINGS_MASK_12;\n    }\n\n    function getPetValue(uint256 identity) internal pure returns(uint256){\n        return (identity % BORDER_MASK_14) / PET_MASK_13;\n    }\n\n\tfunction getBorderValue(uint256 identity) internal pure returns(uint256){\n\t\treturn (identity % BACKGROUND_MASK_15) / BORDER_MASK_14;\n\t}\n\n\tfunction getBackgroundValue(uint256 identity) internal pure returns(uint256){\n\t\treturn (identity % INTELLIGENCE_MASK_16) / BACKGROUND_MASK_15;\n\t}\n\n    function getIntelligenceValue(uint256 identity) internal pure returns(uint256){\n        return (identity % AGILITY_MASK_17) / INTELLIGENCE_MASK_16;\n    }\n\n    function getAgilityValue(uint256 identity) internal pure returns(uint256){\n        return ((identity % STRENGTH_MASK_18) / AGILITY_MASK_17);\n    }\n\n    function getStrengthValue(uint256 identity) internal pure returns(uint256){\n        return ((identity % CLASS_MECH_MASK_19) / STRENGTH_MASK_18);\n    }\n\n    function getClassMechValue(uint256 identity) internal pure returns(uint256){\n        return (identity % RARITY_BONUS_MASK_20) / CLASS_MECH_MASK_19;\n    }\n\n    function getRarityBonusValue(uint256 identity) internal pure returns(uint256){\n        return (identity % SPECIALITY_MASK_21) / RARITY_BONUS_MASK_20;\n    }\n\n    function getSpecialityValue(uint256 identity) internal pure returns(uint256){\n        return (identity % DAMAGE_MASK_22) / SPECIALITY_MASK_21;\n    }\n    \n    function getDamageValue(uint256 identity) internal pure returns(uint256){\n        return (identity % AURA_MASK_23) / DAMAGE_MASK_22;\n    }\n\n    function getAuraValue(uint256 identity) internal pure returns(uint256){\n        return ((identity % BASE_MASK_24) / AURA_MASK_23);\n    }\n\n    /* SETTERS */\n    function _setUniqueValue0(uint256 value) internal pure returns(uint256){\n        require(value < RARITY_MASK_1);\n        return value * UNIQUE_MASK_0;\n    }\n\n    function _setRarityValue1(uint256 value) internal pure returns(uint256){\n        require(value < (CLASS_VIEW_MASK_2 / RARITY_MASK_1));\n        return value * RARITY_MASK_1;\n    }\n\n    function _setClassViewValue2(uint256 value) internal pure returns(uint256){\n        require(value < (BODY_COLOR_MASK_3 / CLASS_VIEW_MASK_2));\n        return value * CLASS_VIEW_MASK_2;\n    }\n\n    function _setBodyColorValue3(uint256 value) internal pure returns(uint256){\n        require(value < (EYES_MASK_4 / BODY_COLOR_MASK_3));\n        return value * BODY_COLOR_MASK_3;\n    }\n\n    function _setEyesValue4(uint256 value) internal pure returns(uint256){\n        require(value < (MOUTH_MASK_5 / EYES_MASK_4));\n        return value * EYES_MASK_4;\n    }\n\n    function _setMouthValue5(uint256 value) internal pure returns(uint256){\n        require(value < (HEIR_MASK_6 / MOUTH_MASK_5));\n        return value * MOUTH_MASK_5;\n    }\n\n    function _setHairValue6(uint256 value) internal pure returns(uint256){\n        require(value < (HEIR_COLOR_MASK_7 / HEIR_MASK_6));\n        return value * HEIR_MASK_6;\n    }\n\n    function _setHairColorValue7(uint256 value) internal pure returns(uint256){\n        require(value < (ARMOR_MASK_8 / HEIR_COLOR_MASK_7));\n        return value * HEIR_COLOR_MASK_7;\n    }\n\n    function _setArmorValue8(uint256 value) internal pure returns(uint256){\n        require(value < (WEAPON_MASK_9 / ARMOR_MASK_8));\n        return value * ARMOR_MASK_8;\n    }\n\n    function _setWeaponValue9(uint256 value) internal pure returns(uint256){\n        require(value < (HAT_MASK_10 / WEAPON_MASK_9));\n        return value * WEAPON_MASK_9;\n    }\n\n    function _setHatValue10(uint256 value) internal pure returns(uint256){\n        require(value < (RUNES_MASK_11 / HAT_MASK_10));\n        return value * HAT_MASK_10;\n    }\n\n    function _setRunesValue11(uint256 value) internal pure returns(uint256){\n        require(value < (WINGS_MASK_12 / RUNES_MASK_11));\n        return value * RUNES_MASK_11;\n    }\n\n    function _setWingsValue12(uint256 value) internal pure returns(uint256){\n        require(value < (PET_MASK_13 / WINGS_MASK_12));\n        return value * WINGS_MASK_12;\n    }\n\n    function _setPetValue13(uint256 value) internal pure returns(uint256){\n        require(value < (BORDER_MASK_14 / PET_MASK_13));\n        return value * PET_MASK_13;\n    }\n\n    function _setBorderValue14(uint256 value) internal pure returns(uint256){\n        require(value < (BACKGROUND_MASK_15 / BORDER_MASK_14));\n        return value * BORDER_MASK_14;\n    }\n\n    function _setBackgroundValue15(uint256 value) internal pure returns(uint256){\n        require(value < (INTELLIGENCE_MASK_16 / BACKGROUND_MASK_15));\n        return value * BACKGROUND_MASK_15;\n    }\n\n    function _setIntelligenceValue16(uint256 value) internal pure returns(uint256){\n        require(value < (AGILITY_MASK_17 / INTELLIGENCE_MASK_16));\n        return value * INTELLIGENCE_MASK_16;\n    }\n\n    function _setAgilityValue17(uint256 value) internal pure returns(uint256){\n        require(value < (STRENGTH_MASK_18 / AGILITY_MASK_17));\n        return value * AGILITY_MASK_17;\n    }\n\n    function _setStrengthValue18(uint256 value) internal pure returns(uint256){\n        require(value < (CLASS_MECH_MASK_19 / STRENGTH_MASK_18));\n        return value * STRENGTH_MASK_18;\n    }\n\n    function _setClassMechValue19(uint256 value) internal pure returns(uint256){\n        require(value < (RARITY_BONUS_MASK_20 / CLASS_MECH_MASK_19));\n        return value * CLASS_MECH_MASK_19;\n    }\n\n    function _setRarityBonusValue20(uint256 value) internal pure returns(uint256){\n        require(value < (SPECIALITY_MASK_21 / RARITY_BONUS_MASK_20));\n        return value * RARITY_BONUS_MASK_20;\n    }\n\n    function _setSpecialityValue21(uint256 value) internal pure returns(uint256){\n        require(value < (DAMAGE_MASK_22 / SPECIALITY_MASK_21));\n        return value * SPECIALITY_MASK_21;\n    }\n    \n    function _setDamgeValue22(uint256 value) internal pure returns(uint256){\n        require(value < (AURA_MASK_23 / DAMAGE_MASK_22));\n        return value * DAMAGE_MASK_22;\n    }\n\n    function _setAuraValue23(uint256 value) internal pure returns(uint256){\n        require(value < (BASE_MASK_24 / AURA_MASK_23));\n        return value * AURA_MASK_23;\n    }\n    \n    /* WARRIOR IDENTITY GENERATION */\n    function _computeRunes(uint256 _rarity) internal pure returns (uint256){\n        return _rarity > UNCOMMON ? _rarity - UNCOMMON : 0;// 1 + _random(0, max, hash, WINGS_MASK_12, RUNES_MASK_11) : 0;\n    }\n\n    function _computeWings(uint256 _rarity, uint256 max, uint256 hash) internal pure returns (uint256){\n        return _rarity > RARE ?  1 + _random(0, max, hash, PET_MASK_13, WINGS_MASK_12) : 0;\n    }\n\n    function _computePet(uint256 _rarity, uint256 max, uint256 hash) internal pure returns (uint256){\n        return _rarity > MYTHIC ? 1 + _random(0, max, hash, BORDER_MASK_14, PET_MASK_13) : 0;\n    }\n\n    function _computeBorder(uint256 _rarity) internal pure returns (uint256){\n        return _rarity >= COMMON ? _rarity - 1 : 0;\n    }\n\n    function _computeBackground(uint256 _rarity) internal pure returns (uint256){\n        return _rarity;\n    }\n    \n    function _unpackPetData(uint256 index) internal pure returns(uint256){\n        return (PETS_DATA % (1000 ** (index + 1)) / (1000 ** index));\n    }\n    \n    function _getPetBonus1(uint256 _pet) internal pure returns(uint256) {\n        return (_pet % (10 ** (PET_PARAM_1 + 1)) / (10 ** PET_PARAM_1));\n    }\n    \n    function _getPetBonus2(uint256 _pet) internal pure returns(uint256) {\n        return (_pet % (10 ** (PET_PARAM_2 + 1)) / (10 ** PET_PARAM_2));\n    }\n    \n    function _getPetAura(uint256 _pet) internal pure returns(uint256) {\n        return (_pet % (10 ** (PET_AURA + 1)) / (10 ** PET_AURA));\n    }\n    \n    function _getBattleBonus(uint256 _setBonusIndex, uint256 _currentBonusIndex, uint256 _petData, uint256 _warriorAuras, uint256 _petAuras) internal pure returns(int256) {\n        int256 bonus = 0;\n        if (_setBonusIndex == _currentBonusIndex) {\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION;\n        }\n        //add pet bonuses\n        if (_setBonusIndex == _getPetBonus1(_petData)) {\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\n        }\n        if (_setBonusIndex == _getPetBonus2(_petData)) {\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\n        }\n        //add warrior aura bonuses\n        if (isAuraSet(_warriorAuras, uint8(_setBonusIndex))) {//warriors receive half bonuses from auras\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\n        }\n        //add pet aura bonuses\n        if (isAuraSet(_petAuras, uint8(_setBonusIndex))) {//pets receive full bonues from auras\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION;\n        }\n        return bonus;\n    }\n    \n    function _computeRarityBonus(uint256 _rarity, uint256 hash) internal pure returns (uint256){\n        if (_rarity == UNCOMMON) {\n            return 1 + _random(0, BONUS_PENETRATION, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\n        }\n        if (_rarity == RARE) {\n            return 1 + _random(BONUS_PENETRATION, BONUS_DAMAGE, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\n        }\n        if (_rarity >= MYTHIC) {\n            return 1 + _random(0, BONUS_DAMAGE, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\n        }\n        return BONUS_NONE;\n    }\n\n    function _computeAura(uint256 _rarity, uint256 hash) internal pure returns (uint256){\n        if (_rarity >= MYTHIC) {\n            return 1 + _random(0, BONUS_DAMAGE, hash, BASE_MASK_24, AURA_MASK_23);\n        }\n        return BONUS_NONE;\n    }\n    \n\tfunction _computeRarity(uint256 _reward, uint256 _unique, uint256 _legendary, \n\t    uint256 _mythic, uint256 _rare, uint256 _uncommon) internal pure returns(uint256){\n\t        \n        uint256 range = _unique + _legendary + _mythic + _rare + _uncommon;\n        if (_reward >= range) return COMMON; // common\n        if (_reward >= (range = (range - _uncommon))) return UNCOMMON;\n        if (_reward >= (range = (range - _rare))) return RARE;\n        if (_reward >= (range = (range - _mythic))) return MYTHIC;\n        if (_reward >= (range = (range - _legendary))) return LEGENDARY;\n        if (_reward < range) return UNIQUE;\n        return COMMON;\n    }\n    \n    function _computeUniqueness(uint256 _rarity, uint256 nextUnique) internal pure returns (uint256){\n        return _rarity == UNIQUE ? nextUnique : 0;\n    }\n    \n    /* identity packing */\n    /* @returns bonus value which depends on speciality value,\n     * if speciality == 1 (miner), then bonus value will be equal 4,\n     * otherwise 1\n     */\n    function _getBonus(uint256 identity) internal pure returns(uint256){\n        return getSpecialityValue(identity) == MINER_PERK ? 4 : 1;\n    }\n    \n\n    function _computeAndSetBaseParameters16_18_22(uint256 _hash) internal pure returns (uint256, uint256){\n        uint256 identity = 0;\n\n        uint256 damage = 35 + _random(0, 21, _hash, AURA_MASK_23, DAMAGE_MASK_22);\n        \n        uint256 strength = 45 + _random(0, 26, _hash, CLASS_MECH_MASK_19, STRENGTH_MASK_18);\n        uint256 agility = 15 + (125 - damage - strength);\n        uint256 intelligence = 155 - strength - agility - damage;\n        (strength, agility, intelligence) = _shuffleParams(strength, agility, intelligence, _hash);\n        \n        identity += _setStrengthValue18(strength);\n        identity += _setAgilityValue17(agility);\n\t\tidentity += _setIntelligenceValue16(intelligence);\n\t\tidentity += _setDamgeValue22(damage);\n        \n        uint256 classMech = strength > agility ? (strength > intelligence ? WARRIOR : MAGE) : (agility > intelligence ? ARCHER : MAGE);\n        return (identity, classMech);\n    }\n    \n    function _shuffleParams(uint256 param1, uint256 param2, uint256 param3, uint256 _hash) internal pure returns(uint256, uint256, uint256) {\n        uint256 temp = param1;\n        if (_hash % 2 == 0) {\n            temp = param1;\n            param1 = param2;\n            param2 = temp;\n        }\n        if ((_hash / 10 % 2) == 0) {\n            temp = param2;\n            param2 = param3;\n            param3 = temp;\n        }\n        if ((_hash / 100 % 2) == 0) {\n            temp = param1;\n            param1 = param2;\n            param2 = temp;\n        }\n        return (param1, param2, param3);\n    }\n    \n    \n    /* RANDOM */\n    function _random(uint256 _min, uint256 _max, uint256 _hash, uint256 _reminder, uint256 _devider) internal pure returns (uint256){\n        return ((_hash % _reminder) / _devider) % (_max - _min) + _min;\n    }\n\n    function _random(uint256 _min, uint256 _max, uint256 _hash) internal pure returns (uint256){\n        return _hash % (_max - _min) + _min;\n    }\n\n    function _getTargetBlock(uint256 _targetBlock) internal view returns(uint256){\n        uint256 currentBlock = block.number;\n        uint256 target = currentBlock - (currentBlock % 256) + (_targetBlock % 256);\n        if (target >= currentBlock) {\n            return (target - 256);\n        }\n        return target;\n    }\n    \n    function _getMaxRarityChance() internal pure returns(uint256){\n        return RARITY_CHANCE_RANGE;\n    }\n    \n    function generateWarrior(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 specialPerc, uint32[19] memory params) internal view returns (uint256) {\n        _targetBlock = _getTargetBlock(_targetBlock);\n        \n        uint256 identity;\n        uint256 hash = uint256(keccak256(block.blockhash(_targetBlock), _heroIdentity, block.coinbase, block.difficulty));\n        //0 _heroLevel produces warriors of COMMON rarity\n        uint256 rarityChance = _heroLevel == 0 ? RARITY_CHANCE_RANGE : \n        \t_random(0, RARITY_CHANCE_RANGE, hash) / (_heroLevel * _getBonus(_heroIdentity)); // 0 - 10 000 000\n        uint256 rarity = _computeRarity(rarityChance, \n            params[UNIQUE_INDEX_13],params[LEGENDARY_INDEX_14], params[MYTHIC_INDEX_15], params[RARE_INDEX_16], params[UNCOMMON_INDEX_17]);\n            \n        uint256 classMech;\n        \n        // start\n        (identity, classMech) = _computeAndSetBaseParameters16_18_22(hash);\n        \n        identity += _setUniqueValue0(_computeUniqueness(rarity, params[UNIQUE_TOTAL_INDEX_18] + 1));\n        identity += _setRarityValue1(rarity);\n        identity += _setClassViewValue2(classMech); // 1 to 1 with classMech\n        \n        identity += _setBodyColorValue3(1 + _random(0, params[BODY_COLOR_MAX_INDEX_0], hash, EYES_MASK_4, BODY_COLOR_MASK_3));\n        identity += _setEyesValue4(1 + _random(0, params[EYES_MAX_INDEX_1], hash, MOUTH_MASK_5, EYES_MASK_4));\n        identity += _setMouthValue5(1 + _random(0, params[MOUTH_MAX_2], hash, HEIR_MASK_6, MOUTH_MASK_5));\n        identity += _setHairValue6(1 + _random(0, params[HAIR_MAX_3], hash, HEIR_COLOR_MASK_7, HEIR_MASK_6));\n        identity += _setHairColorValue7(1 + _random(0, params[HEIR_COLOR_MAX_4], hash, ARMOR_MASK_8, HEIR_COLOR_MASK_7));\n        identity += _setArmorValue8(1 + _random(0, params[ARMOR_MAX_5], hash, WEAPON_MASK_9, ARMOR_MASK_8));\n        identity += _setWeaponValue9(1 + _random(0, params[WEAPON_MAX_6], hash, HAT_MASK_10, WEAPON_MASK_9));\n        identity += _setHatValue10(_random(0, params[HAT_MAX_7], hash, RUNES_MASK_11, HAT_MASK_10));//removed +1\n        \n        identity += _setRunesValue11(_computeRunes(rarity));\n        identity += _setWingsValue12(_computeWings(rarity, params[WINGS_MAX_9], hash));\n        identity += _setPetValue13(_computePet(rarity, params[PET_MAX_10], hash));\n        identity += _setBorderValue14(_computeBorder(rarity)); // 1 to 1 with rarity\n        identity += _setBackgroundValue15(_computeBackground(rarity)); // 1 to 1 with rarity\n        \n        identity += _setClassMechValue19(classMech);\n\n        identity += _setRarityBonusValue20(_computeRarityBonus(rarity, hash));\n        identity += _setSpecialityValue21(specialPerc); // currently only miner (1)\n        \n        identity += _setAuraValue23(_computeAura(rarity, hash));\n        // end\n        return identity;\n    }\n    \n\tfunction _changeParameter(uint256 _paramIndex, uint32 _value, uint32[19] storage parameters) internal {\n\t\t//we can change only view parameters, and unique count in max range <= 100\n\t\trequire(_paramIndex >= BODY_COLOR_MAX_INDEX_0 && _paramIndex <= UNIQUE_INDEX_13);\n\t\t//we can NOT set pet, border and background values,\n\t\t//those values have special logic behind them\n\t\trequire(\n\t\t    _paramIndex != RUNES_MAX_8 && \n\t\t    _paramIndex != PET_MAX_10 && \n\t\t    _paramIndex != BORDER_MAX_11 && \n\t\t    _paramIndex != BACKGROUND_MAX_12\n\t\t);\n\t\t//value of bodyColor, eyes, mouth, hair, hairColor, armor, weapon, hat must be < 1000\n\t\trequire(_paramIndex > HAT_MAX_7 || _value < 1000);\n\t\t//value of wings,  must be < 100\n\t\trequire(_paramIndex > BACKGROUND_MAX_12 || _value < 100);\n\t\t//check that max total number of UNIQUE warriors that we can emit is not > 100\n\t\trequire(_paramIndex != UNIQUE_INDEX_13 || (_value + parameters[UNIQUE_TOTAL_INDEX_18]) <= 100);\n\t\t\n\t\tparameters[_paramIndex] = _value;\n    }\n    \n\tfunction _recordWarriorData(uint256 identity, uint32[19] storage parameters) internal {\n        uint256 rarity = getRarityValue(identity);\n        if (rarity == UNCOMMON) { // uncommon\n            parameters[UNCOMMON_INDEX_17]--;\n            return;\n        }\n        if (rarity == RARE) { // rare\n            parameters[RARE_INDEX_16]--;\n            return;\n        }\n        if (rarity == MYTHIC) { // mythic\n            parameters[MYTHIC_INDEX_15]--;\n            return;\n        }\n        if (rarity == LEGENDARY) { // legendary\n            parameters[LEGENDARY_INDEX_14]--;\n            return;\n        }\n        if (rarity == UNIQUE) { // unique\n            parameters[UNIQUE_INDEX_13]--;\n            parameters[UNIQUE_TOTAL_INDEX_18] ++;\n            return;\n        }\n    }\n    \n    function _validateIdentity(uint256 _identity, uint32[19] memory params) internal pure returns(bool){\n        uint256 rarity = getRarityValue(_identity);\n        require(rarity <= UNIQUE);\n        \n        require(\n            rarity <= COMMON ||//common \n            (rarity == UNCOMMON && params[UNCOMMON_INDEX_17] > 0) ||//uncommon\n            (rarity == RARE && params[RARE_INDEX_16] > 0) ||//rare\n            (rarity == MYTHIC && params[MYTHIC_INDEX_15] > 0) ||//mythic\n            (rarity == LEGENDARY && params[LEGENDARY_INDEX_14] > 0) ||//legendary\n            (rarity == UNIQUE && params[UNIQUE_INDEX_13] > 0)//unique\n        );\n        require(rarity != UNIQUE || getUniqueValue(_identity) > params[UNIQUE_TOTAL_INDEX_18]);\n        \n        //check battle parameters\n        require(\n            getStrengthValue(_identity) < 100 &&\n            getAgilityValue(_identity) < 100 &&\n            getIntelligenceValue(_identity) < 100 &&\n            getDamageValue(_identity) <= 55\n        );\n        require(getClassMechValue(_identity) <= MAGE);\n        require(getClassMechValue(_identity) == getClassViewValue(_identity));\n        require(getSpecialityValue(_identity) <= MINER_PERK);\n        require(getRarityBonusValue(_identity) <= BONUS_DAMAGE);\n        require(getAuraValue(_identity) <= BONUS_DAMAGE);\n        \n        //check view\n        require(getBodyColorValue(_identity) <= params[BODY_COLOR_MAX_INDEX_0]);\n        require(getEyesValue(_identity) <= params[EYES_MAX_INDEX_1]);\n        require(getMouthValue(_identity) <= params[MOUTH_MAX_2]);\n        require(getHairValue(_identity) <= params[HAIR_MAX_3]);\n        require(getHairColorValue(_identity) <= params[HEIR_COLOR_MAX_4]);\n        require(getArmorValue(_identity) <= params[ARMOR_MAX_5]);\n        require(getWeaponValue(_identity) <= params[WEAPON_MAX_6]);\n        require(getHatValue(_identity) <= params[HAT_MAX_7]);\n        require(getRunesValue(_identity) <= params[RUNES_MAX_8]);\n        require(getWingsValue(_identity) <= params[WINGS_MAX_9]);\n        require(getPetValue(_identity) <= params[PET_MAX_10]);\n        require(getBorderValue(_identity) <= params[BORDER_MAX_11]);\n        require(getBackgroundValue(_identity) <= params[BACKGROUND_MAX_12]);\n        \n        return true;\n    }\n    \n    /* UNPACK METHODS */\n    //common\n    function _unpackClassValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % RARITY_PACK_2 / CLASS_PACK_0);\n    }\n    \n    function _unpackRarityBonusValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % RARITY_PACK_2 / RARITY_BONUS_PACK_1);\n    }\n    \n    function _unpackRarityValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % EXPERIENCE_PACK_3 / RARITY_PACK_2);\n    }\n    \n    function _unpackExpValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % INTELLIGENCE_PACK_4 / EXPERIENCE_PACK_3);\n    }\n\n    function _unpackLevelValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % INTELLIGENCE_PACK_4) / (EXPERIENCE_PACK_3 * POINTS_TO_LEVEL);\n    }\n    \n    function _unpackIntelligenceValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % AGILITY_PACK_5 / INTELLIGENCE_PACK_4);\n    }\n    \n    function _unpackAgilityValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % STRENGTH_PACK_6 / AGILITY_PACK_5);\n    }\n    \n    function _unpackStrengthValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % BASE_DAMAGE_PACK_7 / STRENGTH_PACK_6);\n    }\n\n    function _unpackBaseDamageValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % PET_PACK_8 / BASE_DAMAGE_PACK_7);\n    }\n    \n    function _unpackPetValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % AURA_PACK_9 / PET_PACK_8);\n    }\n    \n    function _unpackAuraValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % WARRIOR_ID_PACK_10 / AURA_PACK_9);\n    }\n    //\n    //pvp unpack\n    function _unpackIdValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % PVP_CYCLE_PACK_11 / WARRIOR_ID_PACK_10);\n    }\n    \n    function _unpackCycleValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % RATING_PACK_12 / PVP_CYCLE_PACK_11);\n    }\n    \n    function _unpackRatingValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % PVP_BASE_PACK_13 / RATING_PACK_12);\n    }\n    \n    //max cycle skip value cant be more than 1000000000\n    function _changeCycleValue(uint256 packedValue, uint256 newValue) internal pure returns(uint256){\n        newValue = newValue > 1000000000 ? 1000000000 : newValue;\n        return packedValue - (_unpackCycleValue(packedValue) * PVP_CYCLE_PACK_11) + newValue * PVP_CYCLE_PACK_11;\n    }\n    \n    function _packWarriorCommonData(uint256 _identity, uint256 _experience) internal pure returns(uint256){\n        uint256 packedData = 0;\n        packedData += getClassMechValue(_identity) * CLASS_PACK_0;\n        packedData += getRarityBonusValue(_identity) * RARITY_BONUS_PACK_1;\n        packedData += getRarityValue(_identity) * RARITY_PACK_2;\n        packedData += _experience * EXPERIENCE_PACK_3;\n        packedData += getIntelligenceValue(_identity) * INTELLIGENCE_PACK_4;\n        packedData += getAgilityValue(_identity) * AGILITY_PACK_5;\n        packedData += getStrengthValue(_identity) * STRENGTH_PACK_6;\n        packedData += getDamageValue(_identity) * BASE_DAMAGE_PACK_7;\n        packedData += getPetValue(_identity) * PET_PACK_8;\n        \n        return packedData;\n    }\n    \n    function _packWarriorPvpData(uint256 _identity, uint256 _rating, uint256 _pvpCycle, uint256 _warriorId, uint256 _experience) internal pure returns(uint256){\n        uint256 packedData = _packWarriorCommonData(_identity, _experience);\n        packedData += _warriorId * WARRIOR_ID_PACK_10;\n        packedData += _pvpCycle * PVP_CYCLE_PACK_11;\n        //rating MUST have most significant value!\n        packedData += _rating * RATING_PACK_12;\n        return packedData;\n    }\n    \n    /* TOURNAMENT BATTLES */\n    \n    \n    function _packWarriorIds(uint256[] memory packedWarriors) internal pure returns(uint256){\n        uint256 packedIds = 0;\n        uint256 length = packedWarriors.length;\n        for(uint256 i = 0; i < length; i ++) {\n            packedIds += (MAX_ID_SIZE ** i) * _unpackIdValue(packedWarriors[i]);\n        }\n        return packedIds;\n    }\n\n    function _unpackWarriorId(uint256 packedIds, uint256 index) internal pure returns(uint256){\n        return (packedIds % (MAX_ID_SIZE ** (index + 1)) / (MAX_ID_SIZE ** index));\n    }\n    \n    function _packCombinedParams(int256 hp, int256 damage, int256 armor, int256 dodge, int256 penetration) internal pure returns(uint256) {\n        uint256 combinedWarrior = 0;\n        combinedWarrior += uint256(hp) * HP_PACK_0;\n        combinedWarrior += uint256(damage) * DAMAGE_PACK_1;\n        combinedWarrior += uint256(armor) * ARMOR_PACK_2;\n        combinedWarrior += uint256(dodge) * DODGE_PACK_3;\n        combinedWarrior += uint256(penetration) * PENETRATION_PACK_4;\n        return combinedWarrior;\n    }\n    \n    function _unpackProtectionParams(uint256 combinedWarrior) internal pure returns \n    (int256 hp, int256 armor, int256 dodge){\n        hp = int256(combinedWarrior % DAMAGE_PACK_1 / HP_PACK_0);\n        armor = int256(combinedWarrior % DODGE_PACK_3 / ARMOR_PACK_2);\n        dodge = int256(combinedWarrior % PENETRATION_PACK_4 / DODGE_PACK_3);\n    }\n    \n    function _unpackAttackParams(uint256 combinedWarrior) internal pure returns(int256 damage, int256 penetration) {\n        damage = int256(combinedWarrior % ARMOR_PACK_2 / DAMAGE_PACK_1);\n        penetration = int256(combinedWarrior % COMBINE_BASE_PACK_5 / PENETRATION_PACK_4);\n    }\n    \n    function _combineWarriors(uint256[] memory packedWarriors) internal pure returns (uint256) {\n        int256 hp;\n        int256 damage;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\tint256 penetration;\n\t\t\n\t\t(hp, damage, armor, dodge, penetration) = _computeCombinedParams(packedWarriors);\n        return _packCombinedParams(hp, damage, armor, dodge, penetration);\n    }\n    \n    function _computeCombinedParams(uint256[] memory packedWarriors) internal pure returns \n    (int256 totalHp, int256 totalDamage, int256 maxArmor, int256 maxDodge, int256 maxPenetration){\n        uint256 length = packedWarriors.length;\n        \n        int256 hp;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\tint256 penetration;\n\t\t\n\t\tuint256 warriorAuras;\n\t\tuint256 petAuras;\n\t\t(warriorAuras, petAuras) = _getAurasData(packedWarriors);\n\t\t\n\t\tuint256 packedWarrior;\n        for(uint256 i = 0; i < length; i ++) {\n            packedWarrior = packedWarriors[i];\n            \n            totalDamage += getDamage(packedWarrior, warriorAuras, petAuras);\n            \n            penetration = getPenetration(packedWarrior, warriorAuras, petAuras);\n            maxPenetration = maxPenetration > penetration ? maxPenetration : penetration;\n\t\t\t(hp, armor, dodge) = _getProtectionParams(packedWarrior, warriorAuras, petAuras);\n            totalHp += hp;\n            maxArmor = maxArmor > armor ? maxArmor : armor;\n            maxDodge = maxDodge > dodge ? maxDodge : dodge;\n        }\n    }\n    \n    function _getAurasData(uint256[] memory packedWarriors) internal pure returns(uint256 warriorAuras, uint256 petAuras) {\n        uint256 length = packedWarriors.length;\n        \n        warriorAuras = 0;\n        petAuras = 0;\n        \n        uint256 packedWarrior;\n        for(uint256 i = 0; i < length; i ++) {\n            packedWarrior = packedWarriors[i];\n            warriorAuras = enableAura(warriorAuras, (_unpackAuraValue(packedWarrior)));\n            petAuras = enableAura(petAuras, (_getPetAura(_unpackPetData(_unpackPetValue(packedWarrior)))));\n        }\n        warriorAuras = filterWarriorAuras(warriorAuras, petAuras);\n        return (warriorAuras, petAuras);\n    }\n    \n    // Get bit value at position\n    function isAuraSet(uint256 aura, uint256 auraIndex) internal pure returns (bool) {\n        return aura & (uint256(0x01) << auraIndex) != 0;\n    }\n    \n    // Set bit value at position\n    function enableAura(uint256 a, uint256 n) internal pure returns (uint256) {\n        return a | (uint256(0x01) << n);\n    }\n    \n    //switch off warrior auras that are enabled in pets auras, pet aura have priority\n    function filterWarriorAuras(uint256 _warriorAuras, uint256 _petAuras) internal pure returns(uint256) {\n        return (_warriorAuras & _petAuras) ^ _warriorAuras;\n    }\n  \n    function _getTournamentBattles(uint256 _numberOfContenders) internal pure returns(uint256) {\n        return (_numberOfContenders * BATTLES_PER_CONTENDER / 2);\n    }\n    \n    function getTournamentBattleResults(uint256[] memory combinedWarriors, uint256 _targetBlock) internal view returns (uint32[] memory results){\n        uint256 length = combinedWarriors.length;\n        results = new uint32[](length);\n\t\t\n\t\tint256 damage1;\n\t\tint256 penetration1;\n\t\t\n\t\tuint256 hash;\n\t\t\n\t\tuint256 randomIndex;\n\t\tuint256 exp = 0;\n\t\tuint256 i;\n\t\tuint256 result;\n        for(i = 0; i < length; i ++) {\n            (damage1, penetration1) = _unpackAttackParams(combinedWarriors[i]);\n            while(results[i] < BATTLES_PER_CONTENDER_SUM) {\n                //if we just started generate new random source\n                //or regenerate if we used all data from it\n                if (exp == 0 || exp > 73) {\n                    hash = uint256(keccak256(block.blockhash(_getTargetBlock(_targetBlock - i)), uint256(damage1) + now));\n                    exp = 0;\n                }\n                //we do not fight with self if there are other warriors\n                randomIndex = (_random(i + 1 < length ? i + 1 : i, length, hash, 1000 * 10**exp, 10**exp));\n                result = getTournamentBattleResult(damage1, penetration1, combinedWarriors[i],\n                    combinedWarriors[randomIndex], hash % (1000 * 10**exp) / 10**exp);\n                results[result == 1 ? i : randomIndex] += 101;//icrement battle count 100 and +1 win\n                results[result == 1 ? randomIndex : i] += 100;//increment only battle count 100 for loser\n                if (results[randomIndex] >= BATTLES_PER_CONTENDER_SUM) {\n                    if (randomIndex < length - 1) {\n                        _swapValues(combinedWarriors, results, randomIndex, length - 1);\n                    }\n                    length --;\n                }\n                exp++;\n            }\n        }\n        //filter battle count from results\n        length = combinedWarriors.length;\n        for(i = 0; i < length; i ++) {\n            results[i] = results[i] % 100;\n        }\n        \n        return results;\n    }\n    \n    function _swapValues(uint256[] memory combinedWarriors, uint32[] memory results, uint256 id1, uint256 id2) internal pure {\n        uint256 temp = combinedWarriors[id1];\n        combinedWarriors[id1] = combinedWarriors[id2];\n        combinedWarriors[id2] = temp;\n        temp = results[id1];\n        results[id1] = results[id2];\n        results[id2] = uint32(temp);\n    }\n\n    function getTournamentBattleResult(int256 damage1, int256 penetration1, uint256 combinedWarrior1, \n        uint256 combinedWarrior2, uint256 randomSource) internal pure returns (uint256)\n    {\n        int256 damage2;\n\t\tint256 penetration2;\n        \n\t\t(damage2, penetration2) = _unpackAttackParams(combinedWarrior1);\n\n\t\tint256 totalHp1 = getCombinedTotalHP(combinedWarrior1, penetration2);\n\t\tint256 totalHp2 = getCombinedTotalHP(combinedWarrior2, penetration1);\n        \n        return _getBattleResult(damage1 * getBattleRandom(randomSource, 1) / 100, damage2 * getBattleRandom(randomSource, 10) / 100, totalHp1, totalHp2, randomSource);\n    }\n    /* COMMON BATTLE */\n    \n    function _getBattleResult(int256 damage1, int256 damage2, int256 totalHp1, int256 totalHp2, uint256 randomSource)  internal pure returns (uint256){\n\t\ttotalHp1 = (totalHp1 * (PRECISION * PRECISION) / damage2);\n\t\ttotalHp2 = (totalHp2 * (PRECISION * PRECISION) / damage1);\n\t\t//if draw, let the coin decide who wins\n\t\tif (totalHp1 == totalHp2) return randomSource % 2 + 1;\n\t\treturn totalHp1 > totalHp2 ? 1 : 2;       \n    }\n    \n    function getCombinedTotalHP(uint256 combinedData, int256 enemyPenetration) internal pure returns(int256) {\n        int256 hp;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\t(hp, armor, dodge) = _unpackProtectionParams(combinedData);\n        \n        return _getTotalHp(hp, armor, dodge, enemyPenetration);\n    }\n    \n    function getTotalHP(uint256 packedData, uint256 warriorAuras, uint256 petAuras, int256 enemyPenetration) internal pure returns(int256) {\n        int256 hp;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\t(hp, armor, dodge) = _getProtectionParams(packedData, warriorAuras, petAuras);\n        \n        return _getTotalHp(hp, armor, dodge, enemyPenetration);\n    }\n    \n    function _getTotalHp(int256 hp, int256 armor, int256 dodge, int256 enemyPenetration) internal pure returns(int256) {\n        int256 piercingResult = (armor - enemyPenetration) < -(75 * PRECISION) ? -(75 * PRECISION) : (armor - enemyPenetration);\n        int256 mitigation = (PRECISION - piercingResult * PRECISION / (PRECISION + piercingResult / 100) / 100);\n        \n        return (hp * PRECISION / mitigation + (hp * dodge / (100 * PRECISION)));\n    }\n    \n    function _applyLevelBonus(int256 _value, uint256 _level) internal pure returns(int256) {\n        _level -= 1;\n        return int256(uint256(_value) * (LEVEL_BONUSES % (100 ** (_level + 1)) / (100 ** _level)) / 10);\n    }\n    \n    function _getProtectionParams(uint256 packedData, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256 hp, int256 armor, int256 dodge) {\n        uint256 rarityBonus = _unpackRarityBonusValue(packedData);\n        uint256 petData = _unpackPetData(_unpackPetValue(packedData));\n        int256 strength = _unpackStrengthValue(packedData) * PRECISION + _getBattleBonus(BONUS_STR, rarityBonus, petData, warriorAuras, petAuras);\n        int256 agility = _unpackAgilityValue(packedData) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\n        \n        hp = 100 * PRECISION + strength + 7 * strength / 10 + _getBattleBonus(BONUS_HP, rarityBonus, petData, warriorAuras, petAuras);//add bonus hp\n        hp = _applyLevelBonus(hp, _unpackLevelValue(packedData));\n\t\tarmor = (strength + 8 * strength / 10 + agility + _getBattleBonus(BONUS_ARMOR, rarityBonus, petData, warriorAuras, petAuras));//add bonus armor\n\t\tdodge = (2 * agility / 3);\n    }\n    \n    function getDamage(uint256 packedWarrior, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256) {\n        uint256 rarityBonus = _unpackRarityBonusValue(packedWarrior);\n        uint256 petData = _unpackPetData(_unpackPetValue(packedWarrior));\n        int256 agility = _unpackAgilityValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\n        int256 intelligence = _unpackIntelligenceValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_INT, rarityBonus, petData, warriorAuras, petAuras);\n\t\t\n\t\tint256 crit = (agility / 5 + intelligence / 4) + _getBattleBonus(BONUS_CRIT_CHANCE, rarityBonus, petData, warriorAuras, petAuras);\n\t\tint256 critMultiplier = (PRECISION + intelligence / 25) + _getBattleBonus(BONUS_CRIT_MULT, rarityBonus, petData, warriorAuras, petAuras);\n        \n        int256 damage = int256(_unpackBaseDamageValue(packedWarrior) * 3 * PRECISION / 2) + _getBattleBonus(BONUS_DAMAGE, rarityBonus, petData, warriorAuras, petAuras);\n        \n\t\treturn (_applyLevelBonus(damage, _unpackLevelValue(packedWarrior)) * (PRECISION + crit * critMultiplier / (100 * PRECISION))) / PRECISION;\n    }\n\n    function getPenetration(uint256 packedWarrior, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256) {\n        uint256 rarityBonus = _unpackRarityBonusValue(packedWarrior);\n        uint256 petData = _unpackPetData(_unpackPetValue(packedWarrior));\n        int256 agility = _unpackAgilityValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\n        int256 intelligence = _unpackIntelligenceValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_INT, rarityBonus, petData, warriorAuras, petAuras);\n\t\t\n\t\treturn (intelligence * 2 + agility + _getBattleBonus(BONUS_PENETRATION, rarityBonus, petData, warriorAuras, petAuras));\n    }\n    \n    /* BATTLE PVP */\n    \n    //@param randomSource must be >= 1000\n    function getBattleRandom(uint256 randmSource, uint256 _step) internal pure returns(int256){\n        return int256(100 + _random(0, 11, randmSource, 100 * _step, _step));\n    }\n    \n    uint256 internal constant NO_AURA = 0;\n    \n    function getPVPBattleResult(uint256 packedData1, uint256 packedData2, uint256 randmSource) internal pure returns (uint256){\n        uint256 petAura1 = _computePVPPetAura(packedData1);\n        uint256 petAura2 = _computePVPPetAura(packedData2);\n        \n        uint256 warriorAura1 = _computePVPWarriorAura(packedData1, petAura1);\n        uint256 warriorAura2 = _computePVPWarriorAura(packedData2, petAura2);\n        \n\t\tint256 damage1 = getDamage(packedData1, warriorAura1, petAura1) * getBattleRandom(randmSource, 1) / 100;\n        int256 damage2 = getDamage(packedData2, warriorAura2, petAura2) * getBattleRandom(randmSource, 10) / 100;\n\n\t\tint256 totalHp1;\n\t\tint256 totalHp2;\n\t\t(totalHp1, totalHp2) = _computeContendersTotalHp(packedData1, warriorAura1, petAura1, packedData2, warriorAura1, petAura1);\n        \n        return _getBattleResult(damage1, damage2, totalHp1, totalHp2, randmSource);\n    }\n    \n    function _computePVPPetAura(uint256 packedData) internal pure returns(uint256) {\n        return enableAura(NO_AURA, _getPetAura(_unpackPetData(_unpackPetValue(packedData))));\n    }\n    \n    function _computePVPWarriorAura(uint256 packedData, uint256 petAuras) internal pure returns(uint256) {\n        return filterWarriorAuras(enableAura(NO_AURA, _unpackAuraValue(packedData)), petAuras);\n    }\n    \n    function _computeContendersTotalHp(uint256 packedData1, uint256 warriorAura1, uint256 petAura1, uint256 packedData2, uint256 warriorAura2, uint256 petAura2) \n    internal pure returns(int256 totalHp1, int256 totalHp2) {\n\t\tint256 enemyPenetration = getPenetration(packedData2, warriorAura2, petAura2);\n\t\ttotalHp1 = getTotalHP(packedData1, warriorAura1, petAura1, enemyPenetration);\n\t\tenemyPenetration = getPenetration(packedData1, warriorAura1, petAura1);\n\t\ttotalHp2 = getTotalHP(packedData2, warriorAura1, petAura1, enemyPenetration);\n    }\n    \n    function getRatingRange(uint256 _pvpCycle, uint256 _pvpInterval, uint256 _expandInterval) internal pure returns (uint256){\n        return 50 + (_pvpCycle * _pvpInterval / _expandInterval * 25);\n    }\n    \n    function isMatching(int256 evenRating, int256 oddRating, int256 ratingGap) internal pure returns(bool) {\n        return evenRating <= (oddRating + ratingGap) && evenRating >= (oddRating - ratingGap);\n    }\n    \n    function sort(uint256[] memory data) internal pure {\n       quickSort(data, int(0), int(data.length - 1));\n    }\n    \n    function quickSort(uint256[] memory arr, int256 left, int256 right) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if(i==j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) i++;\n            while (pivot < arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\n                i++;\n                j--;\n            }\n        }\n        if (left < j)\n            quickSort(arr, left, j);\n        if (i < right)\n            quickSort(arr, i, right);\n    }\n    \n    function _swapPair(uint256[] memory matchingIds, uint256 id1, uint256 id2, uint256 id3, uint256 id4) internal pure {\n        uint256 temp = matchingIds[id1];\n        matchingIds[id1] = matchingIds[id2];\n        matchingIds[id2] = temp;\n        \n        temp = matchingIds[id3];\n        matchingIds[id3] = matchingIds[id4];\n        matchingIds[id4] = temp;\n    }\n    \n    function _swapValues(uint256[] memory matchingIds, uint256 id1, uint256 id2) internal pure {\n        uint256 temp = matchingIds[id1];\n        matchingIds[id1] = matchingIds[id2];\n        matchingIds[id2] = temp;\n    }\n    \n    function _getMatchingIds(uint256[] memory matchingIds, uint256 _pvpInterval, uint256 _skipCycles, uint256 _expandInterval) \n    internal pure returns(uint256 matchingCount) \n    {\n        matchingCount = matchingIds.length;\n        if (matchingCount == 0) return 0;\n        \n        uint256 warriorId;\n        uint256 index;\n        //sort matching ids\n        quickSort(matchingIds, int256(0), int256(matchingCount - 1));\n        //find pairs\n        int256 rating1;\n        uint256 pairIndex = 0;\n        int256 ratingRange;\n        for(index = 0; index < matchingCount; index++) {\n            //get packed value\n            warriorId = matchingIds[index];\n            //unpack rating 1\n            rating1 = int256(_unpackRatingValue(warriorId));\n            ratingRange = int256(getRatingRange(_unpackCycleValue(warriorId) + _skipCycles, _pvpInterval, _expandInterval));\n            \n            if (index > pairIndex && //check left neighbor\n            isMatching(rating1, int256(_unpackRatingValue(matchingIds[index - 1])), ratingRange)) {\n                //move matched pairs to the left\n                //swap pairs\n                _swapPair(matchingIds, pairIndex, index - 1, pairIndex + 1, index);\n                //mark last pair position\n                pairIndex += 2;\n            } else if (index + 1 < matchingCount && //check right neighbor\n            isMatching(rating1, int256(_unpackRatingValue(matchingIds[index + 1])), ratingRange)) {\n                //move matched pairs to the left\n                //swap pairs\n                _swapPair(matchingIds, pairIndex, index, pairIndex + 1, index + 1);\n                //mark last pair position\n                pairIndex += 2;\n                //skip next iteration\n                index++;\n            }\n        }\n        \n        matchingCount = pairIndex;\n    }\n\n    function _getPVPBattleResults(uint256[] memory matchingIds, uint256 matchingCount, uint256 _targetBlock) internal view {\n        uint256 exp = 0;\n        uint256 hash = 0;\n        uint256 result = 0;\n        for (uint256 even = 0; even < matchingCount; even += 2) {\n            if (exp == 0 || exp > 73) {\n                hash = uint256(keccak256(block.blockhash(_getTargetBlock(_targetBlock)), hash));\n                exp = 0;\n            }\n                \n            //compute battle result 1 = even(left) id won, 2 - odd(right) id won\n            result = getPVPBattleResult(matchingIds[even], matchingIds[even + 1], hash % (1000 * 10**exp) / 10**exp);\n            require(result > 0 && result < 3);\n            exp++;\n            //if odd warrior won, swap his id with even warrior,\n            //otherwise do nothing,\n            //even ids are winning ids! odds suck!\n            if (result == 2) {\n                _swapValues(matchingIds, even, even + 1);\n            }\n        }\n    }\n    \n    function _getLevel(uint256 _levelPoints) internal pure returns(uint256) {\n        return _levelPoints / POINTS_TO_LEVEL;\n    }\n    \n}\n\nlibrary DataTypes {\n     // / @dev The main Warrior struct. Every warrior in CryptoWarriors is represented by a copy\n    // /  of this structure, so great care was taken to ensure that it fits neatly into\n    // /  exactly two 256-bit words. Note that the order of the members in this structure\n    // /  is important because of the byte-packing rules used by Ethereum.\n    // /  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n    struct Warrior{\n        // The Warrior's identity code is packed into these 256-bits\n        uint256 identity;\n        \n        uint64 cooldownEndBlock;\n        /** every warriors starts from 1 lv (10 level points per level) */\n        uint64 level;\n        /** PVP rating, every warrior starts with 100 rating */\n        int64 rating;\n        // 0 - idle\n        uint32 action;\n        /** Set to the index in the levelRequirements array (see CryptoWarriorBase.levelRequirements) that represents\n         *  the current dungeon level requirement for warrior. This starts at zero. */\n        uint32 dungeonIndex;\n    }\n}\n\ncontract CryptoWarriorBase is PermissionControll, PVPListenerInterface {\n\n    /*** EVENTS ***/\n\n    /// @dev The Arise event is fired whenever a new warrior comes into existence. This obviously\n    ///  includes any time a warrior is created through the ariseWarrior method, but it is also called\n    ///  when a new miner warrior is created.\n    event Arise(address owner, uint256 warriorId, uint256 identity);\n\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a warrior\n    ///  ownership is assigned, including dungeon rewards.\n    event Transfer(address from, address to, uint256 tokenId);\n\n    /*** CONSTANTS ***/\n    \n\tuint256 public constant IDLE = 0;\n    uint256 public constant PVE_BATTLE = 1;\n    uint256 public constant PVP_BATTLE = 2;\n    uint256 public constant TOURNAMENT_BATTLE = 3;\n    \n    //max pve dungeon level\n    uint256 public constant MAX_LEVEL = 25;\n    //how many points is needed to get 1 level\n    uint256 public constant POINTS_TO_LEVEL = 10;\n    \n    /// @dev A lookup table contains PVE dungeon level requirements, each time warrior\n    /// completes dungeon, next level requirement is set, until 25lv (250points) is reached.\n    uint32[6] public dungeonRequirements = [\n        uint32(10),\n        uint32(30),\n        uint32(60),\n        uint32(100),\n        uint32(150),\n        uint32(250)\n    ];\n\n    // An approximation of currently how many seconds are in between blocks.\n    uint256 public secondsPerBlock = 15;\n\n    /*** STORAGE ***/\n\n    /// @dev An array containing the Warrior struct for all Warriors in existence. The ID\n    ///  of each warrior is actually an index of this array.\n    DataTypes.Warrior[] warriors;\n\n    /// @dev A mapping from warrior IDs to the address that owns them. All warriors have\n    ///  some valid owner address, even miner warriors are created with a non-zero owner.\n    mapping (uint256 => address) public warriorToOwner;\n\n    // @dev A mapping from owner address to count of tokens that address owns.\n    //  Used internally inside balanceOf() to resolve ownership count.\n    mapping (address => uint256) ownersTokenCount;\n\n    /// @dev A mapping from warrior IDs to an address that has been approved to call\n    ///  transferFrom(). Each Warrior can only have one approved address for transfer\n    ///  at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public warriorToApproved;\n    \n    // Mapping from owner to list of owned token IDs\n    mapping (address => uint256[]) internal ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) internal ownedTokensIndex;\n\n\n    /// @dev The address of the ClockAuction contract that handles sales of warriors. This\n    ///  same contract handles both peer-to-peer sales as well as the miner sales which are\n    ///  initiated every 15 minutes.\n    SaleClockAuction public saleAuction;\n    \n    \n    /// @dev Assigns ownership of a specific warrior to an address.\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n        // When creating new warriors _from is 0x0, but we can't account that address.\n        if (_from != address(0)) {\n            _clearApproval(_tokenId);\n            _removeTokenFrom(_from, _tokenId);\n        }\n        _addTokenTo(_to, _tokenId);\n        \n        // Emit the transfer event.\n        Transfer(_from, _to, _tokenId);\n    }\n    \n    function _addTokenTo(address _to, uint256 _tokenId) internal {\n        // Since the number of warriors is capped to '1 000 000' we can't overflow this\n        ownersTokenCount[_to]++;\n        // transfer ownership\n        warriorToOwner[_tokenId] = _to;\n        \n        uint256 length = ownedTokens[_to].length;\n        ownedTokens[_to].push(_tokenId);\n        ownedTokensIndex[_tokenId] = length;\n    }\n    \n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\n        //\n        ownersTokenCount[_from]--;\n        \n        warriorToOwner[_tokenId] = address(0);\n        \n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\n        uint256 lastTokenIndex = ownedTokens[_from].length - 1;\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n    \n        ownedTokens[_from][tokenIndex] = lastToken;\n        ownedTokens[_from][lastTokenIndex] = 0;\n        \n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n        // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\n        ownedTokens[_from].length--;\n        ownedTokensIndex[_tokenId] = 0;\n        ownedTokensIndex[lastToken] = tokenIndex;\n    }\n    \n    function _clearApproval(uint256 _tokenId) internal {\n        if (warriorToApproved[_tokenId] != address(0)) {\n            // clear any previously approved ownership exchange\n            warriorToApproved[_tokenId] = address(0);\n        }\n    }\n    \n    function _createWarrior(uint256 _identity, address _owner, uint256 _cooldown, uint256 _level, uint256 _rating, uint256 _dungeonIndex)\n        internal\n        returns (uint256) {\n        \t    \n        DataTypes.Warrior memory _warrior = DataTypes.Warrior({\n            identity : _identity,\n            cooldownEndBlock : uint64(_cooldown),\n            level : uint64(_level),//uint64(10),\n            rating : int64(_rating),//int64(100),\n            action : uint32(IDLE),\n            dungeonIndex : uint32(_dungeonIndex)//uint32(0)\n        });\n        uint256 newWarriorId = warriors.push(_warrior) - 1;\n        \n        // let's just be 100% sure we never let this happen.\n        require(newWarriorId == uint256(uint32(newWarriorId)));\n        \n        // emit the arise event\n        Arise(_owner, newWarriorId, _identity);\n        \n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, _owner, newWarriorId);\n\n        return newWarriorId;\n    }\n    \n\n    // Any C-level can fix how many seconds per blocks are currently observed.\n    function setSecondsPerBlock(uint256 secs) external onlyAuthorized {\n        secondsPerBlock = secs;\n    }\n}\n\ncontract WarriorTokenImpl is CryptoWarriorBase, ERC721 {\n\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n    string public constant name = \"CryptoWarriors\";\n    string public constant symbol = \"CW\";\n\n    bytes4 constant InterfaceSignature_ERC165 =\n        bytes4(keccak256('supportsInterface(bytes4)'));\n\n    bytes4 constant InterfaceSignature_ERC721 =\n        bytes4(keccak256('name()')) ^\n        bytes4(keccak256('symbol()')) ^\n        bytes4(keccak256('totalSupply()')) ^\n        bytes4(keccak256('balanceOf(address)')) ^\n        bytes4(keccak256('ownerOf(uint256)')) ^\n        bytes4(keccak256('approve(address,uint256)')) ^\n        bytes4(keccak256('transfer(address,uint256)')) ^\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n        bytes4(keccak256('tokensOfOwner(address)'));\n\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n    ///  ERC-165 (obviously!) and ERC-721.\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n    {\n        // DEBUG ONLY\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9f40b779));\n\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n    }\n\n    // Internal utility functions: These functions all assume that their input arguments\n    // are valid. We leave it to public methods to sanitize their inputs and follow\n    // the required logic.\n\n    /** @dev Checks if a given address is the current owner of the specified Warrior tokenId.\n     * @param _claimant the address we are validating against.\n     * @param _tokenId warrior id\n     */\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return _claimant != address(0) && warriorToOwner[_tokenId] == _claimant;    \n    }\n\n    function _ownerApproved(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return _claimant != address(0) &&//0 address means token is burned \n        warriorToOwner[_tokenId] == _claimant && warriorToApproved[_tokenId] == address(0);    \n    }\n\n    /// @dev Checks if a given address currently has transferApproval for a particular Warrior.\n    /// @param _claimant the address we are confirming warrior is approved for.\n    /// @param _tokenId warrior id\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return warriorToApproved[_tokenId] == _claimant;\n    }\n\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n    ///  _approve() and transferFrom() are used together for putting Warriors on auction, and\n    ///  there is no value in spamming the log with Approval events in that case.\n    function _approve(uint256 _tokenId, address _approved) internal {\n        warriorToApproved[_tokenId] = _approved;\n    }\n\n    /// @notice Returns the number of Warriors(tokens) owned by a specific address.\n    /// @param _owner The owner address to check.\n    /// @dev Required for ERC-721 compliance\n    function balanceOf(address _owner) public view returns (uint256 count) {\n        return ownersTokenCount[_owner];\n    }\n\n    /// @notice Transfers a Warrior to another address. If transferring to a smart\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n    ///  CryptoWarriors specifically) or your Warrior may be lost forever. Seriously.\n    /// @param _to The address of the recipient, can be a user or contract.\n    /// @param _tokenId The ID of the Warrior to transfer.\n    /// @dev Required for ERC-721 compliance.\n    function transfer(address _to, uint256 _tokenId) external whenNotPaused {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any warriors (except very briefly\n        // after a miner warrior is created and before it goes on auction).\n        require(_to != address(this));\n        // Disallow transfers to the auction contracts to prevent accidental\n        // misuse. Auction contracts should only take ownership of warriors\n        // through the allow + transferFrom flow.\n        require(_to != address(saleAuction));\n        // You can only send your own warrior.\n        require(_owns(msg.sender, _tokenId));\n        // Only idle warriors are allowed \n        require(warriors[_tokenId].action == IDLE);\n\n        // Reassign ownership, clear pending approvals, emit Transfer event.\n        _transfer(msg.sender, _to, _tokenId);\n    }\n    \n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\n        require(_index < balanceOf(_owner));\n        return ownedTokens[_owner][_index];\n    }\n\n    /// @notice Grant another address the right to transfer a specific Warrior via\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\n    ///  clear all approvals.\n    /// @param _tokenId The ID of the Warrior that can be transferred if this call succeeds.\n    /// @dev Required for ERC-721 compliance.\n    function approve(address _to, uint256 _tokenId) external whenNotPaused {\n        // Only an owner can grant transfer approval.\n        require(_owns(msg.sender, _tokenId));\n        // Only idle warriors are allowed \n        require(warriors[_tokenId].action == IDLE);\n\n        // Register the approval (replacing any previous approval).\n        _approve(_tokenId, _to);\n\n        // Emit approval event.\n        Approval(msg.sender, _to, _tokenId);\n    }\n\n    /// @notice Transfer a Warrior owned by another address, for which the calling address\n    ///  has previously been granted transfer approval by the owner.\n    /// @param _from The address that owns the Warrior to be transfered.\n    /// @param _to The address that should take ownership of the Warrior. Can be any address,\n    ///  including the caller.\n    /// @param _tokenId The ID of the Warrior to be transferred.\n    /// @dev Required for ERC-721 compliance.\n    function transferFrom(address _from, address _to, uint256 _tokenId)\n        external\n        whenNotPaused\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any warriors (except very briefly\n        // after a miner warrior is created and before it goes on auction).\n        require(_to != address(this));\n        // Check for approval and valid ownership\n        require(_approvedFor(msg.sender, _tokenId));\n        require(_owns(_from, _tokenId));\n        // Only idle warriors are allowed \n        require(warriors[_tokenId].action == IDLE);\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Returns the total number of Warriors currently in existence.\n    /// @dev Required for ERC-721 compliance.\n    function totalSupply() public view returns (uint256) {\n        return warriors.length;\n    }\n\n    /// @notice Returns the address currently assigned ownership of a given Warrior.\n    /// @dev Required for ERC-721 compliance.\n    function ownerOf(uint256 _tokenId)\n        external\n        view\n        returns (address owner)\n    {\n        require(_tokenId < warriors.length);\n        owner = warriorToOwner[_tokenId];\n    }\n\n    /// @notice Returns a list of all Warrior IDs assigned to an address.\n    /// @param _owner The owner whose Warriors we are interested in.\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n        return ownedTokens[_owner];\n    }\n    \n    function tokensOfOwnerFromIndex(address _owner, uint256 _fromIndex, uint256 _count) external view returns(uint256[] memory ownerTokens) {\n        require(_fromIndex < balanceOf(_owner));\n        uint256[] storage tokens = ownedTokens[_owner];\n        //        \n        uint256 ownerBalance = ownersTokenCount[_owner];\n        uint256 lenght = (ownerBalance - _fromIndex >= _count ? _count : ownerBalance - _fromIndex);\n        //\n        ownerTokens = new uint256[](lenght);\n        for(uint256 i = 0; i < lenght; i ++) {\n            ownerTokens[i] = tokens[_fromIndex + i];\n        }\n        \n        return ownerTokens;\n    }\n    \n    /**\n     * @dev Internal function to burn a specific token\n     * @dev Reverts if the token does not exist\n     * @param _owner owner of the token to burn\n     * @param _tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address _owner, uint256 _tokenId) internal {\n        _clearApproval(_tokenId);\n        _removeTokenFrom(_owner, _tokenId);\n        \n        Transfer(_owner, address(0), _tokenId);\n    }\n\n}\n\ncontract CryptoWarriorPVE is WarriorTokenImpl {\n    uint256 internal constant MINER_PERK = 1;\n    uint256 internal constant SUMMONING_SICKENESS = 12;\n    \n    uint256 internal constant PVE_COOLDOWN = 1 hours;\n    uint256 internal constant PVE_DURATION = 15 minutes;\n    \n    \n    /// @notice The payment required to use startPVEBattle().\n    uint256 public pveBattleFee = 10 finney;\n    uint256 public constant PVE_COMPENSATION = 2 finney;\n    \n\t/// @dev The address of the sibling contract that is used to implement warrior generation algorithm.\n    SanctuaryInterface public sanctuary;\n\n    /** @dev PVEStarted event. Emitted every time a warrior enters pve battle\n     *  @param owner Warrior owner\n     *  @param dungeonIndex Started dungeon index \n     *  @param warriorId Warrior ID that started PVE dungeon\n     *  @param battleEndBlock Block number, when started PVE dungeon will be completed\n     */\n    event PVEStarted(address owner, uint256 dungeonIndex, uint256 warriorId, uint256 battleEndBlock);\n\n    /** @dev PVEFinished event. Emitted every time a warrior finishes pve battle\n     *  @param owner Warrior owner\n     *  @param dungeonIndex Finished dungeon index\n     *  @param warriorId Warrior ID that completed dungeon\n     *  @param cooldownEndBlock Block number, when cooldown on PVE battle entrance will be over\n     *  @param rewardId Warrior ID which was granted to the owner as battle reward\n     */\n    event PVEFinished(address owner, uint256 dungeonIndex, uint256 warriorId, uint256 cooldownEndBlock, uint256 rewardId);\n\n\t/// @dev Update the address of the sanctuary contract, can only be called by the Admin.\n    /// @param _address An address of a sanctuary contract instance to be used from this point forward.\n    function setSanctuaryAddress(address _address) external onlyAdmin {\n        SanctuaryInterface candidateContract = SanctuaryInterface(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSanctuary());\n\n        // Set the new contract address\n        sanctuary = candidateContract;\n    }\n    \n    function areUnique(uint256[] memory _warriorIds) internal pure returns(bool) {\n   \t    uint256 length = _warriorIds.length;\n   \t    uint256 j;\n        for(uint256 i = 0; i < length; i++) {\n\t        for(j = i + 1; j < length; j++) {\n\t            if (_warriorIds[i] == _warriorIds[j]) return false;\n\t        }\n        }\n        return true; \n   \t}\n\n    /// @dev Updates the minimum payment required for calling startPVE(). Can only\n    ///  be called by the COO address.\n    function setPVEBattleFee(uint256 _pveBattleFee) external onlyAdmin {\n        require(_pveBattleFee > PVE_COMPENSATION);\n        pveBattleFee = _pveBattleFee;\n    }\n    \n    /** @dev Returns PVE cooldown, after each battle, the warrior receives a \n     *  cooldown on the next entrance to the battle, cooldown depends on current warrior level,\n     *  which is multiplied by 1h. Special case: after receiving 25 lv, the cooldwon will be 14 days.\n     *  @param _levelPoints warrior level */\n    function getPVECooldown(uint256 _levelPoints) public pure returns (uint256) {\n        uint256 level = CryptoUtils._getLevel(_levelPoints);\n        if (level >= MAX_LEVEL) return (14 * 24 * PVE_COOLDOWN);//14 days\n        return (PVE_COOLDOWN * level);\n    }\n\n    /** @dev Returns PVE duration, each battle have a duration, which depends on current warrior level,\n     *  which is multiplied by 15 min. At the end of the duration, warrior is becoming eligible to receive\n     *  battle reward (new warrior in shiny armor)\n     *  @param _levelPoints warrior level points \n     */\n    function getPVEDuration(uint256 _levelPoints) public pure returns (uint256) {\n        return CryptoUtils._getLevel(_levelPoints) * PVE_DURATION;\n    }\n    \n    /// @dev Checks that a given warrior can participate in PVE battle. Requires that the\n    ///  current cooldown is finished and also checks that warrior is idle (does not participate in any action)\n    ///  and dungeon level requirement is satisfied\n    function _isReadyToPVE(DataTypes.Warrior _warrior) internal view returns (bool) {\n        return (_warrior.action == IDLE) && //is idle\n        (_warrior.cooldownEndBlock <= uint64(block.number)) && //no cooldown\n        (_warrior.level >= dungeonRequirements[_warrior.dungeonIndex]);//dungeon level requirement is satisfied\n    }\n    \n    /// @dev Internal utility function to initiate pve battle, assumes that all battle\n    ///  requirements have been checked.\n    function _triggerPVEStart(uint256 _warriorId) internal {\n        // Grab a reference to the warrior from storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        // Set warrior current action to pve battle\n        warrior.action = uint16(PVE_BATTLE);\n        // Set battle duration\n        warrior.cooldownEndBlock = uint64((getPVEDuration(warrior.level) / secondsPerBlock) + block.number);\n        // Emit the pve battle start event.\n        PVEStarted(msg.sender, warrior.dungeonIndex, _warriorId, warrior.cooldownEndBlock);\n    }\n    \n    /// @dev Starts PVE battle for specified warrior, \n    /// after battle, warrior owner will receive reward (Warrior) \n    /// @param _warriorId A Warrior ready to PVE battle.\n    function startPVE(uint256 _warriorId) external payable whenNotPaused {\n\t\t// Checks for payment.\n        require(msg.value >= pveBattleFee);\n\t\t\n\t\t// Caller must own the warrior.\n        require(_ownerApproved(msg.sender, _warriorId));\n\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n\n        // Check that the warrior exists.\n        require(warrior.identity != 0);\n\n        // Check that the warrior is ready to battle\n        require(_isReadyToPVE(warrior));\n        \n        // All checks passed, let the battle begin!\n        _triggerPVEStart(_warriorId);\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 feeExcess = msg.value - pveBattleFee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of _isReadyToPVE check\n        // will fail\n        msg.sender.transfer(feeExcess);\n        //send battle fee to beneficiary\n        bankAddress.transfer(pveBattleFee - PVE_COMPENSATION);\n    }\n    \n    function _ariseWarrior(address _owner, DataTypes.Warrior storage _warrior) internal returns(uint256) {\n        uint256 identity = sanctuary.generateWarrior(_warrior.identity, CryptoUtils._getLevel(_warrior.level), _warrior.cooldownEndBlock - 1, 0);\n        return _createWarrior(identity, _owner, block.number + (PVE_COOLDOWN * SUMMONING_SICKENESS / secondsPerBlock), 10, 100, 0);\n    }\n\n\t/// @dev Internal utility function to finish pve battle, assumes that all battle\n    ///  finish requirements have been checked.\n    function _triggerPVEFinish(uint256 _warriorId) internal {\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        \n        // Set warrior current action to idle\n        warrior.action = uint16(IDLE);\n        \n        // Compute an estimation of the cooldown time in blocks (based on current level).\n        // and miner perc also reduces cooldown time by 4 times\n        warrior.cooldownEndBlock = uint64((getPVECooldown(warrior.level) / \n            CryptoUtils._getBonus(warrior.identity) / secondsPerBlock) + block.number);\n        \n        // cash completed dungeon index before increment\n        uint256 dungeonIndex = warrior.dungeonIndex;\n        // Increment the dungeon index, clamping it at 5, which is the length of the\n        // dungeonRequirements array. We could check the array size dynamically, but hard-coding\n        // this as a constant saves gas.\n        if (dungeonIndex < 5) {\n            warrior.dungeonIndex += 1;\n        }\n        \n        address owner = warriorToOwner[_warriorId];\n        // generate reward\n        uint256 arisenWarriorId = _ariseWarrior(owner, warrior);\n        //Emit event\n        PVEFinished(owner, dungeonIndex, _warriorId, warrior.cooldownEndBlock, arisenWarriorId);\n    }\n    \n    /**\n     * @dev finishPVE can be called after battle time is over,\n     * if checks are passed then battle result is computed,\n     * and new warrior is awarded to owner of specified _warriord ID.\n     * NB anyone can call this method, if they willing to pay the gas price\n     */\n    function finishPVE(uint256 _warriorId) external whenNotPaused {\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        \n        // Check that the warrior exists.\n        require(warrior.identity != 0);\n        \n        // Check that warrior participated in PVE battle action\n        require(warrior.action == PVE_BATTLE);\n        \n        // And the battle time is over\n        require(warrior.cooldownEndBlock <= uint64(block.number));\n        \n        // When the all checks done, calculate actual battle result\n        _triggerPVEFinish(_warriorId);\n        \n        //not susceptible to reetrance attack because of require(warrior.action == PVE_BATTLE)\n        //and require(warrior.cooldownEndBlock <= uint64(block.number));\n        msg.sender.transfer(PVE_COMPENSATION);\n    }\n    \n    /**\n     * @dev finishPVEBatch same as finishPVE but for multiple warrior ids.\n     * NB anyone can call this method, if they willing to pay the gas price\n     */\n    function finishPVEBatch(uint256[] _warriorIds) external whenNotPaused {\n        uint256 length = _warriorIds.length;\n        //check max number of bach finish pve\n        require(length <= 20);\n        uint256 blockNumber = block.number;\n        uint256 index;\n        //all warrior ids must be unique\n        require(areUnique(_warriorIds));\n        //check prerequisites\n        for(index = 0; index < length; index ++) {\n            DataTypes.Warrior storage warrior = warriors[_warriorIds[index]];\n\t\t\trequire(\n\t\t        // Check that the warrior exists.\n\t\t\t    warrior.identity != 0 &&\n\t\t        // Check that warrior participated in PVE battle action\n\t\t\t    warrior.action == PVE_BATTLE &&\n\t\t        // And the battle time is over\n\t\t\t    warrior.cooldownEndBlock <= blockNumber\n\t\t\t);\n        }\n        // When the all checks done, calculate actual battle result\n        for(index = 0; index < length; index ++) {\n            _triggerPVEFinish(_warriorIds[index]);\n        }\n        \n        //not susceptible to reetrance attack because of require(warrior.action == PVE_BATTLE)\n        //and require(warrior.cooldownEndBlock <= uint64(block.number));\n        msg.sender.transfer(PVE_COMPENSATION * length);\n    }\n}\n\ncontract CryptoWarriorSanctuary is CryptoWarriorPVE {\n    \n    uint256 internal constant RARE = 3;\n    \n    function burnWarrior(uint256 _warriorId, address _owner) whenNotPaused external {\n        require(msg.sender == address(sanctuary));\n        \n        // Caller must own the warrior.\n        require(_ownerApproved(_owner, _warriorId));\n\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n\n        // Check that the warrior exists.\n        require(warrior.identity != 0);\n\n        // Check that the warrior is ready to battle\n        require(warrior.action == IDLE);//is idle\n        \n        // Rarity of burned warrior must be less or equal RARE (3)\n        require(CryptoUtils.getRarityValue(warrior.identity) <= RARE);\n        // Warriors with MINER perc are not allowed to be berned\n        require(CryptoUtils.getSpecialityValue(warrior.identity) < MINER_PERK);\n        \n        _burn(_owner, _warriorId);\n    }\n    \n    function ariseWarrior(uint256 _identity, address _owner, uint256 _cooldown) whenNotPaused external returns(uint256){\n        require(msg.sender == address(sanctuary));\n        return _createWarrior(_identity, _owner, _cooldown, 10, 100, 0);\n    }\n    \n}\n\ncontract CryptoWarriorPVP is CryptoWarriorSanctuary {\n\t\n\tPVPInterface public battleProvider;\n\t\n\t/// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function setBattleProviderAddress(address _address) external onlyAdmin {\n        PVPInterface candidateContract = PVPInterface(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isPVPProvider());\n\n        // Set the new contract address\n        battleProvider = candidateContract;\n    }\n    \n    function _packPVPData(uint256 _warriorId, DataTypes.Warrior storage warrior) internal view returns(uint256){\n        return CryptoUtils._packWarriorPvpData(warrior.identity, uint256(warrior.rating), 0, _warriorId, warrior.level);\n    }\n    \n    function _triggerPVPSignUp(uint256 _warriorId, uint256 fee) internal {\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n    \t\t\n\t\tuint256 packedWarrior = _packPVPData(_warriorId, warrior);\n        \n        // addPVPContender will throw if fee fails.\n        battleProvider.addPVPContender.value(fee)(msg.sender, packedWarrior);\n        \n        warrior.action = uint16(PVP_BATTLE);\n    }\n    \n    /*\n     * @title signUpForPVP enqueues specified warrior to PVP\n     * \n     * @dev When the owner enqueues his warrior for PvP, the warrior enters the waiting room.\n     * Once every 15 minutes, we check the warriors in the room and select pairs. \n     * For those warriors to whom we found couples, fighting is conducted and the results \n     * are recorded in the profile of the warrior. \n     */\n    function signUpForPVP(uint256 _warriorId) public payable whenNotPaused {//done\n\t\t// Caller must own the warrior.\n        require(_ownerApproved(msg.sender, _warriorId));\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        // sanity check\n        require(warrior.identity != 0);\n\n        // Check that the warrior is ready to battle\n        require(warrior.action == IDLE);\n        \n        // Define the current price of the auction.\n        uint256 fee = battleProvider.getPVPEntranceFee(warrior.level);\n        \n        // Checks for payment.\n        require(msg.value >= fee);\n        \n        // All checks passed, put the warrior to the queue!\n        _triggerPVPSignUp(_warriorId, fee);\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 feeExcess = msg.value - fee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of warrior.action == IDLE check\n        // will fail\n        msg.sender.transfer(feeExcess);\n    }\n\n    function _grandPVPWinnerReward(uint256 _warriorId) internal {\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        // reward 1 level, add 10 level points\n        uint256 level = warrior.level;\n        if (level < (MAX_LEVEL * POINTS_TO_LEVEL)) {\n            level = level + POINTS_TO_LEVEL;\n\t\t\twarrior.level = uint64(level > (MAX_LEVEL * POINTS_TO_LEVEL) ? (MAX_LEVEL * POINTS_TO_LEVEL) : level);\n        }\n\t\t// give 100 rating for levelUp and 30 for win\n\t\twarrior.rating += 130;\n\t\t// mark warrior idle, so it can participate\n\t\t// in another actions\n\t\twarrior.action = uint16(IDLE);\n    }\n\n    function _grandPVPLoserReward(uint256 _warriorId) internal {\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n\t\t// reward 0.5 level\n\t\tuint256 oldLevel = warrior.level;\n\t\tuint256 level = oldLevel;\n\t\tif (level < (MAX_LEVEL * POINTS_TO_LEVEL)) {\n            level += (POINTS_TO_LEVEL / 2);\n\t\t\twarrior.level = uint64(level);\n        }\n\t\t// give 100 rating for levelUp if happens and -30 for lose\n\t\tint256 newRating = warrior.rating + (CryptoUtils._getLevel(level) > CryptoUtils._getLevel(oldLevel) ? int256(100 - 30) : int256(-30));\n\t\t// rating can't be less than 0 and more than 1000000000\n\t    warrior.rating = int64((newRating >= 0) ? (newRating > 1000000000 ? 1000000000 : newRating) : 0);\n        // mark warrior idle, so it can participate\n\t\t// in another actions\n\t    warrior.action = uint16(IDLE);\n    }\n    \n    function _grandPVPRewards(uint256[] memory warriorsData, uint256 matchingCount) internal {\n        for(uint256 id = 0; id < matchingCount; id += 2){\n            //\n            // winner, even ids are winners!\n            _grandPVPWinnerReward(CryptoUtils._unpackIdValue(warriorsData[id]));\n            //\n            // loser, they are odd...\n            _grandPVPLoserReward(CryptoUtils._unpackIdValue(warriorsData[id + 1]));\n        }\n\t}\n\n    // @dev Internal utility function to initiate pvp battle, assumes that all battle\n    ///  requirements have been checked.\n    function pvpFinished(uint256[] warriorsData, uint256 matchingCount) public {\n        //this method can be invoked only by battleProvider contract\n        require(msg.sender == address(battleProvider));\n        \n        _grandPVPRewards(warriorsData, matchingCount);\n    }\n    \n    function pvpContenderRemoved(uint256 _warriorId) public {\n        //this method can be invoked only by battleProvider contract\n        require(msg.sender == address(battleProvider));\n        //grab warrior storage reference\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        //specified warrior must be in pvp state\n        require(warrior.action == PVP_BATTLE);\n        //all checks done\n        //set warrior state to IDLE\n        warrior.action = uint16(IDLE);\n    }\n}\n\ncontract CryptoWarriorTournament is CryptoWarriorPVP {\n    \n    uint256 internal constant GROUP_SIZE = 5;\n    \n    function _ownsAll(address _claimant, uint256[] memory _warriorIds) internal view returns (bool) {\n        uint256 length = _warriorIds.length;\n        for(uint256 i = 0; i < length; i++) {\n            if (!_ownerApproved(_claimant, _warriorIds[i])) return false;\n        }\n        return true;    \n    }\n    \n    function _isReadyToTournament(DataTypes.Warrior storage _warrior) internal view returns(bool){\n        return _warrior.level >= 50 && _warrior.action == IDLE;//must not participate in any action\n    }\n    \n    function _packTournamentData(uint256[] memory _warriorIds) internal view returns(uint256[] memory tournamentData) {\n        tournamentData = new uint256[](GROUP_SIZE);\n        uint256 warriorId;\n        for(uint256 i = 0; i < GROUP_SIZE; i++) {\n            warriorId = _warriorIds[i];\n            tournamentData[i] = _packPVPData(warriorId, warriors[warriorId]);   \n        }\n        return tournamentData;\n    }\n    \n    \n    // @dev Internal utility function to sign up to tournament, \n    // assumes that all battle requirements have been checked.\n    function _triggerTournamentSignUp(uint256[] memory _warriorIds, uint256 fee) internal {\n        //pack warrior ids into into uint256\n        uint256[] memory tournamentData = _packTournamentData(_warriorIds);\n        \n        for(uint256 i = 0; i < GROUP_SIZE; i++) {\n            // Set warrior current action to tournament battle\n            warriors[_warriorIds[i]].action = uint16(TOURNAMENT_BATTLE);\n        }\n\n        battleProvider.addTournamentContender.value(fee)(msg.sender, tournamentData);\n    }\n    \n    function signUpForTournament(uint256[] _warriorIds) public payable {\n        //\n        //check that there is enough funds to pay entrance fee\n        uint256 fee = battleProvider.getTournamentThresholdFee();\n        require(msg.value >= fee);\n        //\n        //check that warriors group is exactly of allowed size\n        require(_warriorIds.length == GROUP_SIZE);\n        //\n        //message sender must own all the specified warrior IDs\n        require(_ownsAll(msg.sender, _warriorIds));\n        //\n        //check all warriors are unique\n        require(areUnique(_warriorIds));\n        //\n        //check that all warriors are 25 lv and IDLE\n        for(uint256 i = 0; i < GROUP_SIZE; i ++) {\n            // Grab a reference to the warrior in storage.\n            require(_isReadyToTournament(warriors[_warriorIds[i]]));\n        }\n        \n        \n        //all checks passed, trigger sign up\n        _triggerTournamentSignUp(_warriorIds, fee);\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the fee so this cannot underflow.\n        uint256 feeExcess = msg.value - fee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of _isReadyToTournament check\n        // will fail\n        msg.sender.transfer(feeExcess);\n    }\n    \n    function _setIDLE(uint256 warriorIds) internal {\n        for(uint256 i = 0; i < GROUP_SIZE; i ++) {\n            warriors[CryptoUtils._unpackWarriorId(warriorIds, i)].action = uint16(IDLE);\n        }\n    }\n    \n    function _freeWarriors(uint256[] memory packedContenders) internal {\n        uint256 length = packedContenders.length;\n        for(uint256 i = 0; i < length; i ++) {\n            //set participants action to IDLE\n            _setIDLE(packedContenders[i]);\n        }\n    }\n    \n    function tournamentFinished(uint256[] packedContenders) public {\n        //this method can be invoked only by battleProvider contract\n        require(msg.sender == address(battleProvider));\n        \n        //grad rewards and set IDLE action\n        _freeWarriors(packedContenders);\n    }\n    \n}\n\ncontract CryptoWarriorAuction is CryptoWarriorTournament {\n\n    // @notice The auction contract variables are defined in CryptoWarriorBase to allow\n    //  us to refer to them in WarriorTokenImpl to prevent accidental transfers.\n    // `saleAuction` refers to the auction for miner and p2p sale of warriors.\n\n    /// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function setSaleAuctionAddress(address _address) external onlyAdmin {\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSaleClockAuction());\n\n        // Set the new contract address\n        saleAuction = candidateContract;\n    }\n\n\n    /// @dev Put a warrior up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function createSaleAuction(\n        uint256 _warriorId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    )\n        external\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        // If warrior is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_ownerApproved(msg.sender, _warriorId));\n        // Ensure the warrior is not busy to prevent the auction\n        // contract creation while warrior is in any kind of battle (PVE, PVP, TOURNAMENT).\n        require(warriors[_warriorId].action == IDLE);\n        _approve(_warriorId, address(saleAuction));\n        // Sale auction throws if inputs are invalid and clears\n        // transfer approval after escrowing the warrior.\n        saleAuction.createAuction(\n            _warriorId,\n            _startingPrice,\n            _endingPrice,\n            _duration,\n            msg.sender\n        );\n    }\n\n}\n\ncontract CryptoWarriorIssuer is CryptoWarriorAuction {\n    \n    // Limits the number of warriors the contract owner can ever create\n    uint256 public constant MINER_CREATION_LIMIT = 2880;//issue every 15min for one month\n    // Constants for miner auctions.\n    uint256 public constant MINER_STARTING_PRICE = 100 finney;\n    uint256 public constant MINER_END_PRICE = 50 finney;\n    uint256 public constant MINER_AUCTION_DURATION = 1 days;\n\n    uint256 public minerCreatedCount;\n\n    /// @dev Generates a new miner warrior with MINER perk of COMMON rarity\n    ///  creates an auction for it.\n    function createMinerAuction() external onlyIssuer {\n        require(minerCreatedCount < MINER_CREATION_LIMIT);\n\t\t\n        minerCreatedCount++;\n\n        uint256 identity = sanctuary.generateWarrior(minerCreatedCount, 0, block.number - 1, MINER_PERK);\n        uint256 warriorId = _createWarrior(identity, bankAddress, 0, 10, 100, 0);\n        _approve(warriorId, address(saleAuction));\n\n        saleAuction.createAuction(\n            warriorId,\n            _computeNextMinerPrice(),\n            MINER_END_PRICE,\n            MINER_AUCTION_DURATION,\n            bankAddress\n        );\n    }\n\n    /// @dev Computes the next miner auction starting price, given\n    ///  the average of the past 5 prices * 2.\n    function _computeNextMinerPrice() internal view returns (uint256) {\n        uint256 avePrice = saleAuction.averageMinerSalePrice();\n\n        // Sanity check to ensure we don't overflow arithmetic\n        require(avePrice == uint256(uint128(avePrice)));\n\n        uint256 nextPrice = avePrice * 3 / 2;//confirmed\n\n        // We never auction for less than starting price\n        if (nextPrice < MINER_STARTING_PRICE) {\n            nextPrice = MINER_STARTING_PRICE;\n        }\n\n        return nextPrice;\n    }\n\n}\n\ncontract CoreRecovery is CryptoWarriorIssuer {\n    \n    bool public allowRecovery = true;\n    \n    //data model\n    //0 - identity\n    //1 - cooldownEndBlock\n    //2 - level\n    //3 - rating\n    //4 - index\n    function recoverWarriors(uint256[] recoveryData, address[] owners) external onlyAdmin whenPaused {\n        //check that recory action is allowed\n        require(allowRecovery);\n        \n        uint256 length = owners.length;\n        \n        //check that number of owners corresponds to recover data length\n        require(length == recoveryData.length / 5);\n        \n        for(uint256 i = 0; i < length; i++) {\n            _createWarrior(recoveryData[i * 5], owners[i], recoveryData[i * 5 + 1], \n                recoveryData[i * 5 + 2], recoveryData[i * 5 + 3], recoveryData[i * 5 + 4]);\n        }\n    }\n    \n    //recovery is a one time action, once it is done no more recovery actions allowed\n    function recoveryDone() external onlyAdmin {\n        allowRecovery = false;\n    }\n\n}\n\ncontract CryptoWarriorCore is CoreRecovery {\n\n    /// @notice Creates the main CryptoWarrior smart contract instance.\n    function CryptoWarriorCore() public {\n        // Starts paused.\n        paused = true;\n\n        // the creator of the contract is the initial Admin\n        adminAddress = msg.sender;\n\n        // the creator of the contract is also the initial COO\n        issuerAddress = msg.sender;\n        \n        // the creator of the contract is also the initial Bank\n        bankAddress = msg.sender;\n    }\n    \n    /// @notice No tipping!\n    /// @dev Reject all Ether from being sent here\n    /// (Hopefully, we can prevent user accidents.)\n    function() external payable {\n        require(false);\n    }\n    \n    /// @dev Override unpause so it requires all external contract addresses\n    ///  to be set before contract can be unpaused. Also, we can't have\n    ///  newContractAddress set either, because then the contract was upgraded.\n    /// @notice This is public rather than external so we can call super.unpause\n    ///  without using an expensive CALL.\n    function unpause() public onlyAdmin whenPaused {\n        require(address(saleAuction) != address(0));\n        require(address(sanctuary) != address(0));\n        require(address(battleProvider) != address(0));\n        require(newContractAddress == address(0));\n\n        // Actually unpause the contract.\n        super.unpause();\n    }\n    \n    function getBeneficiary() external view returns(address) {\n        return bankAddress;\n    }\n    \n    function isPVPListener() public pure returns (bool) {\n        return true;\n    }\n       \n    /**\n     *@param _warriorIds array of warriorIds, \n     * for those IDs warrior data will be packed into warriorsData array\n     *@return warriorsData packed warrior data\n     *@return stepSize number of fields in single warrior data */\n    function getWarriors(uint256[] _warriorIds) external view returns (uint256[] memory warriorsData, uint256 stepSize) {\n        stepSize = 6;\n        warriorsData = new uint256[](_warriorIds.length * stepSize);\n        for(uint256 i = 0; i < _warriorIds.length; i++) {\n            _setWarriorData(warriorsData, warriors[_warriorIds[i]], i * stepSize);\n        }\n    }\n    \n    /**\n     *@param indexFrom index in global warrior storage (aka warriorId), \n     * from this index(including), warriors data will be gathered\n     *@param count Number of warriors to include in packed data\n     *@return warriorsData packed warrior data\n     *@return stepSize number of fields in single warrior data */\n    function getWarriorsFromIndex(uint256 indexFrom, uint256 count) external view returns (uint256[] memory warriorsData, uint256 stepSize) {\n        stepSize = 6;\n        //check length\n        uint256 lenght = (warriors.length - indexFrom >= count ? count : warriors.length - indexFrom);\n        \n        warriorsData = new uint256[](lenght * stepSize);\n        for(uint256 i = 0; i < lenght; i ++) {\n            _setWarriorData(warriorsData, warriors[indexFrom + i], i * stepSize);\n        }\n    }\n    \n    function getWarriorOwners(uint256[] _warriorIds) external view returns (address[] memory owners) {\n        uint256 lenght = _warriorIds.length;\n        owners = new address[](lenght);\n        \n        for(uint256 i = 0; i < lenght; i ++) {\n            owners[i] = warriorToOwner[_warriorIds[i]];\n        }\n    }\n    \n    \n    function _setWarriorData(uint256[] memory warriorsData, DataTypes.Warrior storage warrior, uint256 id) internal view {\n        warriorsData[id] = uint256(warrior.identity);//0\n        warriorsData[id + 1] = uint256(warrior.cooldownEndBlock);//1\n        warriorsData[id + 2] = uint256(warrior.level);//2\n        warriorsData[id + 3] = uint256(warrior.rating);//3\n        warriorsData[id + 4] = uint256(warrior.action);//4\n        warriorsData[id + 5] = uint256(warrior.dungeonIndex);//5\n    }\n    \n\tfunction getWarrior(uint256 _id) external view returns \n    (\n        uint256 identity, \n        uint256 cooldownEndBlock, \n        uint256 level,\n        uint256 rating, \n        uint256 action,\n        uint256 dungeonIndex\n    ) {\n        DataTypes.Warrior storage warrior = warriors[_id];\n\n        identity = uint256(warrior.identity);\n        cooldownEndBlock = uint256(warrior.cooldownEndBlock);\n        level = uint256(warrior.level);\n\t\trating = uint256(warrior.rating);\n\t\taction = uint256(warrior.action);\n\t\tdungeonIndex = uint256(warrior.dungeonIndex);\n    }\n    \n}\n\n/*  @title Handles creating pvp battles every 15 min.*/\ncontract PVP is PausableBattle, PVPInterface {\n\t/* PVP BATLE */\n\t\n    /** list of packed warrior data that will participate in next PVP session. \n     *  Fixed size arry, to evade constant remove and push operations,\n     *  this approach reduces transaction costs involving queue modification. */\n    uint256[100] public pvpQueue;\n    //\n    //queue size\n    uint256 public pvpQueueSize = 0;\n    \n    // @dev A mapping from owner address to booty in WEI\n    //  booty is acquired in PVP and Tournament battles and can be\n    // withdrawn with grabBooty method by the owner of the loot\n    mapping (address => uint256) public ownerToBooty;\n    \n    // @dev A mapping from warrior id to owners address\n    mapping (uint256 => address) internal warriorToOwner;\n    \n    // An approximation of currently how many seconds are in between blocks.\n    uint256 internal secondsPerBlock = 15;\n    \n    // Cut owner takes from, measured in basis points (1/100 of a percent).\n    // Values 0-10,000 map to 0%-100%\n    uint256 public pvpOwnerCut;\n    \n    // Values 0-10,000 map to 0%-100%\n    //this % of the total bets will be sent as \n    //a reward to address, that triggered finishPVP method\n    uint256 public pvpMaxIncentiveCut;\n    \n    /// @notice The payment base required to use startPVP().\n    // pvpBattleFee * (warrior.level / POINTS_TO_LEVEL)\n    uint256 internal pvpBattleFee = 10 finney;\n    \n    uint256 public constant PVP_INTERVAL = 15 minutes;\n    \n    uint256 public nextPVPBatleBlock = 0;\n    //number of WEI in hands of warrior owners\n    uint256 public totalBooty = 0;\n    \n    /* TOURNAMENT */\n    uint256 public constant FUND_GATHERING_TIME = 24 hours;\n    uint256 public constant ADMISSION_TIME = 12 hours;\n    uint256 public constant RATING_EXPAND_INTERVAL = 1 hours;\n    uint256 internal constant SAFETY_GAP = 5;\n    \n    uint256 internal constant MAX_INCENTIVE_REWARD = 200 finney;\n    \n    //tournamentContenders size\n    uint256 public tournamentQueueSize = 0;\n    \n    // Values 0-10,000 map to 0%-100%\n    uint256 public tournamentBankCut;\n    \n   /** tournamentEndBlock, tournament is eligible to be finished only\n    *  after block.number >= tournamentEndBlock \n    *  it depends on FUND_GATHERING_TIME and ADMISSION_TIME */\n    uint256 public tournamentEndBlock;\n    \n    //number of WEI in tournament bank\n    uint256 public currentTournamentBank = 0;\n    uint256 public nextTournamentBank = 0;\n    \n    PVPListenerInterface internal pvpListener;\n    \n    /* EVENTS */\n    /** @dev TournamentScheduled event. Emitted every time a tournament is scheduled \n     *  @param tournamentEndBlock when block.number > tournamentEndBlock, then tournament \n     *         is eligible to be finished or rescheduled */\n    event TournamentScheduled(uint256 tournamentEndBlock);\n    \n    /** @dev PVPScheduled event. Emitted every time a tournament is scheduled \n     *  @param nextPVPBatleBlock when block.number > nextPVPBatleBlock, then pvp battle \n     *         is eligible to be finished or rescheduled */\n    event PVPScheduled(uint256 nextPVPBatleBlock);\n    \n    /** @dev PVPNewContender event. Emitted every time a warrior enqueues pvp battle\n     *  @param owner Warrior owner\n     *  @param warriorId Warrior ID that entered PVP queue\n     *  @param entranceFee fee in WEI warrior owner payed to enter PVP\n     */\n    event PVPNewContender(address owner, uint256 warriorId, uint256 entranceFee);\n\n    /** @dev PVPFinished event. Emitted every time a pvp battle is finished\n     *  @param warriorsData array of pairs of pvp warriors packed to uint256, even => winners, odd => losers \n     *  @param owners array of warrior owners, 1 to 1 with warriorsData, even => winners, odd => losers \n     *  @param matchingCount total number of warriors that fought in current pvp session and got rewards,\n     *  if matchingCount < participants.length then all IDs that are >= matchingCount will \n     *  remain in waiting room, until they are matched.\n     */\n    event PVPFinished(uint256[] warriorsData, address[] owners, uint256 matchingCount);\n    \n    /** @dev BootySendFailed event. Emitted every time address.send() function failed to transfer Ether to recipient\n     *  in this case recipient Ether is recorded to ownerToBooty mapping, so recipient can withdraw their booty manually\n     *  @param recipient address for whom send failed\n     *  @param amount number of WEI we failed to send\n     */\n    event BootySendFailed(address recipient, uint256 amount);\n    \n    /** @dev BootyGrabbed event\n     *  @param receiver address who grabbed his booty\n     *  @param amount number of WEI\n     */\n    event BootyGrabbed(address receiver, uint256 amount);\n    \n    /** @dev PVPContenderRemoved event. Emitted every time warrior is removed from pvp queue by its owner.\n     *  @param warriorId id of the removed warrior\n     */\n    event PVPContenderRemoved(uint256 warriorId, address owner);\n    \n    function PVP(uint256 _pvpCut, uint256 _tournamentBankCut, uint256 _pvpMaxIncentiveCut) public {\n        require((_tournamentBankCut + _pvpCut + _pvpMaxIncentiveCut) <= 10000);\n\t\tpvpOwnerCut = _pvpCut;\n\t\ttournamentBankCut = _tournamentBankCut;\n\t\tpvpMaxIncentiveCut = _pvpMaxIncentiveCut;\n    }\n    \n    /** @dev grabBooty sends to message sender his booty in WEI\n     */\n    function grabBooty() external {\n        uint256 booty = ownerToBooty[msg.sender];\n        require(booty > 0);\n        require(totalBooty >= booty);\n        \n        ownerToBooty[msg.sender] = 0;\n        totalBooty -= booty;\n        \n        msg.sender.transfer(booty);\n        //emit event\n        BootyGrabbed(msg.sender, booty);\n    }\n    \n    function safeSend(address _recipient, uint256 _amaunt) internal {\n\t\tuint256 failedBooty = sendBooty(_recipient, _amaunt);\n        if (failedBooty > 0) {\n\t\t\ttotalBooty += failedBooty;\n        }\n    }\n    \n    function sendBooty(address _recipient, uint256 _amaunt) internal returns(uint256) {\n        bool success = _recipient.send(_amaunt);\n        if (!success && _amaunt > 0) {\n            ownerToBooty[_recipient] += _amaunt;\n            BootySendFailed(_recipient, _amaunt);\n            return _amaunt;\n        }\n        return 0;\n    }\n    \n    //@returns block number, after this block tournament is opened for admission\n    function getTournamentAdmissionBlock() public view returns(uint256) {\n        uint256 admissionInterval = (ADMISSION_TIME / secondsPerBlock);\n        return tournamentEndBlock < admissionInterval ? 0 : tournamentEndBlock - admissionInterval;\n    }\n    \n    \n    //schedules next turnament time(block)\n    function _scheduleTournament() internal {\n        //we can chedule only if there is nobody in tournament queue and\n        //time of tournament battle have passed\n\t\tif (tournamentQueueSize == 0 && tournamentEndBlock <= block.number) {\n\t\t    tournamentEndBlock = ((FUND_GATHERING_TIME / 2 + ADMISSION_TIME) / secondsPerBlock) + block.number;\n\t\t    TournamentScheduled(tournamentEndBlock);\n\t\t}\n    }\n    \n    /// @dev Updates the minimum payment required for calling startPVP(). Can only\n    ///  be called by the COO address, and only if pvp queue is empty.\n    function setPVPEntranceFee(uint256 value) external onlyOwner {\n        require(pvpQueueSize == 0);\n        pvpBattleFee = value;\n    }\n    \n    //@returns PVP entrance fee for specified warrior level \n    //@param _levelPoints NB!\n    function getPVPEntranceFee(uint256 _levelPoints) external view returns(uint256) {\n        return pvpBattleFee * CryptoUtils._getLevel(_levelPoints);\n    }\n    \n    //level can only be > 0 and <= 25\n    function _getPVPFeeByLevel(uint256 _level) internal view returns(uint256) {\n        return pvpBattleFee * _level;\n    }\n    \n\t// @dev Computes warrior pvp reward\n    // @param _totalBet - total bet from both competitors.\n    function _computePVPReward(uint256 _totalBet, uint256 _contendersCut) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalBet max value is 1000 finney, and _contendersCut aka\n        // (10000 - pvpOwnerCut - tournamentBankCut - incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalBet.\n        return _totalBet * _contendersCut / 10000;\n    }\n    \n    function _getPVPContendersCut(uint256 _incentiveCut) internal view returns (uint256) {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // (pvpOwnerCut + tournamentBankCut + pvpMaxIncentiveCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). \n        // _incentiveCut is guaranteed to be >= 1 and <=  pvpMaxIncentiveCut\n        return (10000 - pvpOwnerCut - tournamentBankCut - _incentiveCut);\n    }\n\t\n\t// @dev Computes warrior pvp reward\n    // @param _totalSessionLoot - total bets from all competitors.\n    function _computeIncentiveReward(uint256 _totalSessionLoot, uint256 _incentiveCut) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalSessionLoot max value is 37500 finney, and \n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalSessionLoot.\n        return _totalSessionLoot * _incentiveCut / 10000;\n    }\n    \n\t///@dev computes incentive cut for specified loot, \n\t/// Values 0-10,000 map to 0%-100%\n\t/// max incentive reward cut is 5%, if it exceeds MAX_INCENTIVE_REWARD,\n\t/// then cut is lowered to be equal to MAX_INCENTIVE_REWARD.\n\t/// minimum cut is 0.01%\n    /// this % of the total bets will be sent as \n    /// a reward to address, that triggered finishPVP method\n    function _computeIncentiveCut(uint256 _totalSessionLoot, uint256 maxIncentiveCut) internal pure returns(uint256) {\n        uint256 result = _totalSessionLoot * maxIncentiveCut / 10000;\n        result = result <= MAX_INCENTIVE_REWARD ? maxIncentiveCut : MAX_INCENTIVE_REWARD * 10000 / _totalSessionLoot;\n        //min cut is 0.01%\n        return result > 0 ? result : 1;\n    }\n    \n    // @dev Computes warrior pvp reward\n    // @param _totalSessionLoot - total bets from all competitors.\n    function _computePVPBeneficiaryFee(uint256 _totalSessionLoot) internal view returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalSessionLoot max value is 37500 finney, and \n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalSessionLoot.\n        return _totalSessionLoot * pvpOwnerCut / 10000;\n    }\n    \n    // @dev Computes tournament bank cut\n    // @param _totalSessionLoot - total session loot.\n    function _computeTournamentCut(uint256 _totalSessionLoot) internal view returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalSessionLoot max value is 37500 finney, and \n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalSessionLoot.\n        return _totalSessionLoot * tournamentBankCut / 10000;\n    }\n\n    function indexOf(uint256 _warriorId) internal view returns(int256) {\n\t    uint256 length = uint256(pvpQueueSize);\n\t    for(uint256 i = 0; i < length; i ++) {\n\t        if(CryptoUtils._unpackIdValue(pvpQueue[i]) == _warriorId) return int256(i);\n\t    }\n\t    return -1;\n\t}\n    \n    function getPVPIncentiveReward(uint256[] memory matchingIds, uint256 matchingCount) internal view returns(uint256) {\n        uint256 sessionLoot = _computeTotalBooty(matchingIds, matchingCount);\n        \n        return _computeIncentiveReward(sessionLoot, _computeIncentiveCut(sessionLoot, pvpMaxIncentiveCut));\n    }\n    \n    function maxPVPContenders() external view returns(uint256){\n        return pvpQueue.length;\n    }\n    \n    function getPVPState() external view returns\n    (uint256 contendersCount, uint256 matchingCount, uint256 endBlock, uint256 incentiveReward)\n    {\n        uint256[] memory pvpData = _packPVPData();\n        \n    \tcontendersCount = pvpQueueSize;\n    \tmatchingCount = CryptoUtils._getMatchingIds(pvpData, PVP_INTERVAL, _computeCycleSkip(), RATING_EXPAND_INTERVAL);\n    \tendBlock = nextPVPBatleBlock;   \n    \tincentiveReward = getPVPIncentiveReward(pvpData, matchingCount);\n    }\n    \n    function canFinishPVP() external view returns(bool) {\n        return nextPVPBatleBlock <= block.number &&\n         CryptoUtils._getMatchingIds(_packPVPData(), PVP_INTERVAL, _computeCycleSkip(), RATING_EXPAND_INTERVAL) > 1;\n    }\n    \n    function _clarifyPVPSchedule() internal {\n        uint256 length = pvpQueueSize;\n\t\tuint256 currentBlock = block.number;\n\t\tuint256 nextBattleBlock = nextPVPBatleBlock;\n\t\t//if battle not scheduled, schedule battle\n\t\tif (nextBattleBlock <= currentBlock) {\n\t\t    //if queue not empty update cycles\n\t\t    if (length > 0) {\n\t\t\t\tuint256 packedWarrior;\n\t\t\t\tuint256 cycleSkip = _computeCycleSkip();\n\t\t        for(uint256 i = 0; i < length; i++) {\n\t\t            packedWarrior = pvpQueue[i];\n\t\t            //increase warrior iteration cycle\n\t\t            pvpQueue[i] = CryptoUtils._changeCycleValue(packedWarrior, CryptoUtils._unpackCycleValue(packedWarrior) + cycleSkip);\n\t\t        }\n\t\t    }\n\t\t    nextBattleBlock = (PVP_INTERVAL / secondsPerBlock) + currentBlock;\n\t\t    nextPVPBatleBlock = nextBattleBlock;\n\t\t    PVPScheduled(nextBattleBlock);\n\t\t//if pvp queue will be full and there is still too much time left, then let the battle begin! \n\t\t} else if (length + 1 == pvpQueue.length && (currentBlock + SAFETY_GAP * 2) < nextBattleBlock) {\n\t\t    nextBattleBlock = currentBlock + SAFETY_GAP;\n\t\t    nextPVPBatleBlock = nextBattleBlock;\n\t\t    PVPScheduled(nextBattleBlock);\n\t\t}\n    }\n    \n    /// @dev Internal utility function to initiate pvp battle, assumes that all battle\n    ///  requirements have been checked.\n    function _triggerNewPVPContender(address _owner, uint256 _packedWarrior, uint256 fee) internal {\n\n\t\t_clarifyPVPSchedule();\n        //number of pvp cycles the warrior is waiting for suitable enemy match\n        //increment every time when finishPVP is called and no suitable enemy match was found\n        _packedWarrior = CryptoUtils._changeCycleValue(_packedWarrior, 0);\n\t\t\n\t\t//record contender data\n\t\tpvpQueue[pvpQueueSize++] = _packedWarrior;\n\t\twarriorToOwner[CryptoUtils._unpackIdValue(_packedWarrior)] = _owner;\n\t\t\n\t\t//Emit event\n\t\tPVPNewContender(_owner, CryptoUtils._unpackIdValue(_packedWarrior), fee);\n    }\n    \n    function _noMatchingPairs() internal view returns(bool) {\n        uint256 matchingCount = CryptoUtils._getMatchingIds(_packPVPData(), uint64(PVP_INTERVAL), _computeCycleSkip(), uint64(RATING_EXPAND_INTERVAL));\n        return matchingCount == 0;\n    }\n    \n    /*\n     * @title startPVP enqueues specified warrior to PVP\n     * \n     * @dev When the owner enqueues his warrior for PvP, the warrior enters the waiting room.\n     * Once every 15 minutes, we check the warriors in the room and select pairs. \n     * For those warriors to whom we found couples, fighting is conducted and the results \n     * are recorded in the profile of the warrior. \n     */\n    function addPVPContender(address _owner, uint256 _packedWarrior) external payable PVPNotPaused {\n\t\t// Caller must be pvpListener contract\n        require(msg.sender == address(pvpListener));\n\n        require(_owner != address(0));\n        //contender can be added only while PVP is scheduled in future\n        //or no matching warrior pairs found\n        require(nextPVPBatleBlock > block.number || _noMatchingPairs());\n        // Check that the warrior exists.\n        require(_packedWarrior != 0);\n        //owner must withdraw all loot before contending pvp\n        require(ownerToBooty[_owner] == 0);\n        //check that there is enough room for new participants\n        require(pvpQueueSize < pvpQueue.length);\n        // Checks for payment.\n        uint256 fee = _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarrior));\n        require(msg.value >= fee);\n        //\n        // All checks passed, put the warrior to the queue!\n        _triggerNewPVPContender(_owner, _packedWarrior, fee);\n    }\n    \n    function _packPVPData() internal view returns(uint256[] memory matchingIds) {\n        uint256 length = pvpQueueSize;\n        matchingIds = new uint256[](length);\n        for(uint256 i = 0; i < length; i++) {\n            matchingIds[i] = pvpQueue[i];\n        }\n        return matchingIds;\n    }\n    \n    function _computeTotalBooty(uint256[] memory _packedWarriors, uint256 matchingCount) internal view returns(uint256) {\n        //compute session booty\n        uint256 sessionLoot = 0;\n        for(uint256 i = 0; i < matchingCount; i++) {\n            sessionLoot += _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarriors[i]));\n        }\n        return sessionLoot;\n    }\n    \n    function _grandPVPRewards(uint256[] memory _packedWarriors, uint256 matchingCount) \n    internal returns(uint256)\n    {\n        uint256 booty = 0;\n        uint256 packedWarrior;\n        uint256 failedBooty = 0;\n        \n        uint256 sessionBooty = _computeTotalBooty(_packedWarriors, matchingCount);\n        uint256 incentiveCut = _computeIncentiveCut(sessionBooty, pvpMaxIncentiveCut);\n        uint256 contendersCut = _getPVPContendersCut(incentiveCut);\n        \n        for(uint256 id = 0; id < matchingCount; id++) {\n            //give reward to warriors that fought hard\n\t\t\t//winner, even ids are winners!\n\t\t\tpackedWarrior = _packedWarriors[id];\n\t\t\t//\n\t\t\t//give winner deserved booty 80% from both bets\n\t\t\t//must be computed before level reward!\n\t\t\tbooty = _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(packedWarrior)) + \n\t\t\t\t_getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarriors[id + 1]));\n\t\t\t\n\t\t\t//\n\t\t\t//send reward to warrior owner\n\t\t\tfailedBooty += sendBooty(warriorToOwner[CryptoUtils._unpackIdValue(packedWarrior)], _computePVPReward(booty, contendersCut));\n\t\t\t//loser, they are odd...\n\t\t\t//skip them, as they deserve none!\n\t\t\tid ++;\n        }\n        failedBooty += sendBooty(pvpListener.getBeneficiary(), _computePVPBeneficiaryFee(sessionBooty));\n        \n        if (failedBooty > 0) {\n            totalBooty += failedBooty;\n        }\n        //if tournament admission start time not passed\n        //add tournament cut to current tournament bank,\n        //otherwise to next tournament bank\n        if (getTournamentAdmissionBlock() > block.number) {\n            currentTournamentBank += _computeTournamentCut(sessionBooty);\n        } else {\n            nextTournamentBank += _computeTournamentCut(sessionBooty);\n        }\n        \n        //compute incentive reward\n        return _computeIncentiveReward(sessionBooty, incentiveCut);\n    }\n    \n    function _increaseCycleAndTrimQueue(uint256[] memory matchingIds, uint256 matchingCount) internal {\n        uint32 length = uint32(matchingIds.length - matchingCount);  \n\t\tuint256 packedWarrior;\n\t\tuint256 skipCycles = _computeCycleSkip();\n        for(uint256 i = 0; i < length; i++) {\n            packedWarrior = matchingIds[matchingCount + i];\n            //increase warrior iteration cycle\n            pvpQueue[i] = CryptoUtils._changeCycleValue(packedWarrior, CryptoUtils._unpackCycleValue(packedWarrior) + skipCycles);\n        }\n        //trim queue\t\n        pvpQueueSize = length;\n    }\n    \n    function _computeCycleSkip() internal view returns(uint256) {\n        uint256 number = block.number;\n        return nextPVPBatleBlock > number ? 0 : (number - nextPVPBatleBlock) * secondsPerBlock / PVP_INTERVAL + 1;\n    }\n    \n    function _getWarriorOwners(uint256[] memory pvpData) internal view returns (address[] memory owners){\n        uint256 length = pvpData.length;\n        owners = new address[](length);\n        for(uint256 i = 0; i < length; i ++) {\n            owners[i] = warriorToOwner[CryptoUtils._unpackIdValue(pvpData[i])];\n        }\n    }\n    \n    // @dev Internal utility function to initiate pvp battle, assumes that all battle\n    ///  requirements have been checked.\n    function _triggerPVPFinish(uint256[] memory pvpData, uint256 matchingCount) internal returns(uint256){\n        //\n\t\t//compute battle results        \n        CryptoUtils._getPVPBattleResults(pvpData, matchingCount, nextPVPBatleBlock);\n        //\n        //mark not fought warriors and trim queue \n        _increaseCycleAndTrimQueue(pvpData, matchingCount);\n        //\n        //schedule next battle time\n        nextPVPBatleBlock = (PVP_INTERVAL / secondsPerBlock) + block.number;\n        \n        //\n        //schedule tournament\n        //if contendersCount is 0 and tournament not scheduled, schedule tournament\n        //NB MUST be before _grandPVPRewards()\n        _scheduleTournament();\n        // compute and grand rewards to warriors,\n        // put tournament cut to bank, not susceptible to reentry attack because of require(nextPVPBatleBlock <= block.number);\n        // and require(number of pairs > 1);\n        uint256 incentiveReward = _grandPVPRewards(pvpData, matchingCount);\n        //\n        //notify pvp listener contract\n        pvpListener.pvpFinished(pvpData, matchingCount);\n        \n        //\n        //fire event\n\t\tPVPFinished(pvpData, _getWarriorOwners(pvpData), matchingCount);\n        PVPScheduled(nextPVPBatleBlock);\n\t\t\n\t\treturn incentiveReward;\n    }\n    \n    \n    /**\n     * @dev finishPVP this method finds matches of warrior pairs\n     * in waiting room and computes result of their fights.\n     * \n     * The winner gets +1 level, the loser gets +0.5 level\n     * The winning player gets +130 rating\n\t * The losing player gets -30 or 70 rating (if warrior levelUps after battle) .\n     * can be called once in 15min.\n     * NB If the warrior is not picked up in an hour, then we expand the range \n     * of selection by 25 rating each hour.\n     */\n    function finishPVP() public PVPNotPaused {\n        // battle interval is over\n        require(nextPVPBatleBlock <= block.number);\n        //\n\t    //match warriors\n        uint256[] memory pvpData = _packPVPData();\n        //match ids and sort them according to matching\n        uint256 matchingCount = CryptoUtils._getMatchingIds(pvpData, uint64(PVP_INTERVAL), _computeCycleSkip(), uint64(RATING_EXPAND_INTERVAL));\n\t\t// we have at least 1 matching battle pair\n        require(matchingCount > 1);\n        \n        // When the all checks done, calculate actual battle result\n        uint256 incentiveReward = _triggerPVPFinish(pvpData, matchingCount);\n        \n        //give reward for incentive\n        safeSend(msg.sender, incentiveReward);\n    }\n\n    // @dev Removes specified warrior from PVP queue\n    //  sets warrior free (IDLE) and returns pvp entrance fee to owner\n    // @notice This is a state-modifying function that can\n    //  be called while the contract is paused.\n    // @param _warriorId - ID of warrior in PVP queue\n    function removePVPContender(uint256 _warriorId) external{\n        uint256 queueSize = pvpQueueSize;\n        require(queueSize > 0);\n        // Caller must be owner of the specified warrior\n        require(warriorToOwner[_warriorId] == msg.sender);\n        //warrior must be in pvp queue\n        int256 warriorIndex = indexOf(_warriorId);\n        require(warriorIndex >= 0);\n        //grab warrior data\n        uint256 warriorData = pvpQueue[uint32(warriorIndex)];\n        //warrior cycle must be >= 4 (> than 1 hour)\n        require((CryptoUtils._unpackCycleValue(warriorData) + _computeCycleSkip()) >= 4);\n        \n        //remove from queue\n        if (uint256(warriorIndex) < queueSize - 1) {\n\t        pvpQueue[uint32(warriorIndex)] = pvpQueue[pvpQueueSize - 1];\n        }\n        pvpQueueSize --;\n        //notify battle listener\n        pvpListener.pvpContenderRemoved(_warriorId);\n        //return pvp bet\n        msg.sender.transfer(_getPVPFeeByLevel(CryptoUtils._unpackLevelValue(warriorData)));\n        //Emit event\n        PVPContenderRemoved(_warriorId, msg.sender);\n    }\n    \n    function getPVPCycles(uint32[] warriorIds) external view returns(uint32[]){\n        uint256 length = warriorIds.length;\n        uint32[] memory cycles = new uint32[](length);\n        int256 index;\n        uint256 skipCycles = _computeCycleSkip();\n\t    for(uint256 i = 0; i < length; i ++) {\n\t        index = indexOf(warriorIds[i]);\n\t        cycles[i] = index >= 0 ? uint32(CryptoUtils._unpackCycleValue(pvpQueue[uint32(index)]) + skipCycles) : 0;\n\t    }\n\t    return cycles;\n    }\n    \n    // @dev Remove all PVP contenders from PVP queue \n    //  and return all bets to warrior owners.\n    //  NB: this is emergency method, used only in f%#^@up situation\n    function removeAllPVPContenders() external onlyOwner PVPPaused {\n        //remove all pvp contenders\n        uint256 length = pvpQueueSize;\n        \n        uint256 warriorData;\n        uint256 warriorId;\n        uint256 failedBooty;\n        address owner;\n        \n        pvpQueueSize = 0;\n        \n        for(uint256 i = 0; i < length; i++) {\n\t        //grab warrior data\n\t        warriorData = pvpQueue[i];\n\t        warriorId = CryptoUtils._unpackIdValue(warriorData);\n\t        //notify battle listener\n\t        pvpListener.pvpContenderRemoved(uint32(warriorId));\n\t        \n\t        owner = warriorToOwner[warriorId];\n\t        //return pvp bet\n\t        failedBooty += sendBooty(owner, _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(warriorData)));\n        }\n        totalBooty += failedBooty;\n    }\n}\n\n\ncontract Tournament is PVP {\n\n    uint256 internal constant GROUP_SIZE = 5;\n    uint256 internal constant DATA_SIZE = 2;\n    uint256 internal constant THRESHOLD = 300;\n    \n  /** list of warrior IDs that will participate in next tournament. \n    *  Fixed size arry, to evade constant remove and push operations,\n    *  this approach reduces transaction costs involving array modification. */\n    uint256[160] public tournamentQueue;\n    \n    /**The cost of participation in the tournament is 1% of its current prize fund, \n     * money is added to the prize fund. measured in basis points (1/100 of a percent).\n     * Values 0-10,000 map to 0%-100% */\n    uint256 internal tournamentEntranceFeeCut = 100;\n    \n    // Values 0-10,000 map to 0%-100% => 20%\n    uint256 public tournamentOwnersCut;\n    uint256 public tournamentIncentiveCut;\n    \n     /** @dev TournamentNewContender event. Emitted every time a warrior enters tournament\n     *  @param owner Warrior owner\n     *  @param warriorIds 5 Warrior IDs that entered tournament, packed into one uint256\n     *  see CryptoUtils._packWarriorIds\n     */\n    event TournamentNewContender(address owner, uint256 warriorIds, uint256 entranceFee);\n    \n    /** @dev TournamentFinished event. Emitted every time a tournament is finished\n     *  @param owners array of warrior group owners packed to uint256\n     *  @param results number of wins for each group\n     *  @param tournamentBank current tournament bank\n     *  see CryptoUtils._packWarriorIds\n     */\n    event TournamentFinished(uint256[] owners, uint32[] results, uint256 tournamentBank);\n    \n    function Tournament(uint256 _pvpCut, uint256 _tournamentBankCut, \n    uint256 _pvpMaxIncentiveCut, uint256 _tournamentOwnersCut, uint256 _tournamentIncentiveCut) public\n    PVP(_pvpCut, _tournamentBankCut, _pvpMaxIncentiveCut) \n    {\n        require((_tournamentOwnersCut + _tournamentIncentiveCut) <= 10000);\n\t\t\n\t\ttournamentOwnersCut = _tournamentOwnersCut;\n\t\ttournamentIncentiveCut = _tournamentIncentiveCut;\n    }\n    \n    \n    \n    // @dev Computes incentive reward for launching tournament finishTournament()\n    // @param _tournamentBank\n    function _computeTournamentIncentiveReward(uint256 _currentBank, uint256 _incentiveCut) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\n        // and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _currentBank.\n        return _currentBank * _incentiveCut / 10000;\n    }\n    \n    function _computeTournamentContenderCut(uint256 _incentiveCut) internal view returns (uint256) {\n        // NOTE: (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _reward.\n        return 10000 - tournamentOwnersCut - _incentiveCut;\n    }\n    \n    function _computeTournamentBeneficiaryFee(uint256 _currentBank) internal view returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\n        // and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _currentBank.\n        return _currentBank * tournamentOwnersCut / 10000;\n    }\n    \n    // @dev set tournament entrance fee cut, can be set only if\n    // tournament queue is empty\n    // @param _cut range from 0 - 10000, mapped to 0-100%\n    function setTournamentEntranceFeeCut(uint256 _cut) external onlyOwner {\n        //cut must be less or equal 100&\n        require(_cut <= 10000);\n        //tournament queue must be empty\n        require(tournamentQueueSize == 0);\n        //checks passed, set cut\n\t\ttournamentEntranceFeeCut = _cut;\n    }\n    \n    function getTournamentEntranceFee() external view returns(uint256) {\n        return currentTournamentBank * tournamentEntranceFeeCut / 10000;\n    }\n    \n    //@dev returns tournament entrance fee - 3% threshold\n    function getTournamentThresholdFee() public view returns(uint256) {\n        return currentTournamentBank * tournamentEntranceFeeCut * (10000 - THRESHOLD) / 10000 / 10000;\n    }\n    \n    //@dev returns max allowed tournament contenders, public because of internal use\n    function maxTournamentContenders() public view returns(uint256){\n        return tournamentQueue.length / DATA_SIZE;\n    }\n    \n    function canFinishTournament() external view returns(bool) {\n        return tournamentEndBlock <= block.number && tournamentQueueSize > 0;\n    }\n    \n    // @dev Internal utility function to sigin up to tournament, \n    // assumes that all battle requirements have been checked.\n    function _triggerNewTournamentContender(address _owner, uint256[] memory _tournamentData, uint256 _fee) internal {\n        //pack warrior ids into uint256\n        \n        currentTournamentBank += _fee;\n        \n        uint256 packedWarriorIds = CryptoUtils._packWarriorIds(_tournamentData);\n        //make composite warrior out of 5 warriors \n        uint256 combinedWarrior = CryptoUtils._combineWarriors(_tournamentData);\n        \n        //add to queue\n        //icrement tournament queue\n        uint256 size = tournamentQueueSize++ * DATA_SIZE;\n        //record tournament data\n\t\ttournamentQueue[size++] = packedWarriorIds;\n\t\ttournamentQueue[size++] = combinedWarrior;\n\t\twarriorToOwner[CryptoUtils._unpackWarriorId(packedWarriorIds, 0)] = _owner;\n\t\t//\n\t\t//Emit event\n\t\tTournamentNewContender(_owner, packedWarriorIds, _fee);\n    }\n    \n    function addTournamentContender(address _owner, uint256[] _tournamentData) external payable TournamentNotPaused{\n        // Caller must be pvpListener contract\n        require(msg.sender == address(pvpListener));\n        \n        require(_owner != address(0));\n        //\n        //check current tournament bank > 0\n        require(pvpBattleFee == 0 || currentTournamentBank > 0);\n        //\n        //check that there is enough funds to pay entrance fee\n        uint256 fee = getTournamentThresholdFee();\n        require(msg.value >= fee);\n        //owner must withdraw all booty before contending pvp\n        require(ownerToBooty[_owner] == 0);\n        //\n        //check that warriors group is exactly of allowed size\n        require(_tournamentData.length == GROUP_SIZE);\n        //\n        //check that there is enough room for new participants\n        require(tournamentQueueSize < maxTournamentContenders());\n        //\n        //check that admission started\n        require(block.number >= getTournamentAdmissionBlock());\n        //check that admission not ended\n        require(block.number <= tournamentEndBlock);\n        \n        //all checks passed, trigger sign up\n        _triggerNewTournamentContender(_owner, _tournamentData, fee);\n    }\n    \n    //@dev collect all combined warriors data\n    function getCombinedWarriors() internal view returns(uint256[] memory warriorsData) {\n        uint256 length = tournamentQueueSize;\n        warriorsData = new uint256[](length);\n        \n        for(uint256 i = 0; i < length; i ++) {\n            // Grab the combined warrior data in storage.\n            warriorsData[i] = tournamentQueue[i * DATA_SIZE + 1];\n        }\n        return warriorsData;\n    }\n    \n    function getTournamentState() external view returns\n    (uint256 contendersCount, uint256 bank, uint256 admissionStartBlock, uint256 endBlock, uint256 incentiveReward)\n    {\n    \tcontendersCount = tournamentQueueSize;\n    \tbank = currentTournamentBank;\n    \tadmissionStartBlock = getTournamentAdmissionBlock();   \n    \tendBlock = tournamentEndBlock;\n    \tincentiveReward = _computeTournamentIncentiveReward(bank, _computeIncentiveCut(bank, tournamentIncentiveCut));\n    }\n    \n    function _repackToCombinedIds(uint256[] memory _warriorsData) internal view {\n        uint256 length = _warriorsData.length;\n        for(uint256 i = 0; i < length; i ++) {\n            _warriorsData[i] = tournamentQueue[i * DATA_SIZE];\n        }\n    }\n    \n    // @dev Computes warrior pvp reward\n    // @param _totalBet - total bet from both competitors.\n    function _computeTournamentBooty(uint256 _currentBank, uint256 _contenderResult, uint256 _totalBattles) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\n        // _totalBattles is guaranteed to be > 0 and <= 400, and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _reward.\n        // return _currentBank * (10000 - tournamentOwnersCut - _incentiveCut) * _result / 10000 / _totalBattles;\n        return _currentBank * _contenderResult / _totalBattles;\n        \n    }\n    \n    function _grandTournamentBooty(uint256 _warriorIds, uint256 _currentBank, uint256 _contenderResult, uint256 _totalBattles)\n    internal returns (uint256)\n    {\n        uint256 warriorId = CryptoUtils._unpackWarriorId(_warriorIds, 0);\n        address owner = warriorToOwner[warriorId];\n        uint256 booty = _computeTournamentBooty(_currentBank, _contenderResult, _totalBattles);\n        return sendBooty(owner, booty);\n    }\n    \n    function _grandTournamentRewards(uint256 _currentBank, uint256[] memory _warriorsData, uint32[] memory _results) internal returns (uint256){\n        uint256 length = _warriorsData.length;\n        uint256 totalBattles = CryptoUtils._getTournamentBattles(length) * 10000;//*10000 required for booty computation\n        uint256 incentiveCut = _computeIncentiveCut(_currentBank, tournamentIncentiveCut);\n        uint256 contenderCut = _computeTournamentContenderCut(incentiveCut);\n        \n        uint256 failedBooty = 0;\n        for(uint256 i = 0; i < length; i ++) {\n            //grand rewards\n            failedBooty += _grandTournamentBooty(_warriorsData[i], _currentBank, _results[i] * contenderCut, totalBattles);\n        }\n        //send beneficiary fee\n        failedBooty += sendBooty(pvpListener.getBeneficiary(), _computeTournamentBeneficiaryFee(_currentBank));\n        if (failedBooty > 0) {\n            totalBooty += failedBooty;\n        }\n        return _computeTournamentIncentiveReward(_currentBank, incentiveCut);\n    }\n    \n    function _repackToWarriorOwners(uint256[] memory warriorsData) internal view {\n        uint256 length = warriorsData.length;\n        for (uint256 i = 0; i < length; i ++) {\n            warriorsData[i] = uint256(warriorToOwner[CryptoUtils._unpackWarriorId(warriorsData[i], 0)]);\n        }\n    }\n    \n    function _triggerFinishTournament() internal returns(uint256){\n        //hold 10 random battles for each composite warrior\n        uint256[] memory warriorsData = getCombinedWarriors();\n        uint32[] memory results = CryptoUtils.getTournamentBattleResults(warriorsData, tournamentEndBlock - 1);\n        //repack combined warriors id\n        _repackToCombinedIds(warriorsData);\n        //notify pvp listener\n        pvpListener.tournamentFinished(warriorsData);\n        //reschedule\n        //clear tournament\n        tournamentQueueSize = 0;\n        //schedule new tournament\n        _scheduleTournament();\n        \n        uint256 currentBank = currentTournamentBank;\n        currentTournamentBank = 0;//nullify before sending to users\n        //grand rewards, not susceptible to reentry attack\n        //because of require(tournamentEndBlock <= block.number)\n        //and require(tournamentQueueSize > 0) and currentTournamentBank == 0\n        uint256 incentiveReward = _grandTournamentRewards(currentBank, warriorsData, results);\n        \n        currentTournamentBank = nextTournamentBank;\n        nextTournamentBank = 0;\n        \n        _repackToWarriorOwners(warriorsData);\n        \n        //emit event\n        TournamentFinished(warriorsData, results, currentBank);\n\n        return incentiveReward;\n    }\n    \n    function finishTournament() external TournamentNotPaused {\n        //make all the checks\n        // tournament is ready to be executed\n        require(tournamentEndBlock <= block.number);\n        // we have participants\n        require(tournamentQueueSize > 0);\n        \n        uint256 incentiveReward = _triggerFinishTournament();\n        \n        //give reward for incentive\n        safeSend(msg.sender, incentiveReward);\n    }\n    \n    \n    // @dev Remove all PVP contenders from PVP queue \n    //  and return all entrance fees to warrior owners.\n    //  NB: this is emergency method, used only in f%#^@up situation\n    function removeAllTournamentContenders() external onlyOwner TournamentPaused {\n        //remove all pvp contenders\n        uint256 length = tournamentQueueSize;\n        \n        uint256 warriorId;\n        uint256 failedBooty;\n        uint256 i;\n\n        uint256 fee;\n        uint256 bank = currentTournamentBank;\n        \n        uint256[] memory warriorsData = new uint256[](length);\n        //get tournament warriors\n        for(i = 0; i < length; i ++) {\n            warriorsData[i] = tournamentQueue[i * DATA_SIZE];\n        }\n        //notify pvp listener\n        pvpListener.tournamentFinished(warriorsData);\n        //return entrance fee to warrior owners\n     \tcurrentTournamentBank = 0;\n        tournamentQueueSize = 0;\n\n        for(i = length - 1; i >= 0; i --) {\n            //return entrance fee\n            warriorId = CryptoUtils._unpackWarriorId(warriorsData[i], 0);\n            //compute contender entrance fee\n\t\t\tfee = bank - (bank * 10000 / (tournamentEntranceFeeCut * (10000 - THRESHOLD) / 10000 + 10000));\n\t\t\t//return entrance fee to owner\n\t        failedBooty += sendBooty(warriorToOwner[warriorId], fee);\n\t        //subtract fee from bank, for next use\n\t        bank -= fee;\n        }\n        currentTournamentBank = bank;\n        totalBooty += failedBooty;\n    }\n}\n\ncontract BattleProvider is Tournament {\n    \n    function BattleProvider(address _pvpListener, uint256 _pvpCut, uint256 _tournamentCut, uint256 _incentiveCut, \n    uint256 _tournamentOwnersCut, uint256 _tournamentIncentiveCut) public \n    Tournament(_pvpCut, _tournamentCut, _incentiveCut, _tournamentOwnersCut, _tournamentIncentiveCut) \n    {\n        PVPListenerInterface candidateContract = PVPListenerInterface(_pvpListener);\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isPVPListener());\n        // Set the new contract address\n        pvpListener = candidateContract;\n        \n        // the creator of the contract is the initial owner\n        owner = msg.sender;\n    }\n    \n    \n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    // right BattleProvider in our setBattleProviderAddress() call.\n    function isPVPProvider() external pure returns (bool) {\n        return true;\n    }\n    \n    function setSecondsPerBlock(uint256 secs) external onlyOwner {\n        secondsPerBlock = secs;\n    }\n}\n\n\n/* warrior identity generator*/\ncontract WarriorGenerator is Pausable, SanctuaryInterface {\n    \n    CryptoWarriorCore public coreContract;\n    \n    /* LIMITS */\n    uint32[19] public parameters;/*  = [\n        uint32(10),//0_bodyColorMax3\n        uint32(10),//1_eyeshMax4\n        uint32(10),//2_mouthMax5\n        uint32(20),//3_heirMax6\n        uint32(10),//4_heirColorMax7\n        uint32(3),//5_armorMax8\n        uint32(3),//6_weaponMax9\n        uint32(3),//7_hatMax10\n        uint32(4),//8_runesMax11\n        uint32(1),//9_wingsMax12\n        uint32(10),//10_petMax13\n        uint32(6),//11_borderMax14\n        uint32(6),//12_backgroundMax15\n        uint32(10),//13_unique\n        uint32(900),//14_legendary\n        uint32(9000),//15_mythic\n        uint32(90000),//16_rare\n        uint32(900000),//17_uncommon\n        uint32(0)//18_uniqueTotal\n    ];*/\n    \n\n    function changeParameter(uint32 _paramIndex, uint32 _value) external onlyOwner {\n        CryptoUtils._changeParameter(_paramIndex, _value, parameters);\n    }\n\n    // / @dev simply a boolean to indicate this is the contract we expect to be\n    function isSanctuary() public pure returns (bool){\n        return true;\n    }\n\n    // / @dev generate new warrior identity\n    // / @param _heroIdentity Genes of warrior that invoked resurrection, if 0 => Demigod gene that signals to generate unique warrior\n    // / @param _heroLevel Level of the warrior\n    // / @_targetBlock block number from which hash will be taken\n    // / @_perkId special perk id, like MINER(1)\n    // / @return the identity that are supposed to be passed down to newly arisen warrior\n    function generateWarrior(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) \n    public returns (uint256) \n    {\n        //only core contract can call this method\n        require(msg.sender == address(coreContract));\n        \n        return _generateIdentity(_heroIdentity, _heroLevel, _targetBlock, _perkId);\n    }\n    \n    function _generateIdentity(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) internal returns(uint256){\n        \n        //get memory copy, to reduce storage read requests\n        uint32[19] memory memoryParams = parameters;\n        //generate warrior identity\n        uint256 identity = CryptoUtils.generateWarrior(_heroIdentity, _heroLevel, _targetBlock, _perkId, memoryParams);\n        \n        //validate before pushing changes to storage\n        CryptoUtils._validateIdentity(identity, memoryParams);\n        //push changes to storage\n        CryptoUtils._recordWarriorData(identity, parameters);\n        \n        return identity;\n    }\n}\n\ncontract WarriorSanctuary is WarriorGenerator {\n    uint256 internal constant SUMMONING_SICKENESS = 12 hours;\n    uint256 internal constant RITUAL_DURATION = 15 minutes;\n    /// @notice The payment required to use startRitual().\n    uint256 public ritualFee = 10 finney;\n    \n    uint256 public constant RITUAL_COMPENSATION = 2 finney;\n    \n    mapping(address => uint256) public soulCounter;\n    //\n    mapping(address => uint256) public ritualTimeBlock;\n    \n    bool public recoveryAllowed = true;\n    \n    event WarriorBurned(uint256 warriorId, address owner);\n    event RitualStarted(address owner, uint256 numberOfSouls);\n    event RitualFinished(address owner, uint256 numberOfSouls, uint256 newWarriorId);\n    \n    \n    function WarriorSanctuary(address _coreContract, uint32[] _settings) public {\n        uint256 length = _settings.length;\n        require(length == 18);\n        require(_settings[8] == 4);//check runes max\n        require(_settings[10] == 10);//check pets max\n        require(_settings[11] == 5);//check border max\n        require(_settings[12] == 6);//check background max\n        //setup parameters\n        for(uint256 i = 0; i < length; i ++) {\n            parameters[i] = _settings[i];\n        }\t\n        \n        //set core\n        CryptoWarriorCore coreCondidat = CryptoWarriorCore(_coreContract);\n        require(coreCondidat.isPVPListener());\n        coreContract = coreCondidat;\n        \n    }\n    \n    function recoverSouls(address[] owners, uint256[] souls, uint256[] blocks) external onlyOwner {\n        require(recoveryAllowed);\n        \n        uint256 length = owners.length;\n        require(length == souls.length && length == blocks.length);\n        \n        for(uint256 i = 0; i < length; i ++) {\n            soulCounter[owners[i]] = souls[i];\n            ritualTimeBlock[owners[i]] = blocks[i];\n        }\n        \n        recoveryAllowed = false;\n    }\n    \n    \n    //burn warrior\n    function burnWarrior(uint256 _warriorId) whenNotPaused external {\n        coreContract.burnWarrior(_warriorId, msg.sender);\n        \n        soulCounter[msg.sender] ++;\n        \n        WarriorBurned(_warriorId, msg.sender);\n    }\n   \n    \n    function startRitual() whenNotPaused external payable {\n        // Checks for payment.\n        require(msg.value >= ritualFee);\n        \n        uint256 souls = soulCounter[msg.sender];\n        // Check that address has at least 10 burned souls\n        require(souls >= 10);\n        //\n        //Check that no rituals are in progress\n        require(ritualTimeBlock[msg.sender] == 0);\n        \n        ritualTimeBlock[msg.sender] = RITUAL_DURATION / coreContract.secondsPerBlock() + block.number;\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 feeExcess = msg.value - ritualFee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of _isReadyToPVE check\n        // will fail\n        if (feeExcess > 0) {\n            msg.sender.transfer(feeExcess);\n        }\n        //send battle fee to beneficiary\n        coreContract.getBeneficiary().transfer(ritualFee - RITUAL_COMPENSATION);\n        \n        RitualStarted(msg.sender, souls);\n    }\n    \n    \n    //arise warrior\n    function finishRitual(address _owner) whenNotPaused external {\n        // Check ritual time is over\n        uint256 timeBlock = ritualTimeBlock[_owner];\n        require(timeBlock > 0 && timeBlock <= block.number);\n        \n        uint256 souls = soulCounter[_owner];\n        \n        require(souls >= 10);\n        \n        uint256 identity = _generateIdentity(uint256(_owner), souls, timeBlock - 1, 0);\n        \n        uint256 warriorId = coreContract.ariseWarrior(identity, _owner, block.number + (SUMMONING_SICKENESS / coreContract.secondsPerBlock()));\n    \n        soulCounter[_owner] = 0;\n        ritualTimeBlock[_owner] = 0;\n        //send compensation\n        msg.sender.transfer(RITUAL_COMPENSATION);\n        \n        RitualFinished(_owner, 10, warriorId);\n    }\n    \n    function setRitualFee(uint256 _pveRitualFee) external onlyOwner {\n        require(_pveRitualFee > RITUAL_COMPENSATION);\n        ritualFee = _pveRitualFee;\n    }\n}\n\ncontract AuctionBase {\n\tuint256 public constant PRICE_CHANGE_TIME_STEP = 15 minutes;\n    //\n    struct Auction{\n        address seller;\n        uint128 startingPrice;\n        uint128 endingPrice;\n        uint64 duration;\n        uint64 startedAt;\n    }\n    mapping (uint256 => Auction) internal tokenIdToAuction;\n    uint256 public ownerCut;\n    ERC721 public nonFungibleContract;\n\n    event AuctionCreated(uint256 tokenId, address seller, uint256 startingPrice);\n\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner, address seller);\n\n    event AuctionCancelled(uint256 tokenId, address seller);\n\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool){\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n    }\n\n    function _escrow(address _owner, uint256 _tokenId) internal{\n        nonFungibleContract.transferFrom(_owner, address(this), _tokenId);\n    }\n\n    function _transfer(address _receiver, uint256 _tokenId) internal{\n        nonFungibleContract.transfer(_receiver, _tokenId);\n    }\n\n    function _addAuction(uint256 _tokenId, Auction _auction) internal{\n        require(_auction.duration >= 1 minutes);\n        \n        tokenIdToAuction[_tokenId] = _auction;\n        \n        AuctionCreated(uint256(_tokenId), _auction.seller, _auction.startingPrice);\n    }\n\n    function _cancelAuction(uint256 _tokenId, address _seller) internal{\n        _removeAuction(_tokenId);\n        \n        _transfer(_seller, _tokenId);\n        \n        AuctionCancelled(_tokenId, _seller);\n    }\n\n    function _bid(uint256 _tokenId, uint256 _bidAmount) internal returns (uint256){\n        \n        Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        uint256 price = _currentPrice(auction);\n        \n        require(_bidAmount >= price);\n        \n        address seller = auction.seller;\n        \n        _removeAuction(_tokenId);\n        \n        if (price > 0) {\n            uint256 auctioneerCut = _computeCut(price);\n            uint256 sellerProceeds = price - auctioneerCut;\n            seller.transfer(sellerProceeds);\n            nonFungibleContract.getBeneficiary().transfer(auctioneerCut);\n        }\n        \n        uint256 bidExcess = _bidAmount - price;\n        \n        msg.sender.transfer(bidExcess);\n        \n        AuctionSuccessful(_tokenId, price, msg.sender, seller);\n        \n        return price;\n    }\n\n    function _removeAuction(uint256 _tokenId) internal{\n        delete tokenIdToAuction[_tokenId];\n    }\n\n    function _isOnAuction(Auction storage _auction) internal view returns (bool){\n        return (_auction.startedAt > 0);\n    }\n\n    function _currentPrice(Auction storage _auction)\n        internal\n        view\n        returns (uint256){\n        uint256 secondsPassed = 0;\n        \n        if (now > _auction.startedAt) {\n            secondsPassed = now - _auction.startedAt;\n        }\n        \n        return _computeCurrentPrice(_auction.startingPrice,\n            _auction.endingPrice,\n            _auction.duration,\n            secondsPassed);\n    }\n    \n    function _computeCurrentPrice(uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        uint256 _secondsPassed)\n        internal\n        pure\n        returns (uint256){\n        if (_secondsPassed >= _duration) {\n            return _endingPrice;\n        } else {\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\n            \n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed / PRICE_CHANGE_TIME_STEP * PRICE_CHANGE_TIME_STEP) / int256(_duration);\n            \n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\n            \n            return uint256(currentPrice);\n        }\n    }\n\n    function _computeCut(uint256 _price) internal view returns (uint256){\n        \n        return _price * ownerCut / 10000;\n    }\n}\n\ncontract SaleClockAuction is Pausable, AuctionBase {\n    \n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9f40b779);\n    \n    bool public isSaleClockAuction = true;\n    uint256 public minerSaleCount;\n    uint256[5] public lastMinerSalePrices;\n\n    function SaleClockAuction(address _nftAddress, uint256 _cut) public{\n        require(_cut <= 10000);\n        ownerCut = _cut;\n        ERC721 candidateContract = ERC721(_nftAddress);\n        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n        require(candidateContract.getBeneficiary() != address(0));\n        \n        nonFungibleContract = candidateContract;\n    }\n\n    function cancelAuction(uint256 _tokenId)\n        external{\n        \n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        address seller = auction.seller;\n        \n        require(msg.sender == seller);\n        \n        _cancelAuction(_tokenId, seller);\n    }\n\n    function cancelAuctionWhenPaused(uint256 _tokenId)\n        whenPaused\n        onlyOwner\n        external{\n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        _cancelAuction(_tokenId, auction.seller);\n    }\n\n    function getCurrentPrice(uint256 _tokenId)\n        external\n        view\n        returns (uint256){\n        \n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        return _currentPrice(auction);\n    }\n    \n    function createAuction(uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller)\n        whenNotPaused\n        external{\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n        require(msg.sender == address(nonFungibleContract));\n        _escrow(_seller, _tokenId);\n        \n        AuctionBase.Auction memory auction = Auction(_seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now));\n        \n        _addAuction(_tokenId, auction);\n    }\n    \n    function bid(uint256 _tokenId)\n        whenNotPaused\n        external\n        payable{\n        \n        address seller = tokenIdToAuction[_tokenId].seller;\n        \n        uint256 price = _bid(_tokenId, msg.value);\n        \n        _transfer(msg.sender, _tokenId);\n        \n        if (seller == nonFungibleContract.getBeneficiary()) {\n            lastMinerSalePrices[minerSaleCount % 5] = price;\n            minerSaleCount++;\n        }\n    }\n\n    function averageMinerSalePrice() external view returns (uint256){\n        uint256 sum = 0;\n        for (uint256 i = 0; i < 5; i++){\n            sum += lastMinerSalePrices[i];\n        }\n        return sum / 5;\n    }\n    \n    /**getAuctionsById returns packed actions data\n     * @param tokenIds ids of tokens, whose auction's must be active \n     * @return auctionData as uint256 array\n     * @return stepSize number of fields describing auction \n     */\n    function getAuctionsById(uint32[] tokenIds) external view returns(uint256[] memory auctionData, uint32 stepSize) {\n        stepSize = 6;\n        auctionData = new uint256[](tokenIds.length * stepSize);\n        \n        uint32 tokenId;\n        for(uint32 i = 0; i < tokenIds.length; i ++) {\n            tokenId = tokenIds[i];\n            AuctionBase.Auction storage auction = tokenIdToAuction[tokenId];\n            require(_isOnAuction(auction));\n            _setTokenData(auctionData, auction, tokenId, i * stepSize);\n        }\n    }\n    \n    /**getAuctions returns packed actions data\n     * @param fromIndex warrior index from global warrior storage (aka warriorId)\n     * @param count Number of auction's to find, if count == 0, then exact warriorId(fromIndex) will be searched\n     * @return auctionData as uint256 array\n     * @return stepSize number of fields describing auction \n     */\n    function getAuctions(uint32 fromIndex, uint32 count) external view returns(uint256[] memory auctionData, uint32 stepSize) {\n        stepSize = 6;\n        if (count == 0) {\n            AuctionBase.Auction storage auction = tokenIdToAuction[fromIndex];\n\t        \trequire(_isOnAuction(auction));\n\t        \tauctionData = new uint256[](1 * stepSize);\n\t        \t_setTokenData(auctionData, auction, fromIndex, count);\n\t        \treturn (auctionData, stepSize);\n        } else {\n            uint256 totalWarriors = nonFungibleContract.totalSupply();\n\t        if (totalWarriors == 0) {\n\t            // Return an empty array\n\t            return (new uint256[](0), stepSize);\n\t        } else {\n\t\n\t            uint32 totalSize = 0;\n\t            uint32 tokenId;\n\t            uint32 size = 0;\n\t\t\t\tauctionData = new uint256[](count * stepSize);\n\t            for (tokenId = 0; tokenId < totalWarriors && size < count; tokenId++) {\n\t                AuctionBase.Auction storage auction1 = tokenIdToAuction[tokenId];\n\t        \n\t\t        \t\tif (_isOnAuction(auction1)) {\n\t\t        \t\t    totalSize ++;\n\t\t        \t\t    if (totalSize > fromIndex) {\n\t\t        \t\t        _setTokenData(auctionData, auction1, tokenId, size++ * stepSize);//warriorId;\n\t\t        \t\t    }\n\t\t        \t\t}\n\t            }\n\t            \n\t            if (size < count) {\n\t                size *= stepSize;\n\t                uint256[] memory repack = new uint256[](size);\n\t                for(tokenId = 0; tokenId < size; tokenId++) {\n\t                    repack[tokenId] = auctionData[tokenId];\n\t                }\n\t                return (repack, stepSize);\n\t            }\n\t\n\t            return (auctionData, stepSize);\n\t        }\n        }\n    }\n    \n    // @dev Returns auction info for an NFT on auction.\n    // @param _tokenId - ID of NFT on auction.\n    function getAuction(uint256 _tokenId) external view returns(\n        address seller,\n        uint256 startingPrice,\n        uint256 endingPrice,\n        uint256 duration,\n        uint256 startedAt\n        ){\n        \n        Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        return (auction.seller,\n            auction.startingPrice,\n            auction.endingPrice,\n            auction.duration,\n            auction.startedAt);\n    }\n    \n    //pack NFT data into specified array\n    function _setTokenData(uint256[] memory auctionData, \n        AuctionBase.Auction storage auction, uint32 tokenId, uint32 index\n    ) internal view {\n        auctionData[index] = uint256(tokenId);//0\n        auctionData[index + 1] = uint256(auction.seller);//1\n        auctionData[index + 2] = uint256(auction.startingPrice);//2\n        auctionData[index + 3] = uint256(auction.endingPrice);//3\n        auctionData[index + 4] = uint256(auction.duration);//4\n        auctionData[index + 5] = uint256(auction.startedAt);//5\n    }\n    \n}",
  "abi": "[{\"constant\":false,\"inputs\":[],\"name\":\"removeAllPVPContenders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pvpMaxIncentiveCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"grabBooty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tournamentQueue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PVP_INTERVAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournamentQueueSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournamentBankCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMISSION_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpausePVP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTournamentThresholdFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATING_EXPAND_INTERVAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournamentEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pvpOwnerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canFinishTournament\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pvpQueue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canFinishPVP\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextTournamentBank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishPVP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTournamentAdmissionBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secs\",\"type\":\"uint256\"}],\"name\":\"setSecondsPerBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cut\",\"type\":\"uint256\"}],\"name\":\"setTournamentEntranceFeeCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setPVPEntranceFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPVPState\",\"outputs\":[{\"name\":\"contendersCount\",\"type\":\"uint256\"},{\"name\":\"matchingCount\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"incentiveReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_levelPoints\",\"type\":\"uint256\"}],\"name\":\"getPVPEntranceFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishTournament\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeAllTournamentContenders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTournamentState\",\"outputs\":[{\"name\":\"contendersCount\",\"type\":\"uint256\"},{\"name\":\"bank\",\"type\":\"uint256\"},{\"name\":\"admissionStartBlock\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"incentiveReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FUND_GATHERING_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pvpPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pausePVP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTournamentEntranceFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTournamentBank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournamentIncentiveCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPVPBatleBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_warriorId\",\"type\":\"uint256\"}],\"name\":\"removePVPContender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_packedWarrior\",\"type\":\"uint256\"}],\"name\":\"addPVPContender\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBooty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournamentOwnersCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerToBooty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTournamentContenders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseTournament\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournamentPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseTournament\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPVPContenders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pvpQueueSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPVPProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tournamentData\",\"type\":\"uint256[]\"}],\"name\":\"addTournamentContender\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"warriorIds\",\"type\":\"uint32[]\"}],\"name\":\"getPVPCycles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_pvpListener\",\"type\":\"address\"},{\"name\":\"_pvpCut\",\"type\":\"uint256\"},{\"name\":\"_tournamentCut\",\"type\":\"uint256\"},{\"name\":\"_incentiveCut\",\"type\":\"uint256\"},{\"name\":\"_tournamentOwnersCut\",\"type\":\"uint256\"},{\"name\":\"_tournamentIncentiveCut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"warriorIds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"entranceFee\",\"type\":\"uint256\"}],\"name\":\"TournamentNewContender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owners\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"results\",\"type\":\"uint32[]\"},{\"indexed\":false,\"name\":\"tournamentBank\",\"type\":\"uint256\"}],\"name\":\"TournamentFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tournamentEndBlock\",\"type\":\"uint256\"}],\"name\":\"TournamentScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nextPVPBatleBlock\",\"type\":\"uint256\"}],\"name\":\"PVPScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"warriorId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"entranceFee\",\"type\":\"uint256\"}],\"name\":\"PVPNewContender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"warriorsData\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"owners\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"matchingCount\",\"type\":\"uint256\"}],\"name\":\"PVPFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BootySendFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BootyGrabbed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"warriorId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PVPContenderRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"PausePVP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"PauseTournament\",\"type\":\"event\"}]",
  "bytecode": "60606040526000805460a060020a61ffff02191681556065819055600f606855662386f26fc10000606b55606c819055606d819055606e819055607181905560725560646101145534156200005357600080fd5b60405160c08062003add83398101604052808051919060200180519190602001805191906020018051919060200180519190602001805160008054600160a060020a03191633600160a060020a03161781559092509050858585858584848461271082840182011115620000c657600080fd5b606992909255606f55606a556127108282011115620000e457600080fd5b61011591909155610116555088925050600160a060020a038216905063e4d9d2126000604051602001526040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15156200015657600080fd5b6102c65a03f115156200016857600080fd5b5050506040518051905015156200017e57600080fd5b60738054600160a060020a03928316600160a060020a03199182161790915560008054339093169290911691909117905550505050505061391880620001c56000396000f3006060604052600436106102425763ffffffff60e060020a600035041663059d45da81146102475780630c26a8161461025c5780630ca435a61461028157806315834aed146102945780631924f74a146102aa5780631ba5e63f146102bd5780631c44bac7146102d05780631ca43cef146102e357806320154e78146102f657806324abfc02146103095780632a6c703b1461031c5780634474809f1461032f5780634619aa191461034257806346682cab14610355578063477e5d241461037c5780634a7761041461039257806351c85565146103a5578063534e3f81146103b857806354070f83146103cb5780635663896e146103de57806359bb7867146103f45780635c7d64251461040a5780636147bcb914610420578063637492251461045e5780636b2bb92a146104745780636f6f828e1461048757806374af3ee11461049a5780637a314ce2146104df5780637ced55c2146104f257806389cda6a8146105055780638da5cb5b146105185780638db7cd54146105475780639d619dad1461055a578063a43b92a21461056d578063a48255b714610580578063a72f3dea14610593578063a99306e7146105a9578063af10b8cf146105c0578063b3a810f7146105d3578063bd1954c6146105e6578063c6169e1f14610605578063d08279b014610618578063d34468561461062b578063d8a489d91461063e578063f15a9ae814610651578063f2fde38b14610664578063f73c8dfd14610683578063f773ab8014610696578063f8b608a1146106a9578063fe1b602a146106c9575b600080fd5b341561025257600080fd5b61025a61073a565b005b341561026757600080fd5b61026f61085f565b60405190815260200160405180910390f35b341561028c57600080fd5b61025a610865565b341561029f57600080fd5b61026f60043561092e565b34156102b557600080fd5b61026f610942565b34156102c857600080fd5b61026f610948565b34156102db57600080fd5b61026f61094e565b34156102ee57600080fd5b61026f610954565b341561030157600080fd5b61025a61095a565b341561031457600080fd5b61026f6109e2565b341561032757600080fd5b61026f6109ff565b341561033a57600080fd5b61026f610a05565b341561034d57600080fd5b61026f610a0b565b341561036057600080fd5b610368610a11565b604051901515815260200160405180910390f35b341561038757600080fd5b61026f600435610a2c565b341561039d57600080fd5b610368610a39565b34156103b057600080fd5b61026f610a6e565b34156103c357600080fd5b61025a610a74565b34156103d657600080fd5b61026f610ae9565b34156103e957600080fd5b61025a600435610b1a565b34156103ff57600080fd5b61025a600435610b3a565b341561041557600080fd5b61025a600435610b77565b341561042b57600080fd5b610433610ba4565b6040518085815260200184815260200183815260200182815260200194505050505060405180910390f35b341561046957600080fd5b61026f600435610bea565b341561047f57600080fd5b61025a610bff565b341561049257600080fd5b61025a610c4e565b34156104a557600080fd5b6104ad610e46565b604051808681526020018581526020018481526020018381526020018281526020019550505050505060405180910390f35b34156104ea57600080fd5b61026f610e7e565b34156104fd57600080fd5b610368610e85565b341561051057600080fd5b61025a610e95565b341561052357600080fd5b61052b610f23565b604051600160a060020a03909116815260200160405180910390f35b341561055257600080fd5b61026f610f32565b341561056557600080fd5b61026f610f46565b341561057857600080fd5b61026f610f4c565b341561058b57600080fd5b61026f610f53565b341561059e57600080fd5b61025a600435610f59565b61025a600160a060020a0360043516602435611105565b34156105cb57600080fd5b61026f6111d1565b34156105de57600080fd5b61026f6111d7565b34156105f157600080fd5b61026f600160a060020a03600435166111de565b341561061057600080fd5b61026f6111f0565b341561062357600080fd5b61025a6111fb565b341561063657600080fd5b610368611284565b341561064957600080fd5b61025a611294565b341561065c57600080fd5b61026f611323565b341561066f57600080fd5b61025a600160a060020a0360043516611328565b341561068e57600080fd5b61026f61137f565b34156106a157600080fd5b610368611385565b61025a60048035600160a060020a0316906024803590810191013561138a565b34156106d457600080fd5b6106e760048035602481019101356114ad565b60405160208082528190810183818151815260200191508051906020019060200280838360005b8381101561072657808201518382015260200161070e565b505050509050019250505060405180910390f35b600080548190819081908190819033600160a060020a0390811691161461076057600080fd5b60005460a060020a900460ff16151561077857600080fd5b506065805460009182905595505b8581101561084f576001816064811061079b57fe5b015494506107a88561158b565b607354909450600160a060020a031663d7d3c4d5856040518263ffffffff1660e060020a028152600401808263ffffffff168152602001915050600060405180830381600087803b15156107fb57600080fd5b6102c65a03f1151561080c57600080fd5b505050600084815260676020526040902054600160a060020a031691506108438261083e610839886115b8565b6115c9565b6115d0565b90920191600101610786565b5050606d80549091019055505050565b606a5481565b600160a060020a03331660009081526066602052604081205490811161088a57600080fd5b606d548190101561089a57600080fd5b600160a060020a03331660008181526066602052604080822091909155606d8054849003905582156108fc0290839051600060405180830381858888f1935050505015156108e757600080fd5b7fd7a49720c00abce919ff2e9064ad8b7c58f0f539d778c4442b4c86422462d11b3382604051600160a060020a03909216825260208201526040908101905180910390a150565b60748160a0811061093b57fe5b0154905081565b61038481565b606e5481565b606f5481565b61a8c081565b60005433600160a060020a0390811691161461097557600080fd5b60005460a060020a900460ff16151561098d57600080fd5b6000805474ff0000000000000000000000000000000000000000191681557f4e494720a65633d819abbff3aa9af070f5451ce37f40dcdbb5b78b6bbbd8eac490604051901515815260200160405180910390a1565b6101145460715460009161271091026125e4028190045b04905090565b610e1081565b60705481565b60695481565b60004360705411158015610a2757506000606e54115b905090565b6001816064811061093b57fe5b600043606c5411158015610a2757506001610a68610a55611687565b610384610a606116f4565b610e1061171a565b11905090565b60725481565b610a7c6138da565b60008054819060a060020a900460ff1615610a9657600080fd5b606c5443901115610aa657600080fd5b610aae611687565b9250610abf83610384610a606116f4565b915060018211610ace57600080fd5b610ad8838361184e565b9050610ae43382611a3d565b505050565b60008060685461a8c0811515610afb57fe5b0490508060705410610b11578060705403610b14565b60005b91505090565b60005433600160a060020a03908116911614610b3557600080fd5b606855565b60005433600160a060020a03908116911614610b5557600080fd5b612710811115610b6457600080fd5b606e5415610b7157600080fd5b61011455565b60005433600160a060020a03908116911614610b9257600080fd5b60655415610b9f57600080fd5b606b55565b600080600080610bb26138da565b610bba611687565b90506065549450610bd081610384610a606116f4565b9350606c549250610be18185611a61565b91505090919293565b6000610bf582611a88565b606b540292915050565b6000805460a860020a900460ff1615610c1757600080fd5b60705443901115610c2757600080fd5b606e5460009011610c3757600080fd5b610c3f611a92565b9050610c4b3382611a3d565b50565b600080600080600080610c5f6138da565b60005433600160a060020a03908116911614610c7a57600080fd5b60005460a860020a900460ff161515610c9257600080fd5b606e549650607154915086604051805910610caa5750595b90808252806020026020018201604052509050600093505b86841015610cfd5760746002850260a08110610cda57fe5b0154818581518110610ce857fe5b60209081029091010152600190930192610cc2565b607354600160a060020a03166311196cc2826040518263ffffffff1660e060020a0281526004018080602001828103825283818151815260200191508051906020019060200280838360005b83811015610d61578082015183820152602001610d49565b5050505090500192505050600060405180830381600087803b1515610d8557600080fd5b6102c65a03f11515610d9657600080fd5b505060006071819055606e5550600019870193505b60008410610e3357610dd3818581518110610dc257fe5b906020019060200201516000611c6b565b61011454909650612710906125e40204612710018261271002811515610df557fe5b60008881526067602052604090205491900483039350610e1e90600160a060020a0316846115d0565b90940193600019909301929082900390610dab565b506071555050606d805490910190555050565b606e5460715460008080610e58610ae9565b92506070549150610e7584610e708661011654611c9c565b611ce9565b90509091929394565b6201518081565b60005460a060020a900460ff1681565b60005433600160a060020a03908116911614610eb057600080fd5b60005460a060020a900460ff1615610ec757600080fd5b6000805474ff0000000000000000000000000000000000000000191660a060020a1790557f4e494720a65633d819abbff3aa9af070f5451ce37f40dcdbb5b78b6bbbd8eac46001604051901515815260200160405180910390a1565b600054600160a060020a031681565b6101145460715460009161271091026109f9565b60715481565b6101165481565b606c5481565b606554600080808311610f6b57600080fd5b60008481526067602052604090205433600160a060020a03908116911614610f9257600080fd5b610f9b84611cf6565b91506000821215610fab57600080fd5b600163ffffffff831660648110610fbe57fe5b015490506004610fcc6116f4565b610fd583611d41565b011015610fe157600080fd5b6001830382101561101857606554600190600019016064811061100057fe5b0154600163ffffffff84166064811061101557fe5b01555b60658054600019019055607354600160a060020a031663d7d3c4d58560405160e060020a63ffffffff84160281526004810191909152602401600060405180830381600087803b151561106a57600080fd5b6102c65a03f1151561107b57600080fd5b50505033600160a060020a03166108fc611097610839846115b8565b9081150290604051600060405180830381858888f1935050505015156110bc57600080fd5b7fac16c1eed76505aa9d2f8db9df61e1e000d6c24f2c82b9d5ca3b1cbbc63b51018433604051918252600160a060020a031660208201526040908101905180910390a150505050565b6000805460a060020a900460ff161561111d57600080fd5b60735433600160a060020a0390811691161461113857600080fd5b600160a060020a038316151561114d57600080fd5b43606c5411806111605750611160611d69565b151561116b57600080fd5b81151561117757600080fd5b600160a060020a0383166000908152606660205260409020541561119a57600080fd5b606554606490106111aa57600080fd5b6111b6610839836115b8565b905034819010156111c657600080fd5b610ae4838383611d7e565b606d5481565b6101155481565b60666020526000908152604090205481565b6000600260a06109f9565b60005433600160a060020a0390811691161461121657600080fd5b60005460a860020a900460ff16151561122e57600080fd5b6000805475ff000000000000000000000000000000000000000000191681557f84f9bd54c70699971e701e07b4b61fc6c355ffbdfae18535c911b06a0adcf87390604051901515815260200160405180910390a1565b60005460a860020a900460ff1681565b60005433600160a060020a039081169116146112af57600080fd5b60005460a860020a900460ff16156112c657600080fd5b6000805475ff000000000000000000000000000000000000000000191660a860020a1790557f84f9bd54c70699971e701e07b4b61fc6c355ffbdfae18535c911b06a0adcf8736001604051901515815260200160405180910390a1565b606490565b60005433600160a060020a0390811691161461134357600080fd5b600160a060020a03811615610c4b5760008054600160a060020a03831673ffffffffffffffffffffffffffffffffffffffff1990911617905550565b60655481565b600190565b6000805460a860020a900460ff16156113a257600080fd5b60735433600160a060020a039081169116146113bd57600080fd5b600160a060020a03841615156113d257600080fd5b606b5415806113e357506000607154115b15156113ee57600080fd5b6113f66109e2565b9050348190101561140657600080fd5b600160a060020a0384166000908152606660205260409020541561142957600080fd5b6005821461143657600080fd5b61143e6111f0565b606e541061144b57600080fd5b611453610ae9565b43101561145f57600080fd5b60705443111561146e57600080fd5b6114a78484848080602002602001604051908101604052809392919081815260200183836020028082843750889450611e549350505050565b50505050565b6114b56138da565b60006114bf6138da565b83915060008080846040518059106114d45750595b908082528060200260200182016040525093506114ef6116f4565b9150600090505b8481101561157f5761152588888381811061150d57fe5b9050602002013563ffffffff1663ffffffff16611cf6565b92506000831215611537576000611557565b81611555600163ffffffff86166064811061154e57fe5b0154611d41565b015b84828151811061156357fe5b63ffffffff9092166020928302909101909101526001016114f6565b50919695505050505050565b600068056bc75e2d631000006c0c9f2c9cd04674edea40000000835b068115156115b157fe5b0492915050565b6000620f42406305f5e100836115a7565b606b540290565b600080600160a060020a03841683156108fc0284604051600060405180830381858888f193505050509050801580156116095750600083115b1561167b57600160a060020a038416600090815260666020526040908190208054850190557fd9ca6e9100bce633810823c6c2f61e378ef9c8cdfdd9c76cd65627221bebae4e908590859051600160a060020a03909216825260208201526040908101905180910390a1829150611680565b600091505b5092915050565b61168f6138da565b6065546000816040518059106116a25750595b90808252806020026020018201604052509250600090505b818110156116ef57600181606481106116cf57fe5b01548382815181106116dd57fe5b602090810290910101526001016116ba565b505090565b60008043905080606c5411610b1157606854606c54610384919083030204600101610b14565b600080600080600080895195508515156117375760009550611841565b6117468a600060018903611f56565b60009150600093505b8584101561183d5789848151811061176357fe5b90602001906020020151945061177885612083565b925061178f8861178787611d41565b018a896120b3565b905081841180156117c657506117c6836117c08c60018803815181106117b157fe5b90602001906020020151612083565b836120d2565b156117e9576117de8a836001870385600101886120ea565b600282019150611832565b858460010110801561180c575061180c836117c08c87600101815181106117b157fe5b15611832576118248a838685600101886001016120ea565b600190930192600291909101905b60019093019261174f565b8195505b5050505050949350505050565b60008061185e8484606c546121aa565b6118688484612295565b4360685461038481151561187857fe5b0401606c55611885612313565b61188f8484612379565b607354909150600160a060020a031663dfba3be185856040518363ffffffff1660e060020a0281526004018080602001838152602001828103825284818151815260200191508051906020019060200280838360005b838110156118fd5780820151838201526020016118e5565b505050509050019350505050600060405180830381600087803b151561192257600080fd5b6102c65a03f1151561193357600080fd5b5050507f509fa41742f7ecc729c95f067e92bb34c2c2a8762ca2b82cbaaa69b47b3f97578461196186612516565b85604051808060200180602001848152602001838103835286818151815260200191508051906020019060200280838360005b838110156119ac578082015183820152602001611994565b50505050905001838103825285818151815260200191508051906020019060200280838360005b838110156119eb5780820151838201526020016119d3565b505050509050019550505050505060405180910390a17f9a6ed90ac7336988045822a7b73c3b1d3570646a0837176eb0a8c3b61de8eb73606c5460405190815260200160405180910390a19392505050565b6000611a4983836115d0565b90506000811115610ae457606d805482019055505050565b600080611a6e84846125ba565b9050611a8081610e7083606a54611c9c565b949350505050565b6000600a826115b1565b6000611a9c6138da565b611aa46138da565b600080611aaf6125ed565b9350611ac08460016070540361265b565b9250611acb846128e6565b607354600160a060020a03166311196cc2856040518263ffffffff1660e060020a0281526004018080602001828103825283818151815260200191508051906020019060200280838360005b83811015611b2f578082015183820152602001611b17565b5050505090500192505050600060405180830381600087803b1515611b5357600080fd5b6102c65a03f11515611b6457600080fd5b50506000606e5550611b74612313565b6071805460009091559150611b8a82858561292a565b60728054607155600090559050611ba084612a4d565b7f733715aec32b2c4ecd8945862c2c46cdc069409a28cc15fe0006b1f28624e4fd848484604051808060200180602001848152602001838103835286818151815260200191508051906020019060200280838360005b83811015611c0e578082015183820152602001611bf6565b50505050905001838103825285818151815260200191508051906020019060200280838360005b83811015611c4d578082015183820152602001611c35565b505050509050019550505050505060405180910390a1949350505050565b6000816402540be4000a826001016402540be4000a84811515611c8a57fe5b06811515611c9457fe5b049392505050565b6000612710828402046702c68af0bb140000811115611ccf5783686c6b935b8bbd400000811515611cc957fe5b04611cd1565b825b905060008111611ce2576001611a80565b9392505050565b6000612710838302611c94565b606554600090815b81811015611d345783611d1e60018360648110611d1757fe5b015461158b565b1415611d2c57809250611d3a565b600101611cfe565b60001992505b5050919050565b60006c0c9f2c9cd04674edea40000000701d6329f1c35ca4bfabb9f5610000000000836115a7565b600080611d77610a55611687565b1592915050565b611d86612aac565b611d91826000612bc7565b606580546001818101909255919350839160648110611dac57fe5b01558260676000611dbc8561158b565b815260200190815260200160002060006101000a815481600160a060020a030219169083600160a060020a031602179055507fc2b2fad32d91531c90e8056ef63f1d434747dedea07141b9f55d40f49109dedb83611e198461158b565b836040518084600160a060020a0316600160a060020a03168152602001838152602001828152602001935050505060405180910390a1505050565b607180548201905560008080611e6985612c09565b9250611e7485612c4e565b606e8054600180820190925591935060029091029081019150839060749060a08110611e9c57fe5b01556001810190829060749060a08110611eb257fe5b01558560676000611ec38682611c6b565b815260200190815260200160002060006101000a815481600160a060020a030219169083600160a060020a031602179055507fb9d4cfdb0dd36bcac96d1125d536c92360ef0b6b8f2e7912505cd3c5d213a3068684866040518084600160a060020a0316600160a060020a03168152602001838152602001828152602001935050505060405180910390a1505050505050565b8181600081831415611f675761207b565b85600286860305860181518110611f7a57fe5b9060200190602002015190505b818313612055575b80868481518110611f9c57fe5b906020019060200201511015611fb757600190920191611f8f565b858281518110611fc357fe5b90602001906020020151811015611fe05760001990910190611fb7565b81831361205057858281518110611ff357fe5b9060200190602002015186848151811061200957fe5b9060200190602002015187858151811061201f57fe5b90602001906020020188858151811061203457fe5b6020908102909101019190915252600190920191600019909101905b611f87565b8185121561206857612068868684611f56565b8383121561207b5761207b868486611f56565b505050505050565b6000701d6329f1c35ca4bfabb9f561000000000074446c3b15f9926687d2c40534fdb564000000000000836115a7565b6000818385028115156120c257fe5b0460190260320190509392505050565b60008183018413158015611a80575050900390121590565b60008585815181106120f857fe5b90602001906020020151905085848151811061211057fe5b9060200190602002015186868151811061212657fe5b602090810290910101528086858151811061213d57fe5b6020908102909101015285838151811061215357fe5b90602001906020020151905085828151811061216b57fe5b9060200190602002015186848151811061218157fe5b602090810290910101528086838151811061219857fe5b60209081029091010152505050505050565b60008080805b8581101561228c578315806121c55750604984115b156121f4576121d385612c84565b40836040519182526020820152604090810190519081900390206000945092505b61224a87828151811061220357fe5b9060200190602002015188836001018151811061221c57fe5b90602001906020020151600a87900a6103e881028781151561223a57fe5b0681151561224457fe5b04612ca6565b915060008211801561225c5750600382105b151561226757600080fd5b600190930192600282141561228457612284878283600101612d5c565b6002016121b0565b50505050505050565b6000806000808486510393506122a96116f4565b9150600090505b8363ffffffff168110156123035785818601815181106122cc57fe5b9060200190602002015192506122ec83836122e686611d41565b01612bc7565b600182606481106122f957fe5b01556001016122b0565b50505063ffffffff166065555050565b606e5415801561232557504360705411155b156123775760685443906201518081151561233c57fe5b040160708190557fcb15847438c34cb62896ab708e638b62e7e6a08197569fe6e150eaaeb1d4aa469060405190815260200160405180910390a15b565b60008080808080808061238c8a8a6125ba565b935061239a84606a54611c9c565b92506123a583612dbf565b9150600090505b8881101561243f578981815181106123c057fe5b9060200190602002015195506123f06108398b83600101815181106123e157fe5b906020019060200201516115b8565b6123fc610839886115b8565b0196506124336067600061240f8961158b565b8152602081019190915260400160002054600160a060020a031661083e8985611ce9565b909401936002016123ac565b6073546124af90600160a060020a031663565a2e2c6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561248b57600080fd5b6102c65a03f1151561249c57600080fd5b5050506040518051905061083e86612dce565b8501945060008511156124c557606d8054860190555b436124ce610ae9565b11156124eb576124dd84612ddf565b6071805490910190556124fe565b6124f484612ddf565b6072805490910190555b6125088484611ce9565b9a9950505050505050505050565b61251e6138da565b60008083519150816040518059106125335750595b90808252806020026020018201604052509250600090505b81811015611d3a576067600061257586848151811061256657fe5b9060200190602002015161158b565b8152602081019190915260400160002054600160a060020a031683828151811061259b57fe5b600160a060020a0390921660209283029091019091015260010161254b565b600080805b838110156125e5576125d96108398683815181106123e157fe5b909101906001016125bf565b509392505050565b6125f56138da565b606e546000816040518059106126085750595b90808252806020026020018201604052509250600090505b818110156116ef5760746001600283020160a0811061263b57fe5b015483828151811061264957fe5b60209081029091010152600101612620565b6126636138da565b6000806000806000806000808a519750876040518059106126815750595b9080825280602002602001820160405250985060009250600091505b87821015612874576126c38b83815181106126b457fe5b90602001906020020151612df0565b90975095505b6103e88983815181106126d857fe5b9060200190602002015163ffffffff161015612869578215806126fb5750604983115b1561272e5761270b828b03612c84565b404288016040519182526020820152604090810190519081900390209450600092505b6127598883600101106127415782612746565b826001015b898786600a0a6103e80287600a0a612e3e565b93506127b087878d858151811061276c57fe5b906020019060200201518e888151811061278257fe5b90602001906020020151600a88900a6103e881028b8115156127a057fe5b068115156127aa57fe5b04612e72565b9050606589826001146127c357856127c5565b835b815181106127cf57fe5b9060200190602002018181510163ffffffff16905250606489600183146127f657836127f8565b855b8151811061280257fe5b9060200190602002018181510163ffffffff169052506103e889858151811061282757fe5b9060200190602002015163ffffffff161061285e5760018803841015612856576128568b8a8660018c03612edd565b600019909701965b6001909201916126c9565b60019091019061269d565b8a519750600091505b878210156128d857606489838151811061289357fe5b9060200190602002015163ffffffff168115156128ac57fe5b068983815181106128b957fe5b63ffffffff90921660209283029091019091015260019091019061287d565b505050505050505092915050565b60008082519150600090505b81811015610ae45760746002820260a0811061290a57fe5b015483828151811061291857fe5b602090810290910101526001016128f2565b60008060008060008060008851955061294286612fb6565b6127100294506129558a61011654611c9c565b935061296084612fc3565b925060009150600090505b858110156129bd576129b189828151811061298257fe5b906020019060200201518b858b858151811061299a57fe5b9060200190602002015163ffffffff160288612fcf565b9091019060010161296b565b607354612a2d90600160a060020a031663565a2e2c6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515612a0957600080fd5b6102c65a03f11515612a1a57600080fd5b5050506040518051905061083e8c613020565b820191506000821115612a4357606d8054830190555b6125088a85611ce9565b60008082519150600090505b81811015610ae45760676000612a74858481518110610dc257fe5b8152602081019190915260400160002054600160a060020a0316838281518110612a9a57fe5b60209081029091010152600101612a59565b606554606c54439060008080848411612b66576000861115612b1557612ad06116f4565b9150600090505b85811015612b155760018160648110612aec57fe5b01549250612afe83836122e686611d41565b60018260648110612b0b57fe5b0155600101612ad7565b84606854610384811515612b2557fe5b0401606c81905593507f9a6ed90ac7336988045822a7b73c3b1d3570646a0837176eb0a8c3b61de8eb738460405190815260200160405180910390a161207b565b606486600101148015612b7c5750600a85018490105b1561207b5760058501606c81905593507f9a6ed90ac7336988045822a7b73c3b1d3570646a0837176eb0a8c3b61de8eb738460405190815260200160405180910390a1505050505050565b6000633b9aca008211612bda5781612be0565b633b9aca005b91506c0c9f2c9cd04674edea4000000080830290612bfd85611d41565b02840301905092915050565b600080808084519150600090505b81811015612c4557612c2e85828151811061256657fe5b6402540be40082900a029290920191600101612c17565b50909392505050565b600080600080600080612c6087613032565b939850919650945092509050612c7985858585856130fd565b979650505050505050565b600043610100808206820390840601818110611ce25761010081039250611d3a565b6000806000806000806000806000612cbd8c613149565b9750612cc88b613149565b9650612cd48c89613174565b9550612ce08b88613174565b94506064612cef8b600161318d565b612cfa8e898c6131ab565b02811515612d0457fe5b0593506064612d148b600a61318d565b612d1f8d888b6131ab565b02811515612d2957fe5b059250612d3a8c878a8e8a8d6132ae565b9092509050612d4c848484848e6132f5565b9c9b505050505050505050505050565b6000838381518110612d6a57fe5b906020019060200201519050838281518110612d8257fe5b90602001906020020151848481518110612d9857fe5b6020908102909101015280848381518110612daf57fe5b6020908102909101015250505050565b606f5460695461271003030390565b6069546000906127109083026115b1565b606f546000906127109083026115b1565b64e8d4a5100069d3c21bcecceda10000008206049173af298d050e4395d69670b12b7f41000000000000789f4f2726179a224501d762422c946590d910000000000000009092069190910490565b600085868603838587811515612e5057fe5b06811515612e5a57fe5b04811515612e6457fe5b060190505b95945050505050565b6000806000806000612e8388612df0565b9094509250612e928884613354565b9150612e9e878a613354565b90506125086064612eb088600161318d565b8c02811515612ebb57fe5b056064612ec989600a61318d565b8702811515612ed457fe5b0584848a6132f5565b6000848381518110612eeb57fe5b906020019060200201519050848281518110612f0357fe5b90602001906020020151858481518110612f1957fe5b6020908102909101015280858381518110612f3057fe5b60209081029091010152838381518110612f4657fe5b9060200190602002015163ffffffff169050838281518110612f6457fe5b90602001906020020151848481518110612f7a57fe5b63ffffffff90921660209283029091019091015280848381518110612f9b57fe5b63ffffffff9092166020928302909101909101525050505050565b60006002600a83026115b1565b61011554612710030390565b600080600080612fe0886000611c6b565b600081815260676020526040902054909350600160a060020a03169150613008878787613380565b905061301482826115d0565b98975050505050505050565b610115546000906127109083026115b1565b6000806000806000806000806000806000806000808e5198506130548f613398565b9094509250600090505b888110156130eb578e818151811061307257fe5b9060200190602002015191506130898285856131ab565b8d019c50613098828585613411565b9450848a136130a757846130a9565b895b99506130b6828585613491565b9f82019f91995097509550868c136130ce57866130d0565b8b5b9b50858b136130df57856130e1565b8a5b9a5060010161305e565b50505050505050505091939590929450565b73af298d050e4395d69670b12b7f4100000000000081026ec097ce7bc90715b34b9f1000000000830269d3c21bcecceda1000000850264e8d4a510008702880101010195945050505050565b600061316e600061316961316461315f86613554565b61356d565b613594565b6135a1565b92915050565b6000611ce26131876000613169866135a8565b836135c3565b60006131a16000600b858560640286612e3e565b6064019392505050565b6000806000806000806000806131c08b6135c9565b96506131ce61315f8c613554565b95506131de600788888d8d6135d6565b620f42406131eb8d61373d565b020194506131fd600888888d8d6135d6565b620f424061320a8d613751565b0201935061321c600388888d8d6135d6565b600485056005870501019250613236600488888d8d6135d6565b60198505620f424001019150613250600988888d8d6135d6565b6002620f424061325f8e613764565b6003020281151561326c57fe5b05019050620f42406305f5e10084840205620f4240016132948361328f8f6115b8565b61377b565b0281151561329e57fe5b059b9a5050505050505050505050565b60008060006132be868686613411565b90506132cc898989846137c5565b92506132d9898989613411565b90506132e7868989846137c5565b915050965096945050505050565b60008464e8d4a51000850281151561330957fe5b0593508564e8d4a51000840281151561331e57fe5b05925082841415613336575060016002820601612e69565b828413613344576002613347565b60015b60ff169695505050505050565b600080600080613363866137e9565b9194509250905061337683838388613830565b9695505050505050565b60008183850281151561338f57fe5b04949350505050565b6000806000806000855192506000945060009350600090505b828110156133fd578581815181106133c557fe5b9060200190602002015191506133de85613169846135a8565b94506133f38461316961316461315f86613554565b93506001016133b1565b61340785856135c3565b9450505050915091565b6000806000806000613422886135c9565b935061343061315f89613554565b9250613440600785858a8a6135d6565b620f424061344d8a61373d565b0201915061345f600885858a8a6135d6565b620f424061346c8a613751565b0201905061347e600585858a8a6135d6565b6002909102909101019695505050505050565b60008060008060008060006134a58a6135c9565b93506134b361315f8b613554565b92506134c3600685858c8c6135d6565b620f42406134d08c6138a4565b020191506134e2600785858c8c6135d6565b620f42406134ef8c61373d565b02019050613501600185858c8c6135d6565b600a60078402058301016305f5e1000196506135208761328f8c6115b8565b9650613530600285858c8c6135d6565b81600a60088502058401010195506003600282020594505050505093509350939050565b6000662386f26fc10000670de0b6b3a7640000836115a7565b6000816103e80a826001016103e80a6d0e2885b04902c576218a2b72bc608115156115a757fe5b600060646103e8836115a7565b60020a1790565b6000670de0b6b3a764000068056bc75e2d63100000836115a7565b81161890565b6000600a612710836115a7565b6000808686141561361057620f42408760640a8860010160640a67dee2bc31128b5a8081151561360257fe5b0681151561360c57fe5b0402015b613619856138b9565b87141561365b576002620f42408860640a8960010160640a67dee2bc31128b5a8081151561364357fe5b0681151561364d57fe5b040281151561365857fe5b05015b613664856138c5565b8714156136a6576002620f42408860640a8960010160640a67dee2bc31128b5a8081151561368e57fe5b0681151561369857fe5b04028115156136a357fe5b05015b6136b3848860ff166138d1565b156136f3576002620f42408860640a8960010160640a67dee2bc31128b5a808115156136db57fe5b068115156136e557fe5b04028115156136f057fe5b05015b613700838860ff166138d1565b1561337657620f42408760640a8860010160640a67dee2bc31128b5a8081151561372657fe5b0681151561373057fe5b0402019695505050505050565b60006402540be40064e8d4a51000836115a7565b60006305f5e1006402540be400836115a7565b6000655af3107a4000662386f26fc10000836115a7565b6000600182039150600a8260640a8360010160640a7443ab3b8790243acda5750d30b685bd5fbe5056b0568115156137af57fe5b068115156137b957fe5b048402811515611c9457fe5b6000806000806137d6888888613491565b9194509250905061301483838388613830565b64e8d4a5100081069169d3c21bcecceda10000006ec097ce7bc90715b34b9f1000000000808406919091049273af298d050e4395d69670b12b7f4100000000000090060490565b6000808063047868bf198487031261384a57838603613851565b63047868bf195b91506064808305620f424001620f4240840281151561386c57fe5b0581151561387657fe5b05620f42400390506305f5e1008786020581620f4240890281151561389757fe5b0501979650505050505050565b600064e8d4a51000655af3107a4000836115a7565b6000600a6064836115a7565b60006001600a836115a7565b60020a16151590565b602060405190810160405260008152905600a165627a7a7230582099dac81d836679d8342f2783f1aa770750dcadc0549ce873acaf5c98c9a5f5b70029000000000000000000000000d79b3d20bf9e9d54c4da992fda0b52861fb6757500000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000005dc00000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000007d000000000000000000000000000000000000000000000000000000000000001f4",
  "constructorArguments": "000000000000000000000000d79b3d20bf9e9d54c4da992fda0b52861fb6757500000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000005dc00000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000007d000000000000000000000000000000000000000000000000000000000000001f4"
}