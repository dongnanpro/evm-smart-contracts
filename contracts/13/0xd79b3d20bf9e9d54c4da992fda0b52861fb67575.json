{
  "address": "0xd79b3d20bf9e9d54c4da992fda0b52861fb67575",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "CryptoWarriorCore",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-04-20\n*/\n\npragma solidity ^0.4.19;\n\ncontract ERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n    function getBeneficiary() external view returns(address);\n}\n\ncontract SanctuaryInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isSanctuary() public pure returns (bool);\n\n    /// @dev generate new warrior genes\n    /// @param _heroGenes Genes of warrior that have completed dungeon\n    /// @param _heroLevel Level of the warrior\n    /// @return the genes that are supposed to be passed down to newly arisen warrior\n    function generateWarrior(uint256 _heroGenes, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) public returns (uint256);\n}\n\ncontract PVPInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isPVPProvider() external pure returns (bool);\n    \n    function addTournamentContender(address _owner, uint256[] _tournamentData) external payable;\n    function getTournamentThresholdFee() public view returns(uint256);\n    \n    function addPVPContender(address _owner, uint256 _packedWarrior) external payable;\n    function getPVPEntranceFee(uint256 _levelPoints) external view returns(uint256);\n}\n\ncontract PVPListenerInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isPVPListener() public pure returns (bool);\n    function getBeneficiary() external view returns(address);\n    \n    function pvpFinished(uint256[] warriorData, uint256 matchingCount) public;\n    function pvpContenderRemoved(uint256 _warriorId) public;\n    function tournamentFinished(uint256[] packedContenders) public;\n}\n\ncontract PermissionControll {\n    // This facet controls access to contract that implements it. There are four roles managed here:\n    //\n    // - The Admin: The Admin can reassign admin and issuer roles and change the addresses of our dependent smart\n    // contracts. It is also the only role that can unpause the smart contract. It is initially\n    // set to the address that created the smart contract in the CryptoWarriorCore constructor.\n    //\n    // - The Bank: The Bank can withdraw funds from CryptoWarriorCore and its auction and battle contracts, and change admin role.\n    //\n    // - The Issuer: The Issuer can release gen0 warriors to auction.\n    //\n    // / @dev Emited when contract is upgraded\n    event ContractUpgrade(address newContract);\n    \n    // Set in case the core contract is broken and an upgrade is required\n    address public newContractAddress;\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public adminAddress;\n    address public bankAddress;\n    address public issuerAddress; \n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public paused = false;\n    \n\n    // / @dev Access modifier for Admin-only functionality\n    modifier onlyAdmin(){\n        require(msg.sender == adminAddress);\n        _;\n    }\n\n    // / @dev Access modifier for Bank-only functionality\n    modifier onlyBank(){\n        require(msg.sender == bankAddress);\n        _;\n    }\n    \n    /// @dev Access modifier for Issuer-only functionality\n    modifier onlyIssuer(){\n    \t\trequire(msg.sender == issuerAddress);\n        _;\n    }\n    \n    modifier onlyAuthorized(){\n        require(msg.sender == issuerAddress ||\n            msg.sender == adminAddress ||\n            msg.sender == bankAddress);\n        _;\n    }\n\n\n    // / @dev Assigns a new address to act as the Bank. Only available to the current Bank.\n    // / @param _newBank The address of the new Bank\n    function setBank(address _newBank) external onlyBank {\n        require(_newBank != address(0));\n        bankAddress = _newBank;\n    }\n\n    // / @dev Assigns a new address to act as the Admin. Only available to the current Admin.\n    // / @param _newAdmin The address of the new Admin\n    function setAdmin(address _newAdmin) external {\n        require(msg.sender == adminAddress || msg.sender == bankAddress);\n        require(_newAdmin != address(0));\n        adminAddress = _newAdmin;\n    }\n    \n    // / @dev Assigns a new address to act as the Issuer. Only available to the current Issuer.\n    // / @param _newIssuer The address of the new Issuer\n    function setIssuer(address _newIssuer) external onlyAdmin{\n        require(_newIssuer != address(0));\n        issuerAddress = _newIssuer;\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n    // / @dev Modifier to allow actions only when the contract IS NOT paused\n    modifier whenNotPaused(){\n        require(!paused);\n        _;\n    }\n\n    // / @dev Modifier to allow actions only when the contract IS paused\n    modifier whenPaused{\n        require(paused);\n        _;\n    }\n\n    // / @dev Called by any \"Authorized\" role to pause the contract. Used only when\n    // /  a bug or exploit is detected and we need to limit damage.\n    function pause() external onlyAuthorized whenNotPaused{\n        paused = true;\n    }\n\n    // / @dev Unpauses the smart contract. Can only be called by the Admin.\n    // / @notice This is public rather than external so it can be called by\n    // /  derived contracts.\n    function unpause() public onlyAdmin whenPaused{\n        // can't unpause if contract was upgraded\n        paused = false;\n    }\n    \n    \n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n    ///  breaking bug. This method does nothing but keep track of the new contract and\n    ///  emit a message indicating that the new address is set. It's up to clients of this\n    ///  contract to update to the new contract address in that case. (This contract will\n    ///  be paused indefinitely if such an upgrade takes place.)\n    /// @param _v2Address new address\n    function setNewAddress(address _v2Address) external onlyAdmin whenPaused {\n        newContractAddress = _v2Address;\n        ContractUpgrade(_v2Address);\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function Ownable() public{\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner(){\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner{\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n\ncontract PausableBattle is Ownable {\n    event PausePVP(bool paused);\n    event PauseTournament(bool paused);\n    \n    bool public pvpPaused = false;\n    bool public tournamentPaused = false;\n    \n    /** PVP */\n    modifier PVPNotPaused(){\n        require(!pvpPaused);\n        _;\n    }\n\n    modifier PVPPaused{\n        require(pvpPaused);\n        _;\n    }\n\n    function pausePVP() public onlyOwner PVPNotPaused {\n        pvpPaused = true;\n        PausePVP(true);\n    }\n\n    function unpausePVP() public onlyOwner PVPPaused {\n        pvpPaused = false;\n        PausePVP(false);\n    }\n    \n    /** Tournament */\n    modifier TournamentNotPaused(){\n        require(!tournamentPaused);\n        _;\n    }\n\n    modifier TournamentPaused{\n        require(tournamentPaused);\n        _;\n    }\n\n    function pauseTournament() public onlyOwner TournamentNotPaused {\n        tournamentPaused = true;\n        PauseTournament(true);\n    }\n\n    function unpauseTournament() public onlyOwner TournamentPaused {\n        tournamentPaused = false;\n        PauseTournament(false);\n    }\n    \n}\n\ncontract Pausable is Ownable {\n    event Pause();\n\n    event Unpause();\n\n    bool public paused = false;\n\n    /**\n     * @dev modifier to allow actions only when the contract IS paused\n     */\n    modifier whenNotPaused(){\n        require(!paused);\n        _;\n    }\n\n    /**\n     * @dev modifier to allow actions only when the contract IS NOT paused\n     */\n    modifier whenPaused{\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        Unpause();\n    }\n}\n\nlibrary CryptoUtils {\n   \n    /* CLASSES */\n    uint256 internal constant WARRIOR = 0;\n    uint256 internal constant ARCHER = 1;\n    uint256 internal constant MAGE = 2;\n    /* RARITIES */\n    uint256 internal constant COMMON = 1;\n    uint256 internal constant UNCOMMON = 2;\n    uint256 internal constant RARE = 3;\n    uint256 internal constant MYTHIC = 4;\n    uint256 internal constant LEGENDARY = 5;\n    uint256 internal constant UNIQUE = 6;\n    /* LIMITS */\n    uint256 internal constant CLASS_MECHANICS_MAX = 3;\n    uint256 internal constant RARITY_MAX = 6;\n    /*@dev range used for rarity chance computation */\n    uint256 internal constant RARITY_CHANCE_RANGE = 10000000;\n    uint256 internal constant POINTS_TO_LEVEL = 10;\n    /* ATTRIBUTE MASKS */\n    /*@dev range 0-9999 */\n    uint256 internal constant UNIQUE_MASK_0 = 1;\n    /*@dev range 0-9 */\n    uint256 internal constant RARITY_MASK_1 = UNIQUE_MASK_0 * 10000;\n    /*@dev range 0-999 */\n    uint256 internal constant CLASS_VIEW_MASK_2 = RARITY_MASK_1 * 10;\n    /*@dev range 0-999 */\n    uint256 internal constant BODY_COLOR_MASK_3 = CLASS_VIEW_MASK_2 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant EYES_MASK_4 = BODY_COLOR_MASK_3 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant MOUTH_MASK_5 = EYES_MASK_4 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant HEIR_MASK_6 = MOUTH_MASK_5 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant HEIR_COLOR_MASK_7 = HEIR_MASK_6 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant ARMOR_MASK_8 = HEIR_COLOR_MASK_7 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant WEAPON_MASK_9 = ARMOR_MASK_8 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant HAT_MASK_10 = WEAPON_MASK_9 * 1000;\n    /*@dev range 0-99 */\n    uint256 internal constant RUNES_MASK_11 = HAT_MASK_10 * 1000;\n    /*@dev range 0-99 */\n    uint256 internal constant WINGS_MASK_12 = RUNES_MASK_11 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant PET_MASK_13 = WINGS_MASK_12 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant BORDER_MASK_14 = PET_MASK_13 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant BACKGROUND_MASK_15 = BORDER_MASK_14 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant INTELLIGENCE_MASK_16 = BACKGROUND_MASK_15 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant AGILITY_MASK_17 = INTELLIGENCE_MASK_16 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant STRENGTH_MASK_18 = AGILITY_MASK_17 * 100;\n    /*@dev range 0-9 */\n    uint256 internal constant CLASS_MECH_MASK_19 = STRENGTH_MASK_18 * 100;\n    /*@dev range 0-999 */\n    uint256 internal constant RARITY_BONUS_MASK_20 = CLASS_MECH_MASK_19 * 10;\n    /*@dev range 0-9 */\n    uint256 internal constant SPECIALITY_MASK_21 = RARITY_BONUS_MASK_20 * 1000;\n    /*@dev range 0-99 */\n    uint256 internal constant DAMAGE_MASK_22 = SPECIALITY_MASK_21 * 10;\n    /*@dev range 0-99 */\n    uint256 internal constant AURA_MASK_23 = DAMAGE_MASK_22 * 100;\n    /*@dev 20 decimals left */\n    uint256 internal constant BASE_MASK_24 = AURA_MASK_23 * 100;\n    \n    \n    /* SPECIAL PERKS */\n    uint256 internal constant MINER_PERK = 1;\n    \n    \n    /* PARAM INDEXES */\n    uint256 internal constant BODY_COLOR_MAX_INDEX_0 = 0;\n    uint256 internal constant EYES_MAX_INDEX_1 = 1;\n    uint256 internal constant MOUTH_MAX_2 = 2;\n    uint256 internal constant HAIR_MAX_3 = 3;\n    uint256 internal constant HEIR_COLOR_MAX_4 = 4;\n    uint256 internal constant ARMOR_MAX_5 = 5;\n    uint256 internal constant WEAPON_MAX_6 = 6;\n    uint256 internal constant HAT_MAX_7 = 7;\n    uint256 internal constant RUNES_MAX_8 = 8;\n    uint256 internal constant WINGS_MAX_9 = 9;\n    uint256 internal constant PET_MAX_10 = 10;\n    uint256 internal constant BORDER_MAX_11 = 11;\n    uint256 internal constant BACKGROUND_MAX_12 = 12;\n    uint256 internal constant UNIQUE_INDEX_13 = 13;\n    uint256 internal constant LEGENDARY_INDEX_14 = 14;\n    uint256 internal constant MYTHIC_INDEX_15 = 15;\n    uint256 internal constant RARE_INDEX_16 = 16;\n    uint256 internal constant UNCOMMON_INDEX_17 = 17;\n    uint256 internal constant UNIQUE_TOTAL_INDEX_18 = 18;\n    \n     /* PACK PVP DATA LOGIC */\n    //pvp data\n    uint256 internal constant CLASS_PACK_0 = 1;\n    uint256 internal constant RARITY_BONUS_PACK_1 = CLASS_PACK_0 * 10;\n    uint256 internal constant RARITY_PACK_2 = RARITY_BONUS_PACK_1 * 1000;\n    uint256 internal constant EXPERIENCE_PACK_3 = RARITY_PACK_2 * 10;\n    uint256 internal constant INTELLIGENCE_PACK_4 = EXPERIENCE_PACK_3 * 1000;\n    uint256 internal constant AGILITY_PACK_5 = INTELLIGENCE_PACK_4 * 100;\n    uint256 internal constant STRENGTH_PACK_6 = AGILITY_PACK_5 * 100;\n    uint256 internal constant BASE_DAMAGE_PACK_7 = STRENGTH_PACK_6 * 100;\n    uint256 internal constant PET_PACK_8 = BASE_DAMAGE_PACK_7 * 100;\n    uint256 internal constant AURA_PACK_9 = PET_PACK_8 * 100;\n    uint256 internal constant WARRIOR_ID_PACK_10 = AURA_PACK_9 * 100;\n    uint256 internal constant PVP_CYCLE_PACK_11 = WARRIOR_ID_PACK_10 * 10**10;\n    uint256 internal constant RATING_PACK_12 = PVP_CYCLE_PACK_11 * 10**10;\n    uint256 internal constant PVP_BASE_PACK_13 = RATING_PACK_12 * 10**10;//NB rating must be at the END!\n    \n    //tournament data\n    uint256 internal constant HP_PACK_0 = 1;\n    uint256 internal constant DAMAGE_PACK_1 = HP_PACK_0 * 10**12;\n    uint256 internal constant ARMOR_PACK_2 = DAMAGE_PACK_1 * 10**12;\n    uint256 internal constant DODGE_PACK_3 = ARMOR_PACK_2 * 10**12;\n    uint256 internal constant PENETRATION_PACK_4 = DODGE_PACK_3 * 10**12;\n    uint256 internal constant COMBINE_BASE_PACK_5 = PENETRATION_PACK_4 * 10**12;\n    \n    /* MISC CONSTANTS */\n    uint256 internal constant MAX_ID_SIZE = 10000000000;\n    int256 internal constant PRECISION = 1000000;\n    \n    uint256 internal constant BATTLES_PER_CONTENDER = 10;//10x100\n    uint256 internal constant BATTLES_PER_CONTENDER_SUM = BATTLES_PER_CONTENDER * 100;//10x100\n    \n    uint256 internal constant LEVEL_BONUSES = 98898174676155504541373431282523211917151413121110;\n    \n    //ucommon bonuses\n    uint256 internal constant BONUS_NONE = 0;\n    uint256 internal constant BONUS_HP = 1;\n    uint256 internal constant BONUS_ARMOR = 2;\n    uint256 internal constant BONUS_CRIT_CHANCE = 3;\n    uint256 internal constant BONUS_CRIT_MULT = 4;\n    uint256 internal constant BONUS_PENETRATION = 5;\n    //rare bonuses\n    uint256 internal constant BONUS_STR = 6;\n    uint256 internal constant BONUS_AGI = 7;\n    uint256 internal constant BONUS_INT = 8;\n    uint256 internal constant BONUS_DAMAGE = 9;\n    \n    //bonus value database, \n    uint256 internal constant BONUS_DATA = 16060606140107152000;\n    //pets database\n    uint256 internal constant PETS_DATA = 287164235573728325842459981692000;\n    \n    uint256 internal constant PET_AURA = 2;\n    uint256 internal constant PET_PARAM_1 = 1;\n    uint256 internal constant PET_PARAM_2 = 0;\n\n    /* GETTERS */\n\tfunction getUniqueValue(uint256 identity) internal pure returns(uint256){\n\t\treturn identity % RARITY_MASK_1;\n\t}\n\n    function getRarityValue(uint256 identity) internal pure returns(uint256){\n        return (identity % CLASS_VIEW_MASK_2) / RARITY_MASK_1;\n    }\n\n\tfunction getClassViewValue(uint256 identity) internal pure returns(uint256){\n\t\treturn (identity % BODY_COLOR_MASK_3) / CLASS_VIEW_MASK_2;\n\t}\n\n\tfunction getBodyColorValue(uint256 identity) internal pure returns(uint256){\n        return (identity % EYES_MASK_4) / BODY_COLOR_MASK_3;\n    }\n\n    function getEyesValue(uint256 identity) internal pure returns(uint256){\n        return (identity % MOUTH_MASK_5) / EYES_MASK_4;\n    }\n\n    function getMouthValue(uint256 identity) internal pure returns(uint256){\n        return (identity % HEIR_MASK_6) / MOUTH_MASK_5;\n    }\n\n    function getHairValue(uint256 identity) internal pure returns(uint256){\n        return (identity % HEIR_COLOR_MASK_7) / HEIR_MASK_6;\n    }\n\n    function getHairColorValue(uint256 identity) internal pure returns(uint256){\n        return (identity % ARMOR_MASK_8) / HEIR_COLOR_MASK_7;\n    }\n\n    function getArmorValue(uint256 identity) internal pure returns(uint256){\n        return (identity % WEAPON_MASK_9) / ARMOR_MASK_8;\n    }\n\n    function getWeaponValue(uint256 identity) internal pure returns(uint256){\n        return (identity % HAT_MASK_10) / WEAPON_MASK_9;\n    }\n\n    function getHatValue(uint256 identity) internal pure returns(uint256){\n        return (identity % RUNES_MASK_11) / HAT_MASK_10;\n    }\n\n    function getRunesValue(uint256 identity) internal pure returns(uint256){\n        return (identity % WINGS_MASK_12) / RUNES_MASK_11;\n    }\n\n    function getWingsValue(uint256 identity) internal pure returns(uint256){\n        return (identity % PET_MASK_13) / WINGS_MASK_12;\n    }\n\n    function getPetValue(uint256 identity) internal pure returns(uint256){\n        return (identity % BORDER_MASK_14) / PET_MASK_13;\n    }\n\n\tfunction getBorderValue(uint256 identity) internal pure returns(uint256){\n\t\treturn (identity % BACKGROUND_MASK_15) / BORDER_MASK_14;\n\t}\n\n\tfunction getBackgroundValue(uint256 identity) internal pure returns(uint256){\n\t\treturn (identity % INTELLIGENCE_MASK_16) / BACKGROUND_MASK_15;\n\t}\n\n    function getIntelligenceValue(uint256 identity) internal pure returns(uint256){\n        return (identity % AGILITY_MASK_17) / INTELLIGENCE_MASK_16;\n    }\n\n    function getAgilityValue(uint256 identity) internal pure returns(uint256){\n        return ((identity % STRENGTH_MASK_18) / AGILITY_MASK_17);\n    }\n\n    function getStrengthValue(uint256 identity) internal pure returns(uint256){\n        return ((identity % CLASS_MECH_MASK_19) / STRENGTH_MASK_18);\n    }\n\n    function getClassMechValue(uint256 identity) internal pure returns(uint256){\n        return (identity % RARITY_BONUS_MASK_20) / CLASS_MECH_MASK_19;\n    }\n\n    function getRarityBonusValue(uint256 identity) internal pure returns(uint256){\n        return (identity % SPECIALITY_MASK_21) / RARITY_BONUS_MASK_20;\n    }\n\n    function getSpecialityValue(uint256 identity) internal pure returns(uint256){\n        return (identity % DAMAGE_MASK_22) / SPECIALITY_MASK_21;\n    }\n    \n    function getDamageValue(uint256 identity) internal pure returns(uint256){\n        return (identity % AURA_MASK_23) / DAMAGE_MASK_22;\n    }\n\n    function getAuraValue(uint256 identity) internal pure returns(uint256){\n        return ((identity % BASE_MASK_24) / AURA_MASK_23);\n    }\n\n    /* SETTERS */\n    function _setUniqueValue0(uint256 value) internal pure returns(uint256){\n        require(value < RARITY_MASK_1);\n        return value * UNIQUE_MASK_0;\n    }\n\n    function _setRarityValue1(uint256 value) internal pure returns(uint256){\n        require(value < (CLASS_VIEW_MASK_2 / RARITY_MASK_1));\n        return value * RARITY_MASK_1;\n    }\n\n    function _setClassViewValue2(uint256 value) internal pure returns(uint256){\n        require(value < (BODY_COLOR_MASK_3 / CLASS_VIEW_MASK_2));\n        return value * CLASS_VIEW_MASK_2;\n    }\n\n    function _setBodyColorValue3(uint256 value) internal pure returns(uint256){\n        require(value < (EYES_MASK_4 / BODY_COLOR_MASK_3));\n        return value * BODY_COLOR_MASK_3;\n    }\n\n    function _setEyesValue4(uint256 value) internal pure returns(uint256){\n        require(value < (MOUTH_MASK_5 / EYES_MASK_4));\n        return value * EYES_MASK_4;\n    }\n\n    function _setMouthValue5(uint256 value) internal pure returns(uint256){\n        require(value < (HEIR_MASK_6 / MOUTH_MASK_5));\n        return value * MOUTH_MASK_5;\n    }\n\n    function _setHairValue6(uint256 value) internal pure returns(uint256){\n        require(value < (HEIR_COLOR_MASK_7 / HEIR_MASK_6));\n        return value * HEIR_MASK_6;\n    }\n\n    function _setHairColorValue7(uint256 value) internal pure returns(uint256){\n        require(value < (ARMOR_MASK_8 / HEIR_COLOR_MASK_7));\n        return value * HEIR_COLOR_MASK_7;\n    }\n\n    function _setArmorValue8(uint256 value) internal pure returns(uint256){\n        require(value < (WEAPON_MASK_9 / ARMOR_MASK_8));\n        return value * ARMOR_MASK_8;\n    }\n\n    function _setWeaponValue9(uint256 value) internal pure returns(uint256){\n        require(value < (HAT_MASK_10 / WEAPON_MASK_9));\n        return value * WEAPON_MASK_9;\n    }\n\n    function _setHatValue10(uint256 value) internal pure returns(uint256){\n        require(value < (RUNES_MASK_11 / HAT_MASK_10));\n        return value * HAT_MASK_10;\n    }\n\n    function _setRunesValue11(uint256 value) internal pure returns(uint256){\n        require(value < (WINGS_MASK_12 / RUNES_MASK_11));\n        return value * RUNES_MASK_11;\n    }\n\n    function _setWingsValue12(uint256 value) internal pure returns(uint256){\n        require(value < (PET_MASK_13 / WINGS_MASK_12));\n        return value * WINGS_MASK_12;\n    }\n\n    function _setPetValue13(uint256 value) internal pure returns(uint256){\n        require(value < (BORDER_MASK_14 / PET_MASK_13));\n        return value * PET_MASK_13;\n    }\n\n    function _setBorderValue14(uint256 value) internal pure returns(uint256){\n        require(value < (BACKGROUND_MASK_15 / BORDER_MASK_14));\n        return value * BORDER_MASK_14;\n    }\n\n    function _setBackgroundValue15(uint256 value) internal pure returns(uint256){\n        require(value < (INTELLIGENCE_MASK_16 / BACKGROUND_MASK_15));\n        return value * BACKGROUND_MASK_15;\n    }\n\n    function _setIntelligenceValue16(uint256 value) internal pure returns(uint256){\n        require(value < (AGILITY_MASK_17 / INTELLIGENCE_MASK_16));\n        return value * INTELLIGENCE_MASK_16;\n    }\n\n    function _setAgilityValue17(uint256 value) internal pure returns(uint256){\n        require(value < (STRENGTH_MASK_18 / AGILITY_MASK_17));\n        return value * AGILITY_MASK_17;\n    }\n\n    function _setStrengthValue18(uint256 value) internal pure returns(uint256){\n        require(value < (CLASS_MECH_MASK_19 / STRENGTH_MASK_18));\n        return value * STRENGTH_MASK_18;\n    }\n\n    function _setClassMechValue19(uint256 value) internal pure returns(uint256){\n        require(value < (RARITY_BONUS_MASK_20 / CLASS_MECH_MASK_19));\n        return value * CLASS_MECH_MASK_19;\n    }\n\n    function _setRarityBonusValue20(uint256 value) internal pure returns(uint256){\n        require(value < (SPECIALITY_MASK_21 / RARITY_BONUS_MASK_20));\n        return value * RARITY_BONUS_MASK_20;\n    }\n\n    function _setSpecialityValue21(uint256 value) internal pure returns(uint256){\n        require(value < (DAMAGE_MASK_22 / SPECIALITY_MASK_21));\n        return value * SPECIALITY_MASK_21;\n    }\n    \n    function _setDamgeValue22(uint256 value) internal pure returns(uint256){\n        require(value < (AURA_MASK_23 / DAMAGE_MASK_22));\n        return value * DAMAGE_MASK_22;\n    }\n\n    function _setAuraValue23(uint256 value) internal pure returns(uint256){\n        require(value < (BASE_MASK_24 / AURA_MASK_23));\n        return value * AURA_MASK_23;\n    }\n    \n    /* WARRIOR IDENTITY GENERATION */\n    function _computeRunes(uint256 _rarity) internal pure returns (uint256){\n        return _rarity > UNCOMMON ? _rarity - UNCOMMON : 0;// 1 + _random(0, max, hash, WINGS_MASK_12, RUNES_MASK_11) : 0;\n    }\n\n    function _computeWings(uint256 _rarity, uint256 max, uint256 hash) internal pure returns (uint256){\n        return _rarity > RARE ?  1 + _random(0, max, hash, PET_MASK_13, WINGS_MASK_12) : 0;\n    }\n\n    function _computePet(uint256 _rarity, uint256 max, uint256 hash) internal pure returns (uint256){\n        return _rarity > MYTHIC ? 1 + _random(0, max, hash, BORDER_MASK_14, PET_MASK_13) : 0;\n    }\n\n    function _computeBorder(uint256 _rarity) internal pure returns (uint256){\n        return _rarity >= COMMON ? _rarity - 1 : 0;\n    }\n\n    function _computeBackground(uint256 _rarity) internal pure returns (uint256){\n        return _rarity;\n    }\n    \n    function _unpackPetData(uint256 index) internal pure returns(uint256){\n        return (PETS_DATA % (1000 ** (index + 1)) / (1000 ** index));\n    }\n    \n    function _getPetBonus1(uint256 _pet) internal pure returns(uint256) {\n        return (_pet % (10 ** (PET_PARAM_1 + 1)) / (10 ** PET_PARAM_1));\n    }\n    \n    function _getPetBonus2(uint256 _pet) internal pure returns(uint256) {\n        return (_pet % (10 ** (PET_PARAM_2 + 1)) / (10 ** PET_PARAM_2));\n    }\n    \n    function _getPetAura(uint256 _pet) internal pure returns(uint256) {\n        return (_pet % (10 ** (PET_AURA + 1)) / (10 ** PET_AURA));\n    }\n    \n    function _getBattleBonus(uint256 _setBonusIndex, uint256 _currentBonusIndex, uint256 _petData, uint256 _warriorAuras, uint256 _petAuras) internal pure returns(int256) {\n        int256 bonus = 0;\n        if (_setBonusIndex == _currentBonusIndex) {\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION;\n        }\n        //add pet bonuses\n        if (_setBonusIndex == _getPetBonus1(_petData)) {\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\n        }\n        if (_setBonusIndex == _getPetBonus2(_petData)) {\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\n        }\n        //add warrior aura bonuses\n        if (isAuraSet(_warriorAuras, uint8(_setBonusIndex))) {//warriors receive half bonuses from auras\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\n        }\n        //add pet aura bonuses\n        if (isAuraSet(_petAuras, uint8(_setBonusIndex))) {//pets receive full bonues from auras\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION;\n        }\n        return bonus;\n    }\n    \n    function _computeRarityBonus(uint256 _rarity, uint256 hash) internal pure returns (uint256){\n        if (_rarity == UNCOMMON) {\n            return 1 + _random(0, BONUS_PENETRATION, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\n        }\n        if (_rarity == RARE) {\n            return 1 + _random(BONUS_PENETRATION, BONUS_DAMAGE, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\n        }\n        if (_rarity >= MYTHIC) {\n            return 1 + _random(0, BONUS_DAMAGE, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\n        }\n        return BONUS_NONE;\n    }\n\n    function _computeAura(uint256 _rarity, uint256 hash) internal pure returns (uint256){\n        if (_rarity >= MYTHIC) {\n            return 1 + _random(0, BONUS_DAMAGE, hash, BASE_MASK_24, AURA_MASK_23);\n        }\n        return BONUS_NONE;\n    }\n    \n\tfunction _computeRarity(uint256 _reward, uint256 _unique, uint256 _legendary, \n\t    uint256 _mythic, uint256 _rare, uint256 _uncommon) internal pure returns(uint256){\n\t        \n        uint256 range = _unique + _legendary + _mythic + _rare + _uncommon;\n        if (_reward >= range) return COMMON; // common\n        if (_reward >= (range = (range - _uncommon))) return UNCOMMON;\n        if (_reward >= (range = (range - _rare))) return RARE;\n        if (_reward >= (range = (range - _mythic))) return MYTHIC;\n        if (_reward >= (range = (range - _legendary))) return LEGENDARY;\n        if (_reward < range) return UNIQUE;\n        return COMMON;\n    }\n    \n    function _computeUniqueness(uint256 _rarity, uint256 nextUnique) internal pure returns (uint256){\n        return _rarity == UNIQUE ? nextUnique : 0;\n    }\n    \n    /* identity packing */\n    /* @returns bonus value which depends on speciality value,\n     * if speciality == 1 (miner), then bonus value will be equal 4,\n     * otherwise 1\n     */\n    function _getBonus(uint256 identity) internal pure returns(uint256){\n        return getSpecialityValue(identity) == MINER_PERK ? 4 : 1;\n    }\n    \n\n    function _computeAndSetBaseParameters16_18_22(uint256 _hash) internal pure returns (uint256, uint256){\n        uint256 identity = 0;\n\n        uint256 damage = 35 + _random(0, 21, _hash, AURA_MASK_23, DAMAGE_MASK_22);\n        \n        uint256 strength = 45 + _random(0, 26, _hash, CLASS_MECH_MASK_19, STRENGTH_MASK_18);\n        uint256 agility = 15 + (125 - damage - strength);\n        uint256 intelligence = 155 - strength - agility - damage;\n        (strength, agility, intelligence) = _shuffleParams(strength, agility, intelligence, _hash);\n        \n        identity += _setStrengthValue18(strength);\n        identity += _setAgilityValue17(agility);\n\t\tidentity += _setIntelligenceValue16(intelligence);\n\t\tidentity += _setDamgeValue22(damage);\n        \n        uint256 classMech = strength > agility ? (strength > intelligence ? WARRIOR : MAGE) : (agility > intelligence ? ARCHER : MAGE);\n        return (identity, classMech);\n    }\n    \n    function _shuffleParams(uint256 param1, uint256 param2, uint256 param3, uint256 _hash) internal pure returns(uint256, uint256, uint256) {\n        uint256 temp = param1;\n        if (_hash % 2 == 0) {\n            temp = param1;\n            param1 = param2;\n            param2 = temp;\n        }\n        if ((_hash / 10 % 2) == 0) {\n            temp = param2;\n            param2 = param3;\n            param3 = temp;\n        }\n        if ((_hash / 100 % 2) == 0) {\n            temp = param1;\n            param1 = param2;\n            param2 = temp;\n        }\n        return (param1, param2, param3);\n    }\n    \n    \n    /* RANDOM */\n    function _random(uint256 _min, uint256 _max, uint256 _hash, uint256 _reminder, uint256 _devider) internal pure returns (uint256){\n        return ((_hash % _reminder) / _devider) % (_max - _min) + _min;\n    }\n\n    function _random(uint256 _min, uint256 _max, uint256 _hash) internal pure returns (uint256){\n        return _hash % (_max - _min) + _min;\n    }\n\n    function _getTargetBlock(uint256 _targetBlock) internal view returns(uint256){\n        uint256 currentBlock = block.number;\n        uint256 target = currentBlock - (currentBlock % 256) + (_targetBlock % 256);\n        if (target >= currentBlock) {\n            return (target - 256);\n        }\n        return target;\n    }\n    \n    function _getMaxRarityChance() internal pure returns(uint256){\n        return RARITY_CHANCE_RANGE;\n    }\n    \n    function generateWarrior(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 specialPerc, uint32[19] memory params) internal view returns (uint256) {\n        _targetBlock = _getTargetBlock(_targetBlock);\n        \n        uint256 identity;\n        uint256 hash = uint256(keccak256(block.blockhash(_targetBlock), _heroIdentity, block.coinbase, block.difficulty));\n        //0 _heroLevel produces warriors of COMMON rarity\n        uint256 rarityChance = _heroLevel == 0 ? RARITY_CHANCE_RANGE : \n        \t_random(0, RARITY_CHANCE_RANGE, hash) / (_heroLevel * _getBonus(_heroIdentity)); // 0 - 10 000 000\n        uint256 rarity = _computeRarity(rarityChance, \n            params[UNIQUE_INDEX_13],params[LEGENDARY_INDEX_14], params[MYTHIC_INDEX_15], params[RARE_INDEX_16], params[UNCOMMON_INDEX_17]);\n            \n        uint256 classMech;\n        \n        // start\n        (identity, classMech) = _computeAndSetBaseParameters16_18_22(hash);\n        \n        identity += _setUniqueValue0(_computeUniqueness(rarity, params[UNIQUE_TOTAL_INDEX_18] + 1));\n        identity += _setRarityValue1(rarity);\n        identity += _setClassViewValue2(classMech); // 1 to 1 with classMech\n        \n        identity += _setBodyColorValue3(1 + _random(0, params[BODY_COLOR_MAX_INDEX_0], hash, EYES_MASK_4, BODY_COLOR_MASK_3));\n        identity += _setEyesValue4(1 + _random(0, params[EYES_MAX_INDEX_1], hash, MOUTH_MASK_5, EYES_MASK_4));\n        identity += _setMouthValue5(1 + _random(0, params[MOUTH_MAX_2], hash, HEIR_MASK_6, MOUTH_MASK_5));\n        identity += _setHairValue6(1 + _random(0, params[HAIR_MAX_3], hash, HEIR_COLOR_MASK_7, HEIR_MASK_6));\n        identity += _setHairColorValue7(1 + _random(0, params[HEIR_COLOR_MAX_4], hash, ARMOR_MASK_8, HEIR_COLOR_MASK_7));\n        identity += _setArmorValue8(1 + _random(0, params[ARMOR_MAX_5], hash, WEAPON_MASK_9, ARMOR_MASK_8));\n        identity += _setWeaponValue9(1 + _random(0, params[WEAPON_MAX_6], hash, HAT_MASK_10, WEAPON_MASK_9));\n        identity += _setHatValue10(_random(0, params[HAT_MAX_7], hash, RUNES_MASK_11, HAT_MASK_10));//removed +1\n        \n        identity += _setRunesValue11(_computeRunes(rarity));\n        identity += _setWingsValue12(_computeWings(rarity, params[WINGS_MAX_9], hash));\n        identity += _setPetValue13(_computePet(rarity, params[PET_MAX_10], hash));\n        identity += _setBorderValue14(_computeBorder(rarity)); // 1 to 1 with rarity\n        identity += _setBackgroundValue15(_computeBackground(rarity)); // 1 to 1 with rarity\n        \n        identity += _setClassMechValue19(classMech);\n\n        identity += _setRarityBonusValue20(_computeRarityBonus(rarity, hash));\n        identity += _setSpecialityValue21(specialPerc); // currently only miner (1)\n        \n        identity += _setAuraValue23(_computeAura(rarity, hash));\n        // end\n        return identity;\n    }\n    \n\tfunction _changeParameter(uint256 _paramIndex, uint32 _value, uint32[19] storage parameters) internal {\n\t\t//we can change only view parameters, and unique count in max range <= 100\n\t\trequire(_paramIndex >= BODY_COLOR_MAX_INDEX_0 && _paramIndex <= UNIQUE_INDEX_13);\n\t\t//we can NOT set pet, border and background values,\n\t\t//those values have special logic behind them\n\t\trequire(\n\t\t    _paramIndex != RUNES_MAX_8 && \n\t\t    _paramIndex != PET_MAX_10 && \n\t\t    _paramIndex != BORDER_MAX_11 && \n\t\t    _paramIndex != BACKGROUND_MAX_12\n\t\t);\n\t\t//value of bodyColor, eyes, mouth, hair, hairColor, armor, weapon, hat must be < 1000\n\t\trequire(_paramIndex > HAT_MAX_7 || _value < 1000);\n\t\t//value of wings,  must be < 100\n\t\trequire(_paramIndex > BACKGROUND_MAX_12 || _value < 100);\n\t\t//check that max total number of UNIQUE warriors that we can emit is not > 100\n\t\trequire(_paramIndex != UNIQUE_INDEX_13 || (_value + parameters[UNIQUE_TOTAL_INDEX_18]) <= 100);\n\t\t\n\t\tparameters[_paramIndex] = _value;\n    }\n    \n\tfunction _recordWarriorData(uint256 identity, uint32[19] storage parameters) internal {\n        uint256 rarity = getRarityValue(identity);\n        if (rarity == UNCOMMON) { // uncommon\n            parameters[UNCOMMON_INDEX_17]--;\n            return;\n        }\n        if (rarity == RARE) { // rare\n            parameters[RARE_INDEX_16]--;\n            return;\n        }\n        if (rarity == MYTHIC) { // mythic\n            parameters[MYTHIC_INDEX_15]--;\n            return;\n        }\n        if (rarity == LEGENDARY) { // legendary\n            parameters[LEGENDARY_INDEX_14]--;\n            return;\n        }\n        if (rarity == UNIQUE) { // unique\n            parameters[UNIQUE_INDEX_13]--;\n            parameters[UNIQUE_TOTAL_INDEX_18] ++;\n            return;\n        }\n    }\n    \n    function _validateIdentity(uint256 _identity, uint32[19] memory params) internal pure returns(bool){\n        uint256 rarity = getRarityValue(_identity);\n        require(rarity <= UNIQUE);\n        \n        require(\n            rarity <= COMMON ||//common \n            (rarity == UNCOMMON && params[UNCOMMON_INDEX_17] > 0) ||//uncommon\n            (rarity == RARE && params[RARE_INDEX_16] > 0) ||//rare\n            (rarity == MYTHIC && params[MYTHIC_INDEX_15] > 0) ||//mythic\n            (rarity == LEGENDARY && params[LEGENDARY_INDEX_14] > 0) ||//legendary\n            (rarity == UNIQUE && params[UNIQUE_INDEX_13] > 0)//unique\n        );\n        require(rarity != UNIQUE || getUniqueValue(_identity) > params[UNIQUE_TOTAL_INDEX_18]);\n        \n        //check battle parameters\n        require(\n            getStrengthValue(_identity) < 100 &&\n            getAgilityValue(_identity) < 100 &&\n            getIntelligenceValue(_identity) < 100 &&\n            getDamageValue(_identity) <= 55\n        );\n        require(getClassMechValue(_identity) <= MAGE);\n        require(getClassMechValue(_identity) == getClassViewValue(_identity));\n        require(getSpecialityValue(_identity) <= MINER_PERK);\n        require(getRarityBonusValue(_identity) <= BONUS_DAMAGE);\n        require(getAuraValue(_identity) <= BONUS_DAMAGE);\n        \n        //check view\n        require(getBodyColorValue(_identity) <= params[BODY_COLOR_MAX_INDEX_0]);\n        require(getEyesValue(_identity) <= params[EYES_MAX_INDEX_1]);\n        require(getMouthValue(_identity) <= params[MOUTH_MAX_2]);\n        require(getHairValue(_identity) <= params[HAIR_MAX_3]);\n        require(getHairColorValue(_identity) <= params[HEIR_COLOR_MAX_4]);\n        require(getArmorValue(_identity) <= params[ARMOR_MAX_5]);\n        require(getWeaponValue(_identity) <= params[WEAPON_MAX_6]);\n        require(getHatValue(_identity) <= params[HAT_MAX_7]);\n        require(getRunesValue(_identity) <= params[RUNES_MAX_8]);\n        require(getWingsValue(_identity) <= params[WINGS_MAX_9]);\n        require(getPetValue(_identity) <= params[PET_MAX_10]);\n        require(getBorderValue(_identity) <= params[BORDER_MAX_11]);\n        require(getBackgroundValue(_identity) <= params[BACKGROUND_MAX_12]);\n        \n        return true;\n    }\n    \n    /* UNPACK METHODS */\n    //common\n    function _unpackClassValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % RARITY_PACK_2 / CLASS_PACK_0);\n    }\n    \n    function _unpackRarityBonusValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % RARITY_PACK_2 / RARITY_BONUS_PACK_1);\n    }\n    \n    function _unpackRarityValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % EXPERIENCE_PACK_3 / RARITY_PACK_2);\n    }\n    \n    function _unpackExpValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % INTELLIGENCE_PACK_4 / EXPERIENCE_PACK_3);\n    }\n\n    function _unpackLevelValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % INTELLIGENCE_PACK_4) / (EXPERIENCE_PACK_3 * POINTS_TO_LEVEL);\n    }\n    \n    function _unpackIntelligenceValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % AGILITY_PACK_5 / INTELLIGENCE_PACK_4);\n    }\n    \n    function _unpackAgilityValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % STRENGTH_PACK_6 / AGILITY_PACK_5);\n    }\n    \n    function _unpackStrengthValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % BASE_DAMAGE_PACK_7 / STRENGTH_PACK_6);\n    }\n\n    function _unpackBaseDamageValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % PET_PACK_8 / BASE_DAMAGE_PACK_7);\n    }\n    \n    function _unpackPetValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % AURA_PACK_9 / PET_PACK_8);\n    }\n    \n    function _unpackAuraValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % WARRIOR_ID_PACK_10 / AURA_PACK_9);\n    }\n    //\n    //pvp unpack\n    function _unpackIdValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % PVP_CYCLE_PACK_11 / WARRIOR_ID_PACK_10);\n    }\n    \n    function _unpackCycleValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % RATING_PACK_12 / PVP_CYCLE_PACK_11);\n    }\n    \n    function _unpackRatingValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % PVP_BASE_PACK_13 / RATING_PACK_12);\n    }\n    \n    //max cycle skip value cant be more than 1000000000\n    function _changeCycleValue(uint256 packedValue, uint256 newValue) internal pure returns(uint256){\n        newValue = newValue > 1000000000 ? 1000000000 : newValue;\n        return packedValue - (_unpackCycleValue(packedValue) * PVP_CYCLE_PACK_11) + newValue * PVP_CYCLE_PACK_11;\n    }\n    \n    function _packWarriorCommonData(uint256 _identity, uint256 _experience) internal pure returns(uint256){\n        uint256 packedData = 0;\n        packedData += getClassMechValue(_identity) * CLASS_PACK_0;\n        packedData += getRarityBonusValue(_identity) * RARITY_BONUS_PACK_1;\n        packedData += getRarityValue(_identity) * RARITY_PACK_2;\n        packedData += _experience * EXPERIENCE_PACK_3;\n        packedData += getIntelligenceValue(_identity) * INTELLIGENCE_PACK_4;\n        packedData += getAgilityValue(_identity) * AGILITY_PACK_5;\n        packedData += getStrengthValue(_identity) * STRENGTH_PACK_6;\n        packedData += getDamageValue(_identity) * BASE_DAMAGE_PACK_7;\n        packedData += getPetValue(_identity) * PET_PACK_8;\n        \n        return packedData;\n    }\n    \n    function _packWarriorPvpData(uint256 _identity, uint256 _rating, uint256 _pvpCycle, uint256 _warriorId, uint256 _experience) internal pure returns(uint256){\n        uint256 packedData = _packWarriorCommonData(_identity, _experience);\n        packedData += _warriorId * WARRIOR_ID_PACK_10;\n        packedData += _pvpCycle * PVP_CYCLE_PACK_11;\n        //rating MUST have most significant value!\n        packedData += _rating * RATING_PACK_12;\n        return packedData;\n    }\n    \n    /* TOURNAMENT BATTLES */\n    \n    \n    function _packWarriorIds(uint256[] memory packedWarriors) internal pure returns(uint256){\n        uint256 packedIds = 0;\n        uint256 length = packedWarriors.length;\n        for(uint256 i = 0; i < length; i ++) {\n            packedIds += (MAX_ID_SIZE ** i) * _unpackIdValue(packedWarriors[i]);\n        }\n        return packedIds;\n    }\n\n    function _unpackWarriorId(uint256 packedIds, uint256 index) internal pure returns(uint256){\n        return (packedIds % (MAX_ID_SIZE ** (index + 1)) / (MAX_ID_SIZE ** index));\n    }\n    \n    function _packCombinedParams(int256 hp, int256 damage, int256 armor, int256 dodge, int256 penetration) internal pure returns(uint256) {\n        uint256 combinedWarrior = 0;\n        combinedWarrior += uint256(hp) * HP_PACK_0;\n        combinedWarrior += uint256(damage) * DAMAGE_PACK_1;\n        combinedWarrior += uint256(armor) * ARMOR_PACK_2;\n        combinedWarrior += uint256(dodge) * DODGE_PACK_3;\n        combinedWarrior += uint256(penetration) * PENETRATION_PACK_4;\n        return combinedWarrior;\n    }\n    \n    function _unpackProtectionParams(uint256 combinedWarrior) internal pure returns \n    (int256 hp, int256 armor, int256 dodge){\n        hp = int256(combinedWarrior % DAMAGE_PACK_1 / HP_PACK_0);\n        armor = int256(combinedWarrior % DODGE_PACK_3 / ARMOR_PACK_2);\n        dodge = int256(combinedWarrior % PENETRATION_PACK_4 / DODGE_PACK_3);\n    }\n    \n    function _unpackAttackParams(uint256 combinedWarrior) internal pure returns(int256 damage, int256 penetration) {\n        damage = int256(combinedWarrior % ARMOR_PACK_2 / DAMAGE_PACK_1);\n        penetration = int256(combinedWarrior % COMBINE_BASE_PACK_5 / PENETRATION_PACK_4);\n    }\n    \n    function _combineWarriors(uint256[] memory packedWarriors) internal pure returns (uint256) {\n        int256 hp;\n        int256 damage;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\tint256 penetration;\n\t\t\n\t\t(hp, damage, armor, dodge, penetration) = _computeCombinedParams(packedWarriors);\n        return _packCombinedParams(hp, damage, armor, dodge, penetration);\n    }\n    \n    function _computeCombinedParams(uint256[] memory packedWarriors) internal pure returns \n    (int256 totalHp, int256 totalDamage, int256 maxArmor, int256 maxDodge, int256 maxPenetration){\n        uint256 length = packedWarriors.length;\n        \n        int256 hp;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\tint256 penetration;\n\t\t\n\t\tuint256 warriorAuras;\n\t\tuint256 petAuras;\n\t\t(warriorAuras, petAuras) = _getAurasData(packedWarriors);\n\t\t\n\t\tuint256 packedWarrior;\n        for(uint256 i = 0; i < length; i ++) {\n            packedWarrior = packedWarriors[i];\n            \n            totalDamage += getDamage(packedWarrior, warriorAuras, petAuras);\n            \n            penetration = getPenetration(packedWarrior, warriorAuras, petAuras);\n            maxPenetration = maxPenetration > penetration ? maxPenetration : penetration;\n\t\t\t(hp, armor, dodge) = _getProtectionParams(packedWarrior, warriorAuras, petAuras);\n            totalHp += hp;\n            maxArmor = maxArmor > armor ? maxArmor : armor;\n            maxDodge = maxDodge > dodge ? maxDodge : dodge;\n        }\n    }\n    \n    function _getAurasData(uint256[] memory packedWarriors) internal pure returns(uint256 warriorAuras, uint256 petAuras) {\n        uint256 length = packedWarriors.length;\n        \n        warriorAuras = 0;\n        petAuras = 0;\n        \n        uint256 packedWarrior;\n        for(uint256 i = 0; i < length; i ++) {\n            packedWarrior = packedWarriors[i];\n            warriorAuras = enableAura(warriorAuras, (_unpackAuraValue(packedWarrior)));\n            petAuras = enableAura(petAuras, (_getPetAura(_unpackPetData(_unpackPetValue(packedWarrior)))));\n        }\n        warriorAuras = filterWarriorAuras(warriorAuras, petAuras);\n        return (warriorAuras, petAuras);\n    }\n    \n    // Get bit value at position\n    function isAuraSet(uint256 aura, uint256 auraIndex) internal pure returns (bool) {\n        return aura & (uint256(0x01) << auraIndex) != 0;\n    }\n    \n    // Set bit value at position\n    function enableAura(uint256 a, uint256 n) internal pure returns (uint256) {\n        return a | (uint256(0x01) << n);\n    }\n    \n    //switch off warrior auras that are enabled in pets auras, pet aura have priority\n    function filterWarriorAuras(uint256 _warriorAuras, uint256 _petAuras) internal pure returns(uint256) {\n        return (_warriorAuras & _petAuras) ^ _warriorAuras;\n    }\n  \n    function _getTournamentBattles(uint256 _numberOfContenders) internal pure returns(uint256) {\n        return (_numberOfContenders * BATTLES_PER_CONTENDER / 2);\n    }\n    \n    function getTournamentBattleResults(uint256[] memory combinedWarriors, uint256 _targetBlock) internal view returns (uint32[] memory results){\n        uint256 length = combinedWarriors.length;\n        results = new uint32[](length);\n\t\t\n\t\tint256 damage1;\n\t\tint256 penetration1;\n\t\t\n\t\tuint256 hash;\n\t\t\n\t\tuint256 randomIndex;\n\t\tuint256 exp = 0;\n\t\tuint256 i;\n\t\tuint256 result;\n        for(i = 0; i < length; i ++) {\n            (damage1, penetration1) = _unpackAttackParams(combinedWarriors[i]);\n            while(results[i] < BATTLES_PER_CONTENDER_SUM) {\n                //if we just started generate new random source\n                //or regenerate if we used all data from it\n                if (exp == 0 || exp > 73) {\n                    hash = uint256(keccak256(block.blockhash(_getTargetBlock(_targetBlock - i)), uint256(damage1) + now));\n                    exp = 0;\n                }\n                //we do not fight with self if there are other warriors\n                randomIndex = (_random(i + 1 < length ? i + 1 : i, length, hash, 1000 * 10**exp, 10**exp));\n                result = getTournamentBattleResult(damage1, penetration1, combinedWarriors[i],\n                    combinedWarriors[randomIndex], hash % (1000 * 10**exp) / 10**exp);\n                results[result == 1 ? i : randomIndex] += 101;//icrement battle count 100 and +1 win\n                results[result == 1 ? randomIndex : i] += 100;//increment only battle count 100 for loser\n                if (results[randomIndex] >= BATTLES_PER_CONTENDER_SUM) {\n                    if (randomIndex < length - 1) {\n                        _swapValues(combinedWarriors, results, randomIndex, length - 1);\n                    }\n                    length --;\n                }\n                exp++;\n            }\n        }\n        //filter battle count from results\n        length = combinedWarriors.length;\n        for(i = 0; i < length; i ++) {\n            results[i] = results[i] % 100;\n        }\n        \n        return results;\n    }\n    \n    function _swapValues(uint256[] memory combinedWarriors, uint32[] memory results, uint256 id1, uint256 id2) internal pure {\n        uint256 temp = combinedWarriors[id1];\n        combinedWarriors[id1] = combinedWarriors[id2];\n        combinedWarriors[id2] = temp;\n        temp = results[id1];\n        results[id1] = results[id2];\n        results[id2] = uint32(temp);\n    }\n\n    function getTournamentBattleResult(int256 damage1, int256 penetration1, uint256 combinedWarrior1, \n        uint256 combinedWarrior2, uint256 randomSource) internal pure returns (uint256)\n    {\n        int256 damage2;\n\t\tint256 penetration2;\n        \n\t\t(damage2, penetration2) = _unpackAttackParams(combinedWarrior1);\n\n\t\tint256 totalHp1 = getCombinedTotalHP(combinedWarrior1, penetration2);\n\t\tint256 totalHp2 = getCombinedTotalHP(combinedWarrior2, penetration1);\n        \n        return _getBattleResult(damage1 * getBattleRandom(randomSource, 1) / 100, damage2 * getBattleRandom(randomSource, 10) / 100, totalHp1, totalHp2, randomSource);\n    }\n    /* COMMON BATTLE */\n    \n    function _getBattleResult(int256 damage1, int256 damage2, int256 totalHp1, int256 totalHp2, uint256 randomSource)  internal pure returns (uint256){\n\t\ttotalHp1 = (totalHp1 * (PRECISION * PRECISION) / damage2);\n\t\ttotalHp2 = (totalHp2 * (PRECISION * PRECISION) / damage1);\n\t\t//if draw, let the coin decide who wins\n\t\tif (totalHp1 == totalHp2) return randomSource % 2 + 1;\n\t\treturn totalHp1 > totalHp2 ? 1 : 2;       \n    }\n    \n    function getCombinedTotalHP(uint256 combinedData, int256 enemyPenetration) internal pure returns(int256) {\n        int256 hp;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\t(hp, armor, dodge) = _unpackProtectionParams(combinedData);\n        \n        return _getTotalHp(hp, armor, dodge, enemyPenetration);\n    }\n    \n    function getTotalHP(uint256 packedData, uint256 warriorAuras, uint256 petAuras, int256 enemyPenetration) internal pure returns(int256) {\n        int256 hp;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\t(hp, armor, dodge) = _getProtectionParams(packedData, warriorAuras, petAuras);\n        \n        return _getTotalHp(hp, armor, dodge, enemyPenetration);\n    }\n    \n    function _getTotalHp(int256 hp, int256 armor, int256 dodge, int256 enemyPenetration) internal pure returns(int256) {\n        int256 piercingResult = (armor - enemyPenetration) < -(75 * PRECISION) ? -(75 * PRECISION) : (armor - enemyPenetration);\n        int256 mitigation = (PRECISION - piercingResult * PRECISION / (PRECISION + piercingResult / 100) / 100);\n        \n        return (hp * PRECISION / mitigation + (hp * dodge / (100 * PRECISION)));\n    }\n    \n    function _applyLevelBonus(int256 _value, uint256 _level) internal pure returns(int256) {\n        _level -= 1;\n        return int256(uint256(_value) * (LEVEL_BONUSES % (100 ** (_level + 1)) / (100 ** _level)) / 10);\n    }\n    \n    function _getProtectionParams(uint256 packedData, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256 hp, int256 armor, int256 dodge) {\n        uint256 rarityBonus = _unpackRarityBonusValue(packedData);\n        uint256 petData = _unpackPetData(_unpackPetValue(packedData));\n        int256 strength = _unpackStrengthValue(packedData) * PRECISION + _getBattleBonus(BONUS_STR, rarityBonus, petData, warriorAuras, petAuras);\n        int256 agility = _unpackAgilityValue(packedData) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\n        \n        hp = 100 * PRECISION + strength + 7 * strength / 10 + _getBattleBonus(BONUS_HP, rarityBonus, petData, warriorAuras, petAuras);//add bonus hp\n        hp = _applyLevelBonus(hp, _unpackLevelValue(packedData));\n\t\tarmor = (strength + 8 * strength / 10 + agility + _getBattleBonus(BONUS_ARMOR, rarityBonus, petData, warriorAuras, petAuras));//add bonus armor\n\t\tdodge = (2 * agility / 3);\n    }\n    \n    function getDamage(uint256 packedWarrior, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256) {\n        uint256 rarityBonus = _unpackRarityBonusValue(packedWarrior);\n        uint256 petData = _unpackPetData(_unpackPetValue(packedWarrior));\n        int256 agility = _unpackAgilityValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\n        int256 intelligence = _unpackIntelligenceValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_INT, rarityBonus, petData, warriorAuras, petAuras);\n\t\t\n\t\tint256 crit = (agility / 5 + intelligence / 4) + _getBattleBonus(BONUS_CRIT_CHANCE, rarityBonus, petData, warriorAuras, petAuras);\n\t\tint256 critMultiplier = (PRECISION + intelligence / 25) + _getBattleBonus(BONUS_CRIT_MULT, rarityBonus, petData, warriorAuras, petAuras);\n        \n        int256 damage = int256(_unpackBaseDamageValue(packedWarrior) * 3 * PRECISION / 2) + _getBattleBonus(BONUS_DAMAGE, rarityBonus, petData, warriorAuras, petAuras);\n        \n\t\treturn (_applyLevelBonus(damage, _unpackLevelValue(packedWarrior)) * (PRECISION + crit * critMultiplier / (100 * PRECISION))) / PRECISION;\n    }\n\n    function getPenetration(uint256 packedWarrior, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256) {\n        uint256 rarityBonus = _unpackRarityBonusValue(packedWarrior);\n        uint256 petData = _unpackPetData(_unpackPetValue(packedWarrior));\n        int256 agility = _unpackAgilityValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\n        int256 intelligence = _unpackIntelligenceValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_INT, rarityBonus, petData, warriorAuras, petAuras);\n\t\t\n\t\treturn (intelligence * 2 + agility + _getBattleBonus(BONUS_PENETRATION, rarityBonus, petData, warriorAuras, petAuras));\n    }\n    \n    /* BATTLE PVP */\n    \n    //@param randomSource must be >= 1000\n    function getBattleRandom(uint256 randmSource, uint256 _step) internal pure returns(int256){\n        return int256(100 + _random(0, 11, randmSource, 100 * _step, _step));\n    }\n    \n    uint256 internal constant NO_AURA = 0;\n    \n    function getPVPBattleResult(uint256 packedData1, uint256 packedData2, uint256 randmSource) internal pure returns (uint256){\n        uint256 petAura1 = _computePVPPetAura(packedData1);\n        uint256 petAura2 = _computePVPPetAura(packedData2);\n        \n        uint256 warriorAura1 = _computePVPWarriorAura(packedData1, petAura1);\n        uint256 warriorAura2 = _computePVPWarriorAura(packedData2, petAura2);\n        \n\t\tint256 damage1 = getDamage(packedData1, warriorAura1, petAura1) * getBattleRandom(randmSource, 1) / 100;\n        int256 damage2 = getDamage(packedData2, warriorAura2, petAura2) * getBattleRandom(randmSource, 10) / 100;\n\n\t\tint256 totalHp1;\n\t\tint256 totalHp2;\n\t\t(totalHp1, totalHp2) = _computeContendersTotalHp(packedData1, warriorAura1, petAura1, packedData2, warriorAura1, petAura1);\n        \n        return _getBattleResult(damage1, damage2, totalHp1, totalHp2, randmSource);\n    }\n    \n    function _computePVPPetAura(uint256 packedData) internal pure returns(uint256) {\n        return enableAura(NO_AURA, _getPetAura(_unpackPetData(_unpackPetValue(packedData))));\n    }\n    \n    function _computePVPWarriorAura(uint256 packedData, uint256 petAuras) internal pure returns(uint256) {\n        return filterWarriorAuras(enableAura(NO_AURA, _unpackAuraValue(packedData)), petAuras);\n    }\n    \n    function _computeContendersTotalHp(uint256 packedData1, uint256 warriorAura1, uint256 petAura1, uint256 packedData2, uint256 warriorAura2, uint256 petAura2) \n    internal pure returns(int256 totalHp1, int256 totalHp2) {\n\t\tint256 enemyPenetration = getPenetration(packedData2, warriorAura2, petAura2);\n\t\ttotalHp1 = getTotalHP(packedData1, warriorAura1, petAura1, enemyPenetration);\n\t\tenemyPenetration = getPenetration(packedData1, warriorAura1, petAura1);\n\t\ttotalHp2 = getTotalHP(packedData2, warriorAura1, petAura1, enemyPenetration);\n    }\n    \n    function getRatingRange(uint256 _pvpCycle, uint256 _pvpInterval, uint256 _expandInterval) internal pure returns (uint256){\n        return 50 + (_pvpCycle * _pvpInterval / _expandInterval * 25);\n    }\n    \n    function isMatching(int256 evenRating, int256 oddRating, int256 ratingGap) internal pure returns(bool) {\n        return evenRating <= (oddRating + ratingGap) && evenRating >= (oddRating - ratingGap);\n    }\n    \n    function sort(uint256[] memory data) internal pure {\n       quickSort(data, int(0), int(data.length - 1));\n    }\n    \n    function quickSort(uint256[] memory arr, int256 left, int256 right) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if(i==j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) i++;\n            while (pivot < arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\n                i++;\n                j--;\n            }\n        }\n        if (left < j)\n            quickSort(arr, left, j);\n        if (i < right)\n            quickSort(arr, i, right);\n    }\n    \n    function _swapPair(uint256[] memory matchingIds, uint256 id1, uint256 id2, uint256 id3, uint256 id4) internal pure {\n        uint256 temp = matchingIds[id1];\n        matchingIds[id1] = matchingIds[id2];\n        matchingIds[id2] = temp;\n        \n        temp = matchingIds[id3];\n        matchingIds[id3] = matchingIds[id4];\n        matchingIds[id4] = temp;\n    }\n    \n    function _swapValues(uint256[] memory matchingIds, uint256 id1, uint256 id2) internal pure {\n        uint256 temp = matchingIds[id1];\n        matchingIds[id1] = matchingIds[id2];\n        matchingIds[id2] = temp;\n    }\n    \n    function _getMatchingIds(uint256[] memory matchingIds, uint256 _pvpInterval, uint256 _skipCycles, uint256 _expandInterval) \n    internal pure returns(uint256 matchingCount) \n    {\n        matchingCount = matchingIds.length;\n        if (matchingCount == 0) return 0;\n        \n        uint256 warriorId;\n        uint256 index;\n        //sort matching ids\n        quickSort(matchingIds, int256(0), int256(matchingCount - 1));\n        //find pairs\n        int256 rating1;\n        uint256 pairIndex = 0;\n        int256 ratingRange;\n        for(index = 0; index < matchingCount; index++) {\n            //get packed value\n            warriorId = matchingIds[index];\n            //unpack rating 1\n            rating1 = int256(_unpackRatingValue(warriorId));\n            ratingRange = int256(getRatingRange(_unpackCycleValue(warriorId) + _skipCycles, _pvpInterval, _expandInterval));\n            \n            if (index > pairIndex && //check left neighbor\n            isMatching(rating1, int256(_unpackRatingValue(matchingIds[index - 1])), ratingRange)) {\n                //move matched pairs to the left\n                //swap pairs\n                _swapPair(matchingIds, pairIndex, index - 1, pairIndex + 1, index);\n                //mark last pair position\n                pairIndex += 2;\n            } else if (index + 1 < matchingCount && //check right neighbor\n            isMatching(rating1, int256(_unpackRatingValue(matchingIds[index + 1])), ratingRange)) {\n                //move matched pairs to the left\n                //swap pairs\n                _swapPair(matchingIds, pairIndex, index, pairIndex + 1, index + 1);\n                //mark last pair position\n                pairIndex += 2;\n                //skip next iteration\n                index++;\n            }\n        }\n        \n        matchingCount = pairIndex;\n    }\n\n    function _getPVPBattleResults(uint256[] memory matchingIds, uint256 matchingCount, uint256 _targetBlock) internal view {\n        uint256 exp = 0;\n        uint256 hash = 0;\n        uint256 result = 0;\n        for (uint256 even = 0; even < matchingCount; even += 2) {\n            if (exp == 0 || exp > 73) {\n                hash = uint256(keccak256(block.blockhash(_getTargetBlock(_targetBlock)), hash));\n                exp = 0;\n            }\n                \n            //compute battle result 1 = even(left) id won, 2 - odd(right) id won\n            result = getPVPBattleResult(matchingIds[even], matchingIds[even + 1], hash % (1000 * 10**exp) / 10**exp);\n            require(result > 0 && result < 3);\n            exp++;\n            //if odd warrior won, swap his id with even warrior,\n            //otherwise do nothing,\n            //even ids are winning ids! odds suck!\n            if (result == 2) {\n                _swapValues(matchingIds, even, even + 1);\n            }\n        }\n    }\n    \n    function _getLevel(uint256 _levelPoints) internal pure returns(uint256) {\n        return _levelPoints / POINTS_TO_LEVEL;\n    }\n    \n}\n\nlibrary DataTypes {\n     // / @dev The main Warrior struct. Every warrior in CryptoWarriors is represented by a copy\n    // /  of this structure, so great care was taken to ensure that it fits neatly into\n    // /  exactly two 256-bit words. Note that the order of the members in this structure\n    // /  is important because of the byte-packing rules used by Ethereum.\n    // /  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n    struct Warrior{\n        // The Warrior's identity code is packed into these 256-bits\n        uint256 identity;\n        \n        uint64 cooldownEndBlock;\n        /** every warriors starts from 1 lv (10 level points per level) */\n        uint64 level;\n        /** PVP rating, every warrior starts with 100 rating */\n        int64 rating;\n        // 0 - idle\n        uint32 action;\n        /** Set to the index in the levelRequirements array (see CryptoWarriorBase.levelRequirements) that represents\n         *  the current dungeon level requirement for warrior. This starts at zero. */\n        uint32 dungeonIndex;\n    }\n}\n\ncontract CryptoWarriorBase is PermissionControll, PVPListenerInterface {\n\n    /*** EVENTS ***/\n\n    /// @dev The Arise event is fired whenever a new warrior comes into existence. This obviously\n    ///  includes any time a warrior is created through the ariseWarrior method, but it is also called\n    ///  when a new miner warrior is created.\n    event Arise(address owner, uint256 warriorId, uint256 identity);\n\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a warrior\n    ///  ownership is assigned, including dungeon rewards.\n    event Transfer(address from, address to, uint256 tokenId);\n\n    /*** CONSTANTS ***/\n    \n\tuint256 public constant IDLE = 0;\n    uint256 public constant PVE_BATTLE = 1;\n    uint256 public constant PVP_BATTLE = 2;\n    uint256 public constant TOURNAMENT_BATTLE = 3;\n    \n    //max pve dungeon level\n    uint256 public constant MAX_LEVEL = 25;\n    //how many points is needed to get 1 level\n    uint256 public constant POINTS_TO_LEVEL = 10;\n    \n    /// @dev A lookup table contains PVE dungeon level requirements, each time warrior\n    /// completes dungeon, next level requirement is set, until 25lv (250points) is reached.\n    uint32[6] public dungeonRequirements = [\n        uint32(10),\n        uint32(30),\n        uint32(60),\n        uint32(100),\n        uint32(150),\n        uint32(250)\n    ];\n\n    // An approximation of currently how many seconds are in between blocks.\n    uint256 public secondsPerBlock = 15;\n\n    /*** STORAGE ***/\n\n    /// @dev An array containing the Warrior struct for all Warriors in existence. The ID\n    ///  of each warrior is actually an index of this array.\n    DataTypes.Warrior[] warriors;\n\n    /// @dev A mapping from warrior IDs to the address that owns them. All warriors have\n    ///  some valid owner address, even miner warriors are created with a non-zero owner.\n    mapping (uint256 => address) public warriorToOwner;\n\n    // @dev A mapping from owner address to count of tokens that address owns.\n    //  Used internally inside balanceOf() to resolve ownership count.\n    mapping (address => uint256) ownersTokenCount;\n\n    /// @dev A mapping from warrior IDs to an address that has been approved to call\n    ///  transferFrom(). Each Warrior can only have one approved address for transfer\n    ///  at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public warriorToApproved;\n    \n    // Mapping from owner to list of owned token IDs\n    mapping (address => uint256[]) internal ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) internal ownedTokensIndex;\n\n\n    /// @dev The address of the ClockAuction contract that handles sales of warriors. This\n    ///  same contract handles both peer-to-peer sales as well as the miner sales which are\n    ///  initiated every 15 minutes.\n    SaleClockAuction public saleAuction;\n    \n    \n    /// @dev Assigns ownership of a specific warrior to an address.\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n        // When creating new warriors _from is 0x0, but we can't account that address.\n        if (_from != address(0)) {\n            _clearApproval(_tokenId);\n            _removeTokenFrom(_from, _tokenId);\n        }\n        _addTokenTo(_to, _tokenId);\n        \n        // Emit the transfer event.\n        Transfer(_from, _to, _tokenId);\n    }\n    \n    function _addTokenTo(address _to, uint256 _tokenId) internal {\n        // Since the number of warriors is capped to '1 000 000' we can't overflow this\n        ownersTokenCount[_to]++;\n        // transfer ownership\n        warriorToOwner[_tokenId] = _to;\n        \n        uint256 length = ownedTokens[_to].length;\n        ownedTokens[_to].push(_tokenId);\n        ownedTokensIndex[_tokenId] = length;\n    }\n    \n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\n        //\n        ownersTokenCount[_from]--;\n        \n        warriorToOwner[_tokenId] = address(0);\n        \n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\n        uint256 lastTokenIndex = ownedTokens[_from].length - 1;\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n    \n        ownedTokens[_from][tokenIndex] = lastToken;\n        ownedTokens[_from][lastTokenIndex] = 0;\n        \n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n        // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\n        ownedTokens[_from].length--;\n        ownedTokensIndex[_tokenId] = 0;\n        ownedTokensIndex[lastToken] = tokenIndex;\n    }\n    \n    function _clearApproval(uint256 _tokenId) internal {\n        if (warriorToApproved[_tokenId] != address(0)) {\n            // clear any previously approved ownership exchange\n            warriorToApproved[_tokenId] = address(0);\n        }\n    }\n    \n    function _createWarrior(uint256 _identity, address _owner, uint256 _cooldown, uint256 _level, uint256 _rating, uint256 _dungeonIndex)\n        internal\n        returns (uint256) {\n        \t    \n        DataTypes.Warrior memory _warrior = DataTypes.Warrior({\n            identity : _identity,\n            cooldownEndBlock : uint64(_cooldown),\n            level : uint64(_level),//uint64(10),\n            rating : int64(_rating),//int64(100),\n            action : uint32(IDLE),\n            dungeonIndex : uint32(_dungeonIndex)//uint32(0)\n        });\n        uint256 newWarriorId = warriors.push(_warrior) - 1;\n        \n        // let's just be 100% sure we never let this happen.\n        require(newWarriorId == uint256(uint32(newWarriorId)));\n        \n        // emit the arise event\n        Arise(_owner, newWarriorId, _identity);\n        \n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, _owner, newWarriorId);\n\n        return newWarriorId;\n    }\n    \n\n    // Any C-level can fix how many seconds per blocks are currently observed.\n    function setSecondsPerBlock(uint256 secs) external onlyAuthorized {\n        secondsPerBlock = secs;\n    }\n}\n\ncontract WarriorTokenImpl is CryptoWarriorBase, ERC721 {\n\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n    string public constant name = \"CryptoWarriors\";\n    string public constant symbol = \"CW\";\n\n    bytes4 constant InterfaceSignature_ERC165 =\n        bytes4(keccak256('supportsInterface(bytes4)'));\n\n    bytes4 constant InterfaceSignature_ERC721 =\n        bytes4(keccak256('name()')) ^\n        bytes4(keccak256('symbol()')) ^\n        bytes4(keccak256('totalSupply()')) ^\n        bytes4(keccak256('balanceOf(address)')) ^\n        bytes4(keccak256('ownerOf(uint256)')) ^\n        bytes4(keccak256('approve(address,uint256)')) ^\n        bytes4(keccak256('transfer(address,uint256)')) ^\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n        bytes4(keccak256('tokensOfOwner(address)'));\n\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n    ///  ERC-165 (obviously!) and ERC-721.\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n    {\n        // DEBUG ONLY\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9f40b779));\n\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n    }\n\n    // Internal utility functions: These functions all assume that their input arguments\n    // are valid. We leave it to public methods to sanitize their inputs and follow\n    // the required logic.\n\n    /** @dev Checks if a given address is the current owner of the specified Warrior tokenId.\n     * @param _claimant the address we are validating against.\n     * @param _tokenId warrior id\n     */\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return _claimant != address(0) && warriorToOwner[_tokenId] == _claimant;    \n    }\n\n    function _ownerApproved(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return _claimant != address(0) &&//0 address means token is burned \n        warriorToOwner[_tokenId] == _claimant && warriorToApproved[_tokenId] == address(0);    \n    }\n\n    /// @dev Checks if a given address currently has transferApproval for a particular Warrior.\n    /// @param _claimant the address we are confirming warrior is approved for.\n    /// @param _tokenId warrior id\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return warriorToApproved[_tokenId] == _claimant;\n    }\n\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n    ///  _approve() and transferFrom() are used together for putting Warriors on auction, and\n    ///  there is no value in spamming the log with Approval events in that case.\n    function _approve(uint256 _tokenId, address _approved) internal {\n        warriorToApproved[_tokenId] = _approved;\n    }\n\n    /// @notice Returns the number of Warriors(tokens) owned by a specific address.\n    /// @param _owner The owner address to check.\n    /// @dev Required for ERC-721 compliance\n    function balanceOf(address _owner) public view returns (uint256 count) {\n        return ownersTokenCount[_owner];\n    }\n\n    /// @notice Transfers a Warrior to another address. If transferring to a smart\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n    ///  CryptoWarriors specifically) or your Warrior may be lost forever. Seriously.\n    /// @param _to The address of the recipient, can be a user or contract.\n    /// @param _tokenId The ID of the Warrior to transfer.\n    /// @dev Required for ERC-721 compliance.\n    function transfer(address _to, uint256 _tokenId) external whenNotPaused {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any warriors (except very briefly\n        // after a miner warrior is created and before it goes on auction).\n        require(_to != address(this));\n        // Disallow transfers to the auction contracts to prevent accidental\n        // misuse. Auction contracts should only take ownership of warriors\n        // through the allow + transferFrom flow.\n        require(_to != address(saleAuction));\n        // You can only send your own warrior.\n        require(_owns(msg.sender, _tokenId));\n        // Only idle warriors are allowed \n        require(warriors[_tokenId].action == IDLE);\n\n        // Reassign ownership, clear pending approvals, emit Transfer event.\n        _transfer(msg.sender, _to, _tokenId);\n    }\n    \n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\n        require(_index < balanceOf(_owner));\n        return ownedTokens[_owner][_index];\n    }\n\n    /// @notice Grant another address the right to transfer a specific Warrior via\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\n    ///  clear all approvals.\n    /// @param _tokenId The ID of the Warrior that can be transferred if this call succeeds.\n    /// @dev Required for ERC-721 compliance.\n    function approve(address _to, uint256 _tokenId) external whenNotPaused {\n        // Only an owner can grant transfer approval.\n        require(_owns(msg.sender, _tokenId));\n        // Only idle warriors are allowed \n        require(warriors[_tokenId].action == IDLE);\n\n        // Register the approval (replacing any previous approval).\n        _approve(_tokenId, _to);\n\n        // Emit approval event.\n        Approval(msg.sender, _to, _tokenId);\n    }\n\n    /// @notice Transfer a Warrior owned by another address, for which the calling address\n    ///  has previously been granted transfer approval by the owner.\n    /// @param _from The address that owns the Warrior to be transfered.\n    /// @param _to The address that should take ownership of the Warrior. Can be any address,\n    ///  including the caller.\n    /// @param _tokenId The ID of the Warrior to be transferred.\n    /// @dev Required for ERC-721 compliance.\n    function transferFrom(address _from, address _to, uint256 _tokenId)\n        external\n        whenNotPaused\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any warriors (except very briefly\n        // after a miner warrior is created and before it goes on auction).\n        require(_to != address(this));\n        // Check for approval and valid ownership\n        require(_approvedFor(msg.sender, _tokenId));\n        require(_owns(_from, _tokenId));\n        // Only idle warriors are allowed \n        require(warriors[_tokenId].action == IDLE);\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Returns the total number of Warriors currently in existence.\n    /// @dev Required for ERC-721 compliance.\n    function totalSupply() public view returns (uint256) {\n        return warriors.length;\n    }\n\n    /// @notice Returns the address currently assigned ownership of a given Warrior.\n    /// @dev Required for ERC-721 compliance.\n    function ownerOf(uint256 _tokenId)\n        external\n        view\n        returns (address owner)\n    {\n        require(_tokenId < warriors.length);\n        owner = warriorToOwner[_tokenId];\n    }\n\n    /// @notice Returns a list of all Warrior IDs assigned to an address.\n    /// @param _owner The owner whose Warriors we are interested in.\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n        return ownedTokens[_owner];\n    }\n    \n    function tokensOfOwnerFromIndex(address _owner, uint256 _fromIndex, uint256 _count) external view returns(uint256[] memory ownerTokens) {\n        require(_fromIndex < balanceOf(_owner));\n        uint256[] storage tokens = ownedTokens[_owner];\n        //        \n        uint256 ownerBalance = ownersTokenCount[_owner];\n        uint256 lenght = (ownerBalance - _fromIndex >= _count ? _count : ownerBalance - _fromIndex);\n        //\n        ownerTokens = new uint256[](lenght);\n        for(uint256 i = 0; i < lenght; i ++) {\n            ownerTokens[i] = tokens[_fromIndex + i];\n        }\n        \n        return ownerTokens;\n    }\n    \n    /**\n     * @dev Internal function to burn a specific token\n     * @dev Reverts if the token does not exist\n     * @param _owner owner of the token to burn\n     * @param _tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address _owner, uint256 _tokenId) internal {\n        _clearApproval(_tokenId);\n        _removeTokenFrom(_owner, _tokenId);\n        \n        Transfer(_owner, address(0), _tokenId);\n    }\n\n}\n\ncontract CryptoWarriorPVE is WarriorTokenImpl {\n    uint256 internal constant MINER_PERK = 1;\n    uint256 internal constant SUMMONING_SICKENESS = 12;\n    \n    uint256 internal constant PVE_COOLDOWN = 1 hours;\n    uint256 internal constant PVE_DURATION = 15 minutes;\n    \n    \n    /// @notice The payment required to use startPVEBattle().\n    uint256 public pveBattleFee = 10 finney;\n    uint256 public constant PVE_COMPENSATION = 2 finney;\n    \n\t/// @dev The address of the sibling contract that is used to implement warrior generation algorithm.\n    SanctuaryInterface public sanctuary;\n\n    /** @dev PVEStarted event. Emitted every time a warrior enters pve battle\n     *  @param owner Warrior owner\n     *  @param dungeonIndex Started dungeon index \n     *  @param warriorId Warrior ID that started PVE dungeon\n     *  @param battleEndBlock Block number, when started PVE dungeon will be completed\n     */\n    event PVEStarted(address owner, uint256 dungeonIndex, uint256 warriorId, uint256 battleEndBlock);\n\n    /** @dev PVEFinished event. Emitted every time a warrior finishes pve battle\n     *  @param owner Warrior owner\n     *  @param dungeonIndex Finished dungeon index\n     *  @param warriorId Warrior ID that completed dungeon\n     *  @param cooldownEndBlock Block number, when cooldown on PVE battle entrance will be over\n     *  @param rewardId Warrior ID which was granted to the owner as battle reward\n     */\n    event PVEFinished(address owner, uint256 dungeonIndex, uint256 warriorId, uint256 cooldownEndBlock, uint256 rewardId);\n\n\t/// @dev Update the address of the sanctuary contract, can only be called by the Admin.\n    /// @param _address An address of a sanctuary contract instance to be used from this point forward.\n    function setSanctuaryAddress(address _address) external onlyAdmin {\n        SanctuaryInterface candidateContract = SanctuaryInterface(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSanctuary());\n\n        // Set the new contract address\n        sanctuary = candidateContract;\n    }\n    \n    function areUnique(uint256[] memory _warriorIds) internal pure returns(bool) {\n   \t    uint256 length = _warriorIds.length;\n   \t    uint256 j;\n        for(uint256 i = 0; i < length; i++) {\n\t        for(j = i + 1; j < length; j++) {\n\t            if (_warriorIds[i] == _warriorIds[j]) return false;\n\t        }\n        }\n        return true; \n   \t}\n\n    /// @dev Updates the minimum payment required for calling startPVE(). Can only\n    ///  be called by the COO address.\n    function setPVEBattleFee(uint256 _pveBattleFee) external onlyAdmin {\n        require(_pveBattleFee > PVE_COMPENSATION);\n        pveBattleFee = _pveBattleFee;\n    }\n    \n    /** @dev Returns PVE cooldown, after each battle, the warrior receives a \n     *  cooldown on the next entrance to the battle, cooldown depends on current warrior level,\n     *  which is multiplied by 1h. Special case: after receiving 25 lv, the cooldwon will be 14 days.\n     *  @param _levelPoints warrior level */\n    function getPVECooldown(uint256 _levelPoints) public pure returns (uint256) {\n        uint256 level = CryptoUtils._getLevel(_levelPoints);\n        if (level >= MAX_LEVEL) return (14 * 24 * PVE_COOLDOWN);//14 days\n        return (PVE_COOLDOWN * level);\n    }\n\n    /** @dev Returns PVE duration, each battle have a duration, which depends on current warrior level,\n     *  which is multiplied by 15 min. At the end of the duration, warrior is becoming eligible to receive\n     *  battle reward (new warrior in shiny armor)\n     *  @param _levelPoints warrior level points \n     */\n    function getPVEDuration(uint256 _levelPoints) public pure returns (uint256) {\n        return CryptoUtils._getLevel(_levelPoints) * PVE_DURATION;\n    }\n    \n    /// @dev Checks that a given warrior can participate in PVE battle. Requires that the\n    ///  current cooldown is finished and also checks that warrior is idle (does not participate in any action)\n    ///  and dungeon level requirement is satisfied\n    function _isReadyToPVE(DataTypes.Warrior _warrior) internal view returns (bool) {\n        return (_warrior.action == IDLE) && //is idle\n        (_warrior.cooldownEndBlock <= uint64(block.number)) && //no cooldown\n        (_warrior.level >= dungeonRequirements[_warrior.dungeonIndex]);//dungeon level requirement is satisfied\n    }\n    \n    /// @dev Internal utility function to initiate pve battle, assumes that all battle\n    ///  requirements have been checked.\n    function _triggerPVEStart(uint256 _warriorId) internal {\n        // Grab a reference to the warrior from storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        // Set warrior current action to pve battle\n        warrior.action = uint16(PVE_BATTLE);\n        // Set battle duration\n        warrior.cooldownEndBlock = uint64((getPVEDuration(warrior.level) / secondsPerBlock) + block.number);\n        // Emit the pve battle start event.\n        PVEStarted(msg.sender, warrior.dungeonIndex, _warriorId, warrior.cooldownEndBlock);\n    }\n    \n    /// @dev Starts PVE battle for specified warrior, \n    /// after battle, warrior owner will receive reward (Warrior) \n    /// @param _warriorId A Warrior ready to PVE battle.\n    function startPVE(uint256 _warriorId) external payable whenNotPaused {\n\t\t// Checks for payment.\n        require(msg.value >= pveBattleFee);\n\t\t\n\t\t// Caller must own the warrior.\n        require(_ownerApproved(msg.sender, _warriorId));\n\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n\n        // Check that the warrior exists.\n        require(warrior.identity != 0);\n\n        // Check that the warrior is ready to battle\n        require(_isReadyToPVE(warrior));\n        \n        // All checks passed, let the battle begin!\n        _triggerPVEStart(_warriorId);\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 feeExcess = msg.value - pveBattleFee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of _isReadyToPVE check\n        // will fail\n        msg.sender.transfer(feeExcess);\n        //send battle fee to beneficiary\n        bankAddress.transfer(pveBattleFee - PVE_COMPENSATION);\n    }\n    \n    function _ariseWarrior(address _owner, DataTypes.Warrior storage _warrior) internal returns(uint256) {\n        uint256 identity = sanctuary.generateWarrior(_warrior.identity, CryptoUtils._getLevel(_warrior.level), _warrior.cooldownEndBlock - 1, 0);\n        return _createWarrior(identity, _owner, block.number + (PVE_COOLDOWN * SUMMONING_SICKENESS / secondsPerBlock), 10, 100, 0);\n    }\n\n\t/// @dev Internal utility function to finish pve battle, assumes that all battle\n    ///  finish requirements have been checked.\n    function _triggerPVEFinish(uint256 _warriorId) internal {\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        \n        // Set warrior current action to idle\n        warrior.action = uint16(IDLE);\n        \n        // Compute an estimation of the cooldown time in blocks (based on current level).\n        // and miner perc also reduces cooldown time by 4 times\n        warrior.cooldownEndBlock = uint64((getPVECooldown(warrior.level) / \n            CryptoUtils._getBonus(warrior.identity) / secondsPerBlock) + block.number);\n        \n        // cash completed dungeon index before increment\n        uint256 dungeonIndex = warrior.dungeonIndex;\n        // Increment the dungeon index, clamping it at 5, which is the length of the\n        // dungeonRequirements array. We could check the array size dynamically, but hard-coding\n        // this as a constant saves gas.\n        if (dungeonIndex < 5) {\n            warrior.dungeonIndex += 1;\n        }\n        \n        address owner = warriorToOwner[_warriorId];\n        // generate reward\n        uint256 arisenWarriorId = _ariseWarrior(owner, warrior);\n        //Emit event\n        PVEFinished(owner, dungeonIndex, _warriorId, warrior.cooldownEndBlock, arisenWarriorId);\n    }\n    \n    /**\n     * @dev finishPVE can be called after battle time is over,\n     * if checks are passed then battle result is computed,\n     * and new warrior is awarded to owner of specified _warriord ID.\n     * NB anyone can call this method, if they willing to pay the gas price\n     */\n    function finishPVE(uint256 _warriorId) external whenNotPaused {\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        \n        // Check that the warrior exists.\n        require(warrior.identity != 0);\n        \n        // Check that warrior participated in PVE battle action\n        require(warrior.action == PVE_BATTLE);\n        \n        // And the battle time is over\n        require(warrior.cooldownEndBlock <= uint64(block.number));\n        \n        // When the all checks done, calculate actual battle result\n        _triggerPVEFinish(_warriorId);\n        \n        //not susceptible to reetrance attack because of require(warrior.action == PVE_BATTLE)\n        //and require(warrior.cooldownEndBlock <= uint64(block.number));\n        msg.sender.transfer(PVE_COMPENSATION);\n    }\n    \n    /**\n     * @dev finishPVEBatch same as finishPVE but for multiple warrior ids.\n     * NB anyone can call this method, if they willing to pay the gas price\n     */\n    function finishPVEBatch(uint256[] _warriorIds) external whenNotPaused {\n        uint256 length = _warriorIds.length;\n        //check max number of bach finish pve\n        require(length <= 20);\n        uint256 blockNumber = block.number;\n        uint256 index;\n        //all warrior ids must be unique\n        require(areUnique(_warriorIds));\n        //check prerequisites\n        for(index = 0; index < length; index ++) {\n            DataTypes.Warrior storage warrior = warriors[_warriorIds[index]];\n\t\t\trequire(\n\t\t        // Check that the warrior exists.\n\t\t\t    warrior.identity != 0 &&\n\t\t        // Check that warrior participated in PVE battle action\n\t\t\t    warrior.action == PVE_BATTLE &&\n\t\t        // And the battle time is over\n\t\t\t    warrior.cooldownEndBlock <= blockNumber\n\t\t\t);\n        }\n        // When the all checks done, calculate actual battle result\n        for(index = 0; index < length; index ++) {\n            _triggerPVEFinish(_warriorIds[index]);\n        }\n        \n        //not susceptible to reetrance attack because of require(warrior.action == PVE_BATTLE)\n        //and require(warrior.cooldownEndBlock <= uint64(block.number));\n        msg.sender.transfer(PVE_COMPENSATION * length);\n    }\n}\n\ncontract CryptoWarriorSanctuary is CryptoWarriorPVE {\n    \n    uint256 internal constant RARE = 3;\n    \n    function burnWarrior(uint256 _warriorId, address _owner) whenNotPaused external {\n        require(msg.sender == address(sanctuary));\n        \n        // Caller must own the warrior.\n        require(_ownerApproved(_owner, _warriorId));\n\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n\n        // Check that the warrior exists.\n        require(warrior.identity != 0);\n\n        // Check that the warrior is ready to battle\n        require(warrior.action == IDLE);//is idle\n        \n        // Rarity of burned warrior must be less or equal RARE (3)\n        require(CryptoUtils.getRarityValue(warrior.identity) <= RARE);\n        // Warriors with MINER perc are not allowed to be berned\n        require(CryptoUtils.getSpecialityValue(warrior.identity) < MINER_PERK);\n        \n        _burn(_owner, _warriorId);\n    }\n    \n    function ariseWarrior(uint256 _identity, address _owner, uint256 _cooldown) whenNotPaused external returns(uint256){\n        require(msg.sender == address(sanctuary));\n        return _createWarrior(_identity, _owner, _cooldown, 10, 100, 0);\n    }\n    \n}\n\ncontract CryptoWarriorPVP is CryptoWarriorSanctuary {\n\t\n\tPVPInterface public battleProvider;\n\t\n\t/// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function setBattleProviderAddress(address _address) external onlyAdmin {\n        PVPInterface candidateContract = PVPInterface(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isPVPProvider());\n\n        // Set the new contract address\n        battleProvider = candidateContract;\n    }\n    \n    function _packPVPData(uint256 _warriorId, DataTypes.Warrior storage warrior) internal view returns(uint256){\n        return CryptoUtils._packWarriorPvpData(warrior.identity, uint256(warrior.rating), 0, _warriorId, warrior.level);\n    }\n    \n    function _triggerPVPSignUp(uint256 _warriorId, uint256 fee) internal {\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n    \t\t\n\t\tuint256 packedWarrior = _packPVPData(_warriorId, warrior);\n        \n        // addPVPContender will throw if fee fails.\n        battleProvider.addPVPContender.value(fee)(msg.sender, packedWarrior);\n        \n        warrior.action = uint16(PVP_BATTLE);\n    }\n    \n    /*\n     * @title signUpForPVP enqueues specified warrior to PVP\n     * \n     * @dev When the owner enqueues his warrior for PvP, the warrior enters the waiting room.\n     * Once every 15 minutes, we check the warriors in the room and select pairs. \n     * For those warriors to whom we found couples, fighting is conducted and the results \n     * are recorded in the profile of the warrior. \n     */\n    function signUpForPVP(uint256 _warriorId) public payable whenNotPaused {//done\n\t\t// Caller must own the warrior.\n        require(_ownerApproved(msg.sender, _warriorId));\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        // sanity check\n        require(warrior.identity != 0);\n\n        // Check that the warrior is ready to battle\n        require(warrior.action == IDLE);\n        \n        // Define the current price of the auction.\n        uint256 fee = battleProvider.getPVPEntranceFee(warrior.level);\n        \n        // Checks for payment.\n        require(msg.value >= fee);\n        \n        // All checks passed, put the warrior to the queue!\n        _triggerPVPSignUp(_warriorId, fee);\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 feeExcess = msg.value - fee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of warrior.action == IDLE check\n        // will fail\n        msg.sender.transfer(feeExcess);\n    }\n\n    function _grandPVPWinnerReward(uint256 _warriorId) internal {\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        // reward 1 level, add 10 level points\n        uint256 level = warrior.level;\n        if (level < (MAX_LEVEL * POINTS_TO_LEVEL)) {\n            level = level + POINTS_TO_LEVEL;\n\t\t\twarrior.level = uint64(level > (MAX_LEVEL * POINTS_TO_LEVEL) ? (MAX_LEVEL * POINTS_TO_LEVEL) : level);\n        }\n\t\t// give 100 rating for levelUp and 30 for win\n\t\twarrior.rating += 130;\n\t\t// mark warrior idle, so it can participate\n\t\t// in another actions\n\t\twarrior.action = uint16(IDLE);\n    }\n\n    function _grandPVPLoserReward(uint256 _warriorId) internal {\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n\t\t// reward 0.5 level\n\t\tuint256 oldLevel = warrior.level;\n\t\tuint256 level = oldLevel;\n\t\tif (level < (MAX_LEVEL * POINTS_TO_LEVEL)) {\n            level += (POINTS_TO_LEVEL / 2);\n\t\t\twarrior.level = uint64(level);\n        }\n\t\t// give 100 rating for levelUp if happens and -30 for lose\n\t\tint256 newRating = warrior.rating + (CryptoUtils._getLevel(level) > CryptoUtils._getLevel(oldLevel) ? int256(100 - 30) : int256(-30));\n\t\t// rating can't be less than 0 and more than 1000000000\n\t    warrior.rating = int64((newRating >= 0) ? (newRating > 1000000000 ? 1000000000 : newRating) : 0);\n        // mark warrior idle, so it can participate\n\t\t// in another actions\n\t    warrior.action = uint16(IDLE);\n    }\n    \n    function _grandPVPRewards(uint256[] memory warriorsData, uint256 matchingCount) internal {\n        for(uint256 id = 0; id < matchingCount; id += 2){\n            //\n            // winner, even ids are winners!\n            _grandPVPWinnerReward(CryptoUtils._unpackIdValue(warriorsData[id]));\n            //\n            // loser, they are odd...\n            _grandPVPLoserReward(CryptoUtils._unpackIdValue(warriorsData[id + 1]));\n        }\n\t}\n\n    // @dev Internal utility function to initiate pvp battle, assumes that all battle\n    ///  requirements have been checked.\n    function pvpFinished(uint256[] warriorsData, uint256 matchingCount) public {\n        //this method can be invoked only by battleProvider contract\n        require(msg.sender == address(battleProvider));\n        \n        _grandPVPRewards(warriorsData, matchingCount);\n    }\n    \n    function pvpContenderRemoved(uint256 _warriorId) public {\n        //this method can be invoked only by battleProvider contract\n        require(msg.sender == address(battleProvider));\n        //grab warrior storage reference\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        //specified warrior must be in pvp state\n        require(warrior.action == PVP_BATTLE);\n        //all checks done\n        //set warrior state to IDLE\n        warrior.action = uint16(IDLE);\n    }\n}\n\ncontract CryptoWarriorTournament is CryptoWarriorPVP {\n    \n    uint256 internal constant GROUP_SIZE = 5;\n    \n    function _ownsAll(address _claimant, uint256[] memory _warriorIds) internal view returns (bool) {\n        uint256 length = _warriorIds.length;\n        for(uint256 i = 0; i < length; i++) {\n            if (!_ownerApproved(_claimant, _warriorIds[i])) return false;\n        }\n        return true;    \n    }\n    \n    function _isReadyToTournament(DataTypes.Warrior storage _warrior) internal view returns(bool){\n        return _warrior.level >= 50 && _warrior.action == IDLE;//must not participate in any action\n    }\n    \n    function _packTournamentData(uint256[] memory _warriorIds) internal view returns(uint256[] memory tournamentData) {\n        tournamentData = new uint256[](GROUP_SIZE);\n        uint256 warriorId;\n        for(uint256 i = 0; i < GROUP_SIZE; i++) {\n            warriorId = _warriorIds[i];\n            tournamentData[i] = _packPVPData(warriorId, warriors[warriorId]);   \n        }\n        return tournamentData;\n    }\n    \n    \n    // @dev Internal utility function to sign up to tournament, \n    // assumes that all battle requirements have been checked.\n    function _triggerTournamentSignUp(uint256[] memory _warriorIds, uint256 fee) internal {\n        //pack warrior ids into into uint256\n        uint256[] memory tournamentData = _packTournamentData(_warriorIds);\n        \n        for(uint256 i = 0; i < GROUP_SIZE; i++) {\n            // Set warrior current action to tournament battle\n            warriors[_warriorIds[i]].action = uint16(TOURNAMENT_BATTLE);\n        }\n\n        battleProvider.addTournamentContender.value(fee)(msg.sender, tournamentData);\n    }\n    \n    function signUpForTournament(uint256[] _warriorIds) public payable {\n        //\n        //check that there is enough funds to pay entrance fee\n        uint256 fee = battleProvider.getTournamentThresholdFee();\n        require(msg.value >= fee);\n        //\n        //check that warriors group is exactly of allowed size\n        require(_warriorIds.length == GROUP_SIZE);\n        //\n        //message sender must own all the specified warrior IDs\n        require(_ownsAll(msg.sender, _warriorIds));\n        //\n        //check all warriors are unique\n        require(areUnique(_warriorIds));\n        //\n        //check that all warriors are 25 lv and IDLE\n        for(uint256 i = 0; i < GROUP_SIZE; i ++) {\n            // Grab a reference to the warrior in storage.\n            require(_isReadyToTournament(warriors[_warriorIds[i]]));\n        }\n        \n        \n        //all checks passed, trigger sign up\n        _triggerTournamentSignUp(_warriorIds, fee);\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the fee so this cannot underflow.\n        uint256 feeExcess = msg.value - fee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of _isReadyToTournament check\n        // will fail\n        msg.sender.transfer(feeExcess);\n    }\n    \n    function _setIDLE(uint256 warriorIds) internal {\n        for(uint256 i = 0; i < GROUP_SIZE; i ++) {\n            warriors[CryptoUtils._unpackWarriorId(warriorIds, i)].action = uint16(IDLE);\n        }\n    }\n    \n    function _freeWarriors(uint256[] memory packedContenders) internal {\n        uint256 length = packedContenders.length;\n        for(uint256 i = 0; i < length; i ++) {\n            //set participants action to IDLE\n            _setIDLE(packedContenders[i]);\n        }\n    }\n    \n    function tournamentFinished(uint256[] packedContenders) public {\n        //this method can be invoked only by battleProvider contract\n        require(msg.sender == address(battleProvider));\n        \n        //grad rewards and set IDLE action\n        _freeWarriors(packedContenders);\n    }\n    \n}\n\ncontract CryptoWarriorAuction is CryptoWarriorTournament {\n\n    // @notice The auction contract variables are defined in CryptoWarriorBase to allow\n    //  us to refer to them in WarriorTokenImpl to prevent accidental transfers.\n    // `saleAuction` refers to the auction for miner and p2p sale of warriors.\n\n    /// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function setSaleAuctionAddress(address _address) external onlyAdmin {\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSaleClockAuction());\n\n        // Set the new contract address\n        saleAuction = candidateContract;\n    }\n\n\n    /// @dev Put a warrior up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function createSaleAuction(\n        uint256 _warriorId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    )\n        external\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        // If warrior is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_ownerApproved(msg.sender, _warriorId));\n        // Ensure the warrior is not busy to prevent the auction\n        // contract creation while warrior is in any kind of battle (PVE, PVP, TOURNAMENT).\n        require(warriors[_warriorId].action == IDLE);\n        _approve(_warriorId, address(saleAuction));\n        // Sale auction throws if inputs are invalid and clears\n        // transfer approval after escrowing the warrior.\n        saleAuction.createAuction(\n            _warriorId,\n            _startingPrice,\n            _endingPrice,\n            _duration,\n            msg.sender\n        );\n    }\n\n}\n\ncontract CryptoWarriorIssuer is CryptoWarriorAuction {\n    \n    // Limits the number of warriors the contract owner can ever create\n    uint256 public constant MINER_CREATION_LIMIT = 2880;//issue every 15min for one month\n    // Constants for miner auctions.\n    uint256 public constant MINER_STARTING_PRICE = 100 finney;\n    uint256 public constant MINER_END_PRICE = 50 finney;\n    uint256 public constant MINER_AUCTION_DURATION = 1 days;\n\n    uint256 public minerCreatedCount;\n\n    /// @dev Generates a new miner warrior with MINER perk of COMMON rarity\n    ///  creates an auction for it.\n    function createMinerAuction() external onlyIssuer {\n        require(minerCreatedCount < MINER_CREATION_LIMIT);\n\t\t\n        minerCreatedCount++;\n\n        uint256 identity = sanctuary.generateWarrior(minerCreatedCount, 0, block.number - 1, MINER_PERK);\n        uint256 warriorId = _createWarrior(identity, bankAddress, 0, 10, 100, 0);\n        _approve(warriorId, address(saleAuction));\n\n        saleAuction.createAuction(\n            warriorId,\n            _computeNextMinerPrice(),\n            MINER_END_PRICE,\n            MINER_AUCTION_DURATION,\n            bankAddress\n        );\n    }\n\n    /// @dev Computes the next miner auction starting price, given\n    ///  the average of the past 5 prices * 2.\n    function _computeNextMinerPrice() internal view returns (uint256) {\n        uint256 avePrice = saleAuction.averageMinerSalePrice();\n\n        // Sanity check to ensure we don't overflow arithmetic\n        require(avePrice == uint256(uint128(avePrice)));\n\n        uint256 nextPrice = avePrice * 3 / 2;//confirmed\n\n        // We never auction for less than starting price\n        if (nextPrice < MINER_STARTING_PRICE) {\n            nextPrice = MINER_STARTING_PRICE;\n        }\n\n        return nextPrice;\n    }\n\n}\n\ncontract CoreRecovery is CryptoWarriorIssuer {\n    \n    bool public allowRecovery = true;\n    \n    //data model\n    //0 - identity\n    //1 - cooldownEndBlock\n    //2 - level\n    //3 - rating\n    //4 - index\n    function recoverWarriors(uint256[] recoveryData, address[] owners) external onlyAdmin whenPaused {\n        //check that recory action is allowed\n        require(allowRecovery);\n        \n        uint256 length = owners.length;\n        \n        //check that number of owners corresponds to recover data length\n        require(length == recoveryData.length / 5);\n        \n        for(uint256 i = 0; i < length; i++) {\n            _createWarrior(recoveryData[i * 5], owners[i], recoveryData[i * 5 + 1], \n                recoveryData[i * 5 + 2], recoveryData[i * 5 + 3], recoveryData[i * 5 + 4]);\n        }\n    }\n    \n    //recovery is a one time action, once it is done no more recovery actions allowed\n    function recoveryDone() external onlyAdmin {\n        allowRecovery = false;\n    }\n\n}\n\ncontract CryptoWarriorCore is CoreRecovery {\n\n    /// @notice Creates the main CryptoWarrior smart contract instance.\n    function CryptoWarriorCore() public {\n        // Starts paused.\n        paused = true;\n\n        // the creator of the contract is the initial Admin\n        adminAddress = msg.sender;\n\n        // the creator of the contract is also the initial COO\n        issuerAddress = msg.sender;\n        \n        // the creator of the contract is also the initial Bank\n        bankAddress = msg.sender;\n    }\n    \n    /// @notice No tipping!\n    /// @dev Reject all Ether from being sent here\n    /// (Hopefully, we can prevent user accidents.)\n    function() external payable {\n        require(false);\n    }\n    \n    /// @dev Override unpause so it requires all external contract addresses\n    ///  to be set before contract can be unpaused. Also, we can't have\n    ///  newContractAddress set either, because then the contract was upgraded.\n    /// @notice This is public rather than external so we can call super.unpause\n    ///  without using an expensive CALL.\n    function unpause() public onlyAdmin whenPaused {\n        require(address(saleAuction) != address(0));\n        require(address(sanctuary) != address(0));\n        require(address(battleProvider) != address(0));\n        require(newContractAddress == address(0));\n\n        // Actually unpause the contract.\n        super.unpause();\n    }\n    \n    function getBeneficiary() external view returns(address) {\n        return bankAddress;\n    }\n    \n    function isPVPListener() public pure returns (bool) {\n        return true;\n    }\n       \n    /**\n     *@param _warriorIds array of warriorIds, \n     * for those IDs warrior data will be packed into warriorsData array\n     *@return warriorsData packed warrior data\n     *@return stepSize number of fields in single warrior data */\n    function getWarriors(uint256[] _warriorIds) external view returns (uint256[] memory warriorsData, uint256 stepSize) {\n        stepSize = 6;\n        warriorsData = new uint256[](_warriorIds.length * stepSize);\n        for(uint256 i = 0; i < _warriorIds.length; i++) {\n            _setWarriorData(warriorsData, warriors[_warriorIds[i]], i * stepSize);\n        }\n    }\n    \n    /**\n     *@param indexFrom index in global warrior storage (aka warriorId), \n     * from this index(including), warriors data will be gathered\n     *@param count Number of warriors to include in packed data\n     *@return warriorsData packed warrior data\n     *@return stepSize number of fields in single warrior data */\n    function getWarriorsFromIndex(uint256 indexFrom, uint256 count) external view returns (uint256[] memory warriorsData, uint256 stepSize) {\n        stepSize = 6;\n        //check length\n        uint256 lenght = (warriors.length - indexFrom >= count ? count : warriors.length - indexFrom);\n        \n        warriorsData = new uint256[](lenght * stepSize);\n        for(uint256 i = 0; i < lenght; i ++) {\n            _setWarriorData(warriorsData, warriors[indexFrom + i], i * stepSize);\n        }\n    }\n    \n    function getWarriorOwners(uint256[] _warriorIds) external view returns (address[] memory owners) {\n        uint256 lenght = _warriorIds.length;\n        owners = new address[](lenght);\n        \n        for(uint256 i = 0; i < lenght; i ++) {\n            owners[i] = warriorToOwner[_warriorIds[i]];\n        }\n    }\n    \n    \n    function _setWarriorData(uint256[] memory warriorsData, DataTypes.Warrior storage warrior, uint256 id) internal view {\n        warriorsData[id] = uint256(warrior.identity);//0\n        warriorsData[id + 1] = uint256(warrior.cooldownEndBlock);//1\n        warriorsData[id + 2] = uint256(warrior.level);//2\n        warriorsData[id + 3] = uint256(warrior.rating);//3\n        warriorsData[id + 4] = uint256(warrior.action);//4\n        warriorsData[id + 5] = uint256(warrior.dungeonIndex);//5\n    }\n    \n\tfunction getWarrior(uint256 _id) external view returns \n    (\n        uint256 identity, \n        uint256 cooldownEndBlock, \n        uint256 level,\n        uint256 rating, \n        uint256 action,\n        uint256 dungeonIndex\n    ) {\n        DataTypes.Warrior storage warrior = warriors[_id];\n\n        identity = uint256(warrior.identity);\n        cooldownEndBlock = uint256(warrior.cooldownEndBlock);\n        level = uint256(warrior.level);\n\t\trating = uint256(warrior.rating);\n\t\taction = uint256(warrior.action);\n\t\tdungeonIndex = uint256(warrior.dungeonIndex);\n    }\n    \n}\n\n/*  @title Handles creating pvp battles every 15 min.*/\ncontract PVP is PausableBattle, PVPInterface {\n\t/* PVP BATLE */\n\t\n    /** list of packed warrior data that will participate in next PVP session. \n     *  Fixed size arry, to evade constant remove and push operations,\n     *  this approach reduces transaction costs involving queue modification. */\n    uint256[100] public pvpQueue;\n    //\n    //queue size\n    uint256 public pvpQueueSize = 0;\n    \n    // @dev A mapping from owner address to booty in WEI\n    //  booty is acquired in PVP and Tournament battles and can be\n    // withdrawn with grabBooty method by the owner of the loot\n    mapping (address => uint256) public ownerToBooty;\n    \n    // @dev A mapping from warrior id to owners address\n    mapping (uint256 => address) internal warriorToOwner;\n    \n    // An approximation of currently how many seconds are in between blocks.\n    uint256 internal secondsPerBlock = 15;\n    \n    // Cut owner takes from, measured in basis points (1/100 of a percent).\n    // Values 0-10,000 map to 0%-100%\n    uint256 public pvpOwnerCut;\n    \n    // Values 0-10,000 map to 0%-100%\n    //this % of the total bets will be sent as \n    //a reward to address, that triggered finishPVP method\n    uint256 public pvpMaxIncentiveCut;\n    \n    /// @notice The payment base required to use startPVP().\n    // pvpBattleFee * (warrior.level / POINTS_TO_LEVEL)\n    uint256 internal pvpBattleFee = 10 finney;\n    \n    uint256 public constant PVP_INTERVAL = 15 minutes;\n    \n    uint256 public nextPVPBatleBlock = 0;\n    //number of WEI in hands of warrior owners\n    uint256 public totalBooty = 0;\n    \n    /* TOURNAMENT */\n    uint256 public constant FUND_GATHERING_TIME = 24 hours;\n    uint256 public constant ADMISSION_TIME = 12 hours;\n    uint256 public constant RATING_EXPAND_INTERVAL = 1 hours;\n    uint256 internal constant SAFETY_GAP = 5;\n    \n    uint256 internal constant MAX_INCENTIVE_REWARD = 200 finney;\n    \n    //tournamentContenders size\n    uint256 public tournamentQueueSize = 0;\n    \n    // Values 0-10,000 map to 0%-100%\n    uint256 public tournamentBankCut;\n    \n   /** tournamentEndBlock, tournament is eligible to be finished only\n    *  after block.number >= tournamentEndBlock \n    *  it depends on FUND_GATHERING_TIME and ADMISSION_TIME */\n    uint256 public tournamentEndBlock;\n    \n    //number of WEI in tournament bank\n    uint256 public currentTournamentBank = 0;\n    uint256 public nextTournamentBank = 0;\n    \n    PVPListenerInterface internal pvpListener;\n    \n    /* EVENTS */\n    /** @dev TournamentScheduled event. Emitted every time a tournament is scheduled \n     *  @param tournamentEndBlock when block.number > tournamentEndBlock, then tournament \n     *         is eligible to be finished or rescheduled */\n    event TournamentScheduled(uint256 tournamentEndBlock);\n    \n    /** @dev PVPScheduled event. Emitted every time a tournament is scheduled \n     *  @param nextPVPBatleBlock when block.number > nextPVPBatleBlock, then pvp battle \n     *         is eligible to be finished or rescheduled */\n    event PVPScheduled(uint256 nextPVPBatleBlock);\n    \n    /** @dev PVPNewContender event. Emitted every time a warrior enqueues pvp battle\n     *  @param owner Warrior owner\n     *  @param warriorId Warrior ID that entered PVP queue\n     *  @param entranceFee fee in WEI warrior owner payed to enter PVP\n     */\n    event PVPNewContender(address owner, uint256 warriorId, uint256 entranceFee);\n\n    /** @dev PVPFinished event. Emitted every time a pvp battle is finished\n     *  @param warriorsData array of pairs of pvp warriors packed to uint256, even => winners, odd => losers \n     *  @param owners array of warrior owners, 1 to 1 with warriorsData, even => winners, odd => losers \n     *  @param matchingCount total number of warriors that fought in current pvp session and got rewards,\n     *  if matchingCount < participants.length then all IDs that are >= matchingCount will \n     *  remain in waiting room, until they are matched.\n     */\n    event PVPFinished(uint256[] warriorsData, address[] owners, uint256 matchingCount);\n    \n    /** @dev BootySendFailed event. Emitted every time address.send() function failed to transfer Ether to recipient\n     *  in this case recipient Ether is recorded to ownerToBooty mapping, so recipient can withdraw their booty manually\n     *  @param recipient address for whom send failed\n     *  @param amount number of WEI we failed to send\n     */\n    event BootySendFailed(address recipient, uint256 amount);\n    \n    /** @dev BootyGrabbed event\n     *  @param receiver address who grabbed his booty\n     *  @param amount number of WEI\n     */\n    event BootyGrabbed(address receiver, uint256 amount);\n    \n    /** @dev PVPContenderRemoved event. Emitted every time warrior is removed from pvp queue by its owner.\n     *  @param warriorId id of the removed warrior\n     */\n    event PVPContenderRemoved(uint256 warriorId, address owner);\n    \n    function PVP(uint256 _pvpCut, uint256 _tournamentBankCut, uint256 _pvpMaxIncentiveCut) public {\n        require((_tournamentBankCut + _pvpCut + _pvpMaxIncentiveCut) <= 10000);\n\t\tpvpOwnerCut = _pvpCut;\n\t\ttournamentBankCut = _tournamentBankCut;\n\t\tpvpMaxIncentiveCut = _pvpMaxIncentiveCut;\n    }\n    \n    /** @dev grabBooty sends to message sender his booty in WEI\n     */\n    function grabBooty() external {\n        uint256 booty = ownerToBooty[msg.sender];\n        require(booty > 0);\n        require(totalBooty >= booty);\n        \n        ownerToBooty[msg.sender] = 0;\n        totalBooty -= booty;\n        \n        msg.sender.transfer(booty);\n        //emit event\n        BootyGrabbed(msg.sender, booty);\n    }\n    \n    function safeSend(address _recipient, uint256 _amaunt) internal {\n\t\tuint256 failedBooty = sendBooty(_recipient, _amaunt);\n        if (failedBooty > 0) {\n\t\t\ttotalBooty += failedBooty;\n        }\n    }\n    \n    function sendBooty(address _recipient, uint256 _amaunt) internal returns(uint256) {\n        bool success = _recipient.send(_amaunt);\n        if (!success && _amaunt > 0) {\n            ownerToBooty[_recipient] += _amaunt;\n            BootySendFailed(_recipient, _amaunt);\n            return _amaunt;\n        }\n        return 0;\n    }\n    \n    //@returns block number, after this block tournament is opened for admission\n    function getTournamentAdmissionBlock() public view returns(uint256) {\n        uint256 admissionInterval = (ADMISSION_TIME / secondsPerBlock);\n        return tournamentEndBlock < admissionInterval ? 0 : tournamentEndBlock - admissionInterval;\n    }\n    \n    \n    //schedules next turnament time(block)\n    function _scheduleTournament() internal {\n        //we can chedule only if there is nobody in tournament queue and\n        //time of tournament battle have passed\n\t\tif (tournamentQueueSize == 0 && tournamentEndBlock <= block.number) {\n\t\t    tournamentEndBlock = ((FUND_GATHERING_TIME / 2 + ADMISSION_TIME) / secondsPerBlock) + block.number;\n\t\t    TournamentScheduled(tournamentEndBlock);\n\t\t}\n    }\n    \n    /// @dev Updates the minimum payment required for calling startPVP(). Can only\n    ///  be called by the COO address, and only if pvp queue is empty.\n    function setPVPEntranceFee(uint256 value) external onlyOwner {\n        require(pvpQueueSize == 0);\n        pvpBattleFee = value;\n    }\n    \n    //@returns PVP entrance fee for specified warrior level \n    //@param _levelPoints NB!\n    function getPVPEntranceFee(uint256 _levelPoints) external view returns(uint256) {\n        return pvpBattleFee * CryptoUtils._getLevel(_levelPoints);\n    }\n    \n    //level can only be > 0 and <= 25\n    function _getPVPFeeByLevel(uint256 _level) internal view returns(uint256) {\n        return pvpBattleFee * _level;\n    }\n    \n\t// @dev Computes warrior pvp reward\n    // @param _totalBet - total bet from both competitors.\n    function _computePVPReward(uint256 _totalBet, uint256 _contendersCut) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalBet max value is 1000 finney, and _contendersCut aka\n        // (10000 - pvpOwnerCut - tournamentBankCut - incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalBet.\n        return _totalBet * _contendersCut / 10000;\n    }\n    \n    function _getPVPContendersCut(uint256 _incentiveCut) internal view returns (uint256) {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // (pvpOwnerCut + tournamentBankCut + pvpMaxIncentiveCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). \n        // _incentiveCut is guaranteed to be >= 1 and <=  pvpMaxIncentiveCut\n        return (10000 - pvpOwnerCut - tournamentBankCut - _incentiveCut);\n    }\n\t\n\t// @dev Computes warrior pvp reward\n    // @param _totalSessionLoot - total bets from all competitors.\n    function _computeIncentiveReward(uint256 _totalSessionLoot, uint256 _incentiveCut) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalSessionLoot max value is 37500 finney, and \n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalSessionLoot.\n        return _totalSessionLoot * _incentiveCut / 10000;\n    }\n    \n\t///@dev computes incentive cut for specified loot, \n\t/// Values 0-10,000 map to 0%-100%\n\t/// max incentive reward cut is 5%, if it exceeds MAX_INCENTIVE_REWARD,\n\t/// then cut is lowered to be equal to MAX_INCENTIVE_REWARD.\n\t/// minimum cut is 0.01%\n    /// this % of the total bets will be sent as \n    /// a reward to address, that triggered finishPVP method\n    function _computeIncentiveCut(uint256 _totalSessionLoot, uint256 maxIncentiveCut) internal pure returns(uint256) {\n        uint256 result = _totalSessionLoot * maxIncentiveCut / 10000;\n        result = result <= MAX_INCENTIVE_REWARD ? maxIncentiveCut : MAX_INCENTIVE_REWARD * 10000 / _totalSessionLoot;\n        //min cut is 0.01%\n        return result > 0 ? result : 1;\n    }\n    \n    // @dev Computes warrior pvp reward\n    // @param _totalSessionLoot - total bets from all competitors.\n    function _computePVPBeneficiaryFee(uint256 _totalSessionLoot) internal view returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalSessionLoot max value is 37500 finney, and \n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalSessionLoot.\n        return _totalSessionLoot * pvpOwnerCut / 10000;\n    }\n    \n    // @dev Computes tournament bank cut\n    // @param _totalSessionLoot - total session loot.\n    function _computeTournamentCut(uint256 _totalSessionLoot) internal view returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalSessionLoot max value is 37500 finney, and \n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalSessionLoot.\n        return _totalSessionLoot * tournamentBankCut / 10000;\n    }\n\n    function indexOf(uint256 _warriorId) internal view returns(int256) {\n\t    uint256 length = uint256(pvpQueueSize);\n\t    for(uint256 i = 0; i < length; i ++) {\n\t        if(CryptoUtils._unpackIdValue(pvpQueue[i]) == _warriorId) return int256(i);\n\t    }\n\t    return -1;\n\t}\n    \n    function getPVPIncentiveReward(uint256[] memory matchingIds, uint256 matchingCount) internal view returns(uint256) {\n        uint256 sessionLoot = _computeTotalBooty(matchingIds, matchingCount);\n        \n        return _computeIncentiveReward(sessionLoot, _computeIncentiveCut(sessionLoot, pvpMaxIncentiveCut));\n    }\n    \n    function maxPVPContenders() external view returns(uint256){\n        return pvpQueue.length;\n    }\n    \n    function getPVPState() external view returns\n    (uint256 contendersCount, uint256 matchingCount, uint256 endBlock, uint256 incentiveReward)\n    {\n        uint256[] memory pvpData = _packPVPData();\n        \n    \tcontendersCount = pvpQueueSize;\n    \tmatchingCount = CryptoUtils._getMatchingIds(pvpData, PVP_INTERVAL, _computeCycleSkip(), RATING_EXPAND_INTERVAL);\n    \tendBlock = nextPVPBatleBlock;   \n    \tincentiveReward = getPVPIncentiveReward(pvpData, matchingCount);\n    }\n    \n    function canFinishPVP() external view returns(bool) {\n        return nextPVPBatleBlock <= block.number &&\n         CryptoUtils._getMatchingIds(_packPVPData(), PVP_INTERVAL, _computeCycleSkip(), RATING_EXPAND_INTERVAL) > 1;\n    }\n    \n    function _clarifyPVPSchedule() internal {\n        uint256 length = pvpQueueSize;\n\t\tuint256 currentBlock = block.number;\n\t\tuint256 nextBattleBlock = nextPVPBatleBlock;\n\t\t//if battle not scheduled, schedule battle\n\t\tif (nextBattleBlock <= currentBlock) {\n\t\t    //if queue not empty update cycles\n\t\t    if (length > 0) {\n\t\t\t\tuint256 packedWarrior;\n\t\t\t\tuint256 cycleSkip = _computeCycleSkip();\n\t\t        for(uint256 i = 0; i < length; i++) {\n\t\t            packedWarrior = pvpQueue[i];\n\t\t            //increase warrior iteration cycle\n\t\t            pvpQueue[i] = CryptoUtils._changeCycleValue(packedWarrior, CryptoUtils._unpackCycleValue(packedWarrior) + cycleSkip);\n\t\t        }\n\t\t    }\n\t\t    nextBattleBlock = (PVP_INTERVAL / secondsPerBlock) + currentBlock;\n\t\t    nextPVPBatleBlock = nextBattleBlock;\n\t\t    PVPScheduled(nextBattleBlock);\n\t\t//if pvp queue will be full and there is still too much time left, then let the battle begin! \n\t\t} else if (length + 1 == pvpQueue.length && (currentBlock + SAFETY_GAP * 2) < nextBattleBlock) {\n\t\t    nextBattleBlock = currentBlock + SAFETY_GAP;\n\t\t    nextPVPBatleBlock = nextBattleBlock;\n\t\t    PVPScheduled(nextBattleBlock);\n\t\t}\n    }\n    \n    /// @dev Internal utility function to initiate pvp battle, assumes that all battle\n    ///  requirements have been checked.\n    function _triggerNewPVPContender(address _owner, uint256 _packedWarrior, uint256 fee) internal {\n\n\t\t_clarifyPVPSchedule();\n        //number of pvp cycles the warrior is waiting for suitable enemy match\n        //increment every time when finishPVP is called and no suitable enemy match was found\n        _packedWarrior = CryptoUtils._changeCycleValue(_packedWarrior, 0);\n\t\t\n\t\t//record contender data\n\t\tpvpQueue[pvpQueueSize++] = _packedWarrior;\n\t\twarriorToOwner[CryptoUtils._unpackIdValue(_packedWarrior)] = _owner;\n\t\t\n\t\t//Emit event\n\t\tPVPNewContender(_owner, CryptoUtils._unpackIdValue(_packedWarrior), fee);\n    }\n    \n    function _noMatchingPairs() internal view returns(bool) {\n        uint256 matchingCount = CryptoUtils._getMatchingIds(_packPVPData(), uint64(PVP_INTERVAL), _computeCycleSkip(), uint64(RATING_EXPAND_INTERVAL));\n        return matchingCount == 0;\n    }\n    \n    /*\n     * @title startPVP enqueues specified warrior to PVP\n     * \n     * @dev When the owner enqueues his warrior for PvP, the warrior enters the waiting room.\n     * Once every 15 minutes, we check the warriors in the room and select pairs. \n     * For those warriors to whom we found couples, fighting is conducted and the results \n     * are recorded in the profile of the warrior. \n     */\n    function addPVPContender(address _owner, uint256 _packedWarrior) external payable PVPNotPaused {\n\t\t// Caller must be pvpListener contract\n        require(msg.sender == address(pvpListener));\n\n        require(_owner != address(0));\n        //contender can be added only while PVP is scheduled in future\n        //or no matching warrior pairs found\n        require(nextPVPBatleBlock > block.number || _noMatchingPairs());\n        // Check that the warrior exists.\n        require(_packedWarrior != 0);\n        //owner must withdraw all loot before contending pvp\n        require(ownerToBooty[_owner] == 0);\n        //check that there is enough room for new participants\n        require(pvpQueueSize < pvpQueue.length);\n        // Checks for payment.\n        uint256 fee = _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarrior));\n        require(msg.value >= fee);\n        //\n        // All checks passed, put the warrior to the queue!\n        _triggerNewPVPContender(_owner, _packedWarrior, fee);\n    }\n    \n    function _packPVPData() internal view returns(uint256[] memory matchingIds) {\n        uint256 length = pvpQueueSize;\n        matchingIds = new uint256[](length);\n        for(uint256 i = 0; i < length; i++) {\n            matchingIds[i] = pvpQueue[i];\n        }\n        return matchingIds;\n    }\n    \n    function _computeTotalBooty(uint256[] memory _packedWarriors, uint256 matchingCount) internal view returns(uint256) {\n        //compute session booty\n        uint256 sessionLoot = 0;\n        for(uint256 i = 0; i < matchingCount; i++) {\n            sessionLoot += _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarriors[i]));\n        }\n        return sessionLoot;\n    }\n    \n    function _grandPVPRewards(uint256[] memory _packedWarriors, uint256 matchingCount) \n    internal returns(uint256)\n    {\n        uint256 booty = 0;\n        uint256 packedWarrior;\n        uint256 failedBooty = 0;\n        \n        uint256 sessionBooty = _computeTotalBooty(_packedWarriors, matchingCount);\n        uint256 incentiveCut = _computeIncentiveCut(sessionBooty, pvpMaxIncentiveCut);\n        uint256 contendersCut = _getPVPContendersCut(incentiveCut);\n        \n        for(uint256 id = 0; id < matchingCount; id++) {\n            //give reward to warriors that fought hard\n\t\t\t//winner, even ids are winners!\n\t\t\tpackedWarrior = _packedWarriors[id];\n\t\t\t//\n\t\t\t//give winner deserved booty 80% from both bets\n\t\t\t//must be computed before level reward!\n\t\t\tbooty = _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(packedWarrior)) + \n\t\t\t\t_getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarriors[id + 1]));\n\t\t\t\n\t\t\t//\n\t\t\t//send reward to warrior owner\n\t\t\tfailedBooty += sendBooty(warriorToOwner[CryptoUtils._unpackIdValue(packedWarrior)], _computePVPReward(booty, contendersCut));\n\t\t\t//loser, they are odd...\n\t\t\t//skip them, as they deserve none!\n\t\t\tid ++;\n        }\n        failedBooty += sendBooty(pvpListener.getBeneficiary(), _computePVPBeneficiaryFee(sessionBooty));\n        \n        if (failedBooty > 0) {\n            totalBooty += failedBooty;\n        }\n        //if tournament admission start time not passed\n        //add tournament cut to current tournament bank,\n        //otherwise to next tournament bank\n        if (getTournamentAdmissionBlock() > block.number) {\n            currentTournamentBank += _computeTournamentCut(sessionBooty);\n        } else {\n            nextTournamentBank += _computeTournamentCut(sessionBooty);\n        }\n        \n        //compute incentive reward\n        return _computeIncentiveReward(sessionBooty, incentiveCut);\n    }\n    \n    function _increaseCycleAndTrimQueue(uint256[] memory matchingIds, uint256 matchingCount) internal {\n        uint32 length = uint32(matchingIds.length - matchingCount);  \n\t\tuint256 packedWarrior;\n\t\tuint256 skipCycles = _computeCycleSkip();\n        for(uint256 i = 0; i < length; i++) {\n            packedWarrior = matchingIds[matchingCount + i];\n            //increase warrior iteration cycle\n            pvpQueue[i] = CryptoUtils._changeCycleValue(packedWarrior, CryptoUtils._unpackCycleValue(packedWarrior) + skipCycles);\n        }\n        //trim queue\t\n        pvpQueueSize = length;\n    }\n    \n    function _computeCycleSkip() internal view returns(uint256) {\n        uint256 number = block.number;\n        return nextPVPBatleBlock > number ? 0 : (number - nextPVPBatleBlock) * secondsPerBlock / PVP_INTERVAL + 1;\n    }\n    \n    function _getWarriorOwners(uint256[] memory pvpData) internal view returns (address[] memory owners){\n        uint256 length = pvpData.length;\n        owners = new address[](length);\n        for(uint256 i = 0; i < length; i ++) {\n            owners[i] = warriorToOwner[CryptoUtils._unpackIdValue(pvpData[i])];\n        }\n    }\n    \n    // @dev Internal utility function to initiate pvp battle, assumes that all battle\n    ///  requirements have been checked.\n    function _triggerPVPFinish(uint256[] memory pvpData, uint256 matchingCount) internal returns(uint256){\n        //\n\t\t//compute battle results        \n        CryptoUtils._getPVPBattleResults(pvpData, matchingCount, nextPVPBatleBlock);\n        //\n        //mark not fought warriors and trim queue \n        _increaseCycleAndTrimQueue(pvpData, matchingCount);\n        //\n        //schedule next battle time\n        nextPVPBatleBlock = (PVP_INTERVAL / secondsPerBlock) + block.number;\n        \n        //\n        //schedule tournament\n        //if contendersCount is 0 and tournament not scheduled, schedule tournament\n        //NB MUST be before _grandPVPRewards()\n        _scheduleTournament();\n        // compute and grand rewards to warriors,\n        // put tournament cut to bank, not susceptible to reentry attack because of require(nextPVPBatleBlock <= block.number);\n        // and require(number of pairs > 1);\n        uint256 incentiveReward = _grandPVPRewards(pvpData, matchingCount);\n        //\n        //notify pvp listener contract\n        pvpListener.pvpFinished(pvpData, matchingCount);\n        \n        //\n        //fire event\n\t\tPVPFinished(pvpData, _getWarriorOwners(pvpData), matchingCount);\n        PVPScheduled(nextPVPBatleBlock);\n\t\t\n\t\treturn incentiveReward;\n    }\n    \n    \n    /**\n     * @dev finishPVP this method finds matches of warrior pairs\n     * in waiting room and computes result of their fights.\n     * \n     * The winner gets +1 level, the loser gets +0.5 level\n     * The winning player gets +130 rating\n\t * The losing player gets -30 or 70 rating (if warrior levelUps after battle) .\n     * can be called once in 15min.\n     * NB If the warrior is not picked up in an hour, then we expand the range \n     * of selection by 25 rating each hour.\n     */\n    function finishPVP() public PVPNotPaused {\n        // battle interval is over\n        require(nextPVPBatleBlock <= block.number);\n        //\n\t    //match warriors\n        uint256[] memory pvpData = _packPVPData();\n        //match ids and sort them according to matching\n        uint256 matchingCount = CryptoUtils._getMatchingIds(pvpData, uint64(PVP_INTERVAL), _computeCycleSkip(), uint64(RATING_EXPAND_INTERVAL));\n\t\t// we have at least 1 matching battle pair\n        require(matchingCount > 1);\n        \n        // When the all checks done, calculate actual battle result\n        uint256 incentiveReward = _triggerPVPFinish(pvpData, matchingCount);\n        \n        //give reward for incentive\n        safeSend(msg.sender, incentiveReward);\n    }\n\n    // @dev Removes specified warrior from PVP queue\n    //  sets warrior free (IDLE) and returns pvp entrance fee to owner\n    // @notice This is a state-modifying function that can\n    //  be called while the contract is paused.\n    // @param _warriorId - ID of warrior in PVP queue\n    function removePVPContender(uint256 _warriorId) external{\n        uint256 queueSize = pvpQueueSize;\n        require(queueSize > 0);\n        // Caller must be owner of the specified warrior\n        require(warriorToOwner[_warriorId] == msg.sender);\n        //warrior must be in pvp queue\n        int256 warriorIndex = indexOf(_warriorId);\n        require(warriorIndex >= 0);\n        //grab warrior data\n        uint256 warriorData = pvpQueue[uint32(warriorIndex)];\n        //warrior cycle must be >= 4 (> than 1 hour)\n        require((CryptoUtils._unpackCycleValue(warriorData) + _computeCycleSkip()) >= 4);\n        \n        //remove from queue\n        if (uint256(warriorIndex) < queueSize - 1) {\n\t        pvpQueue[uint32(warriorIndex)] = pvpQueue[pvpQueueSize - 1];\n        }\n        pvpQueueSize --;\n        //notify battle listener\n        pvpListener.pvpContenderRemoved(_warriorId);\n        //return pvp bet\n        msg.sender.transfer(_getPVPFeeByLevel(CryptoUtils._unpackLevelValue(warriorData)));\n        //Emit event\n        PVPContenderRemoved(_warriorId, msg.sender);\n    }\n    \n    function getPVPCycles(uint32[] warriorIds) external view returns(uint32[]){\n        uint256 length = warriorIds.length;\n        uint32[] memory cycles = new uint32[](length);\n        int256 index;\n        uint256 skipCycles = _computeCycleSkip();\n\t    for(uint256 i = 0; i < length; i ++) {\n\t        index = indexOf(warriorIds[i]);\n\t        cycles[i] = index >= 0 ? uint32(CryptoUtils._unpackCycleValue(pvpQueue[uint32(index)]) + skipCycles) : 0;\n\t    }\n\t    return cycles;\n    }\n    \n    // @dev Remove all PVP contenders from PVP queue \n    //  and return all bets to warrior owners.\n    //  NB: this is emergency method, used only in f%#^@up situation\n    function removeAllPVPContenders() external onlyOwner PVPPaused {\n        //remove all pvp contenders\n        uint256 length = pvpQueueSize;\n        \n        uint256 warriorData;\n        uint256 warriorId;\n        uint256 failedBooty;\n        address owner;\n        \n        pvpQueueSize = 0;\n        \n        for(uint256 i = 0; i < length; i++) {\n\t        //grab warrior data\n\t        warriorData = pvpQueue[i];\n\t        warriorId = CryptoUtils._unpackIdValue(warriorData);\n\t        //notify battle listener\n\t        pvpListener.pvpContenderRemoved(uint32(warriorId));\n\t        \n\t        owner = warriorToOwner[warriorId];\n\t        //return pvp bet\n\t        failedBooty += sendBooty(owner, _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(warriorData)));\n        }\n        totalBooty += failedBooty;\n    }\n}\n\n\ncontract Tournament is PVP {\n\n    uint256 internal constant GROUP_SIZE = 5;\n    uint256 internal constant DATA_SIZE = 2;\n    uint256 internal constant THRESHOLD = 300;\n    \n  /** list of warrior IDs that will participate in next tournament. \n    *  Fixed size arry, to evade constant remove and push operations,\n    *  this approach reduces transaction costs involving array modification. */\n    uint256[160] public tournamentQueue;\n    \n    /**The cost of participation in the tournament is 1% of its current prize fund, \n     * money is added to the prize fund. measured in basis points (1/100 of a percent).\n     * Values 0-10,000 map to 0%-100% */\n    uint256 internal tournamentEntranceFeeCut = 100;\n    \n    // Values 0-10,000 map to 0%-100% => 20%\n    uint256 public tournamentOwnersCut;\n    uint256 public tournamentIncentiveCut;\n    \n     /** @dev TournamentNewContender event. Emitted every time a warrior enters tournament\n     *  @param owner Warrior owner\n     *  @param warriorIds 5 Warrior IDs that entered tournament, packed into one uint256\n     *  see CryptoUtils._packWarriorIds\n     */\n    event TournamentNewContender(address owner, uint256 warriorIds, uint256 entranceFee);\n    \n    /** @dev TournamentFinished event. Emitted every time a tournament is finished\n     *  @param owners array of warrior group owners packed to uint256\n     *  @param results number of wins for each group\n     *  @param tournamentBank current tournament bank\n     *  see CryptoUtils._packWarriorIds\n     */\n    event TournamentFinished(uint256[] owners, uint32[] results, uint256 tournamentBank);\n    \n    function Tournament(uint256 _pvpCut, uint256 _tournamentBankCut, \n    uint256 _pvpMaxIncentiveCut, uint256 _tournamentOwnersCut, uint256 _tournamentIncentiveCut) public\n    PVP(_pvpCut, _tournamentBankCut, _pvpMaxIncentiveCut) \n    {\n        require((_tournamentOwnersCut + _tournamentIncentiveCut) <= 10000);\n\t\t\n\t\ttournamentOwnersCut = _tournamentOwnersCut;\n\t\ttournamentIncentiveCut = _tournamentIncentiveCut;\n    }\n    \n    \n    \n    // @dev Computes incentive reward for launching tournament finishTournament()\n    // @param _tournamentBank\n    function _computeTournamentIncentiveReward(uint256 _currentBank, uint256 _incentiveCut) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\n        // and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _currentBank.\n        return _currentBank * _incentiveCut / 10000;\n    }\n    \n    function _computeTournamentContenderCut(uint256 _incentiveCut) internal view returns (uint256) {\n        // NOTE: (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _reward.\n        return 10000 - tournamentOwnersCut - _incentiveCut;\n    }\n    \n    function _computeTournamentBeneficiaryFee(uint256 _currentBank) internal view returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\n        // and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _currentBank.\n        return _currentBank * tournamentOwnersCut / 10000;\n    }\n    \n    // @dev set tournament entrance fee cut, can be set only if\n    // tournament queue is empty\n    // @param _cut range from 0 - 10000, mapped to 0-100%\n    function setTournamentEntranceFeeCut(uint256 _cut) external onlyOwner {\n        //cut must be less or equal 100&\n        require(_cut <= 10000);\n        //tournament queue must be empty\n        require(tournamentQueueSize == 0);\n        //checks passed, set cut\n\t\ttournamentEntranceFeeCut = _cut;\n    }\n    \n    function getTournamentEntranceFee() external view returns(uint256) {\n        return currentTournamentBank * tournamentEntranceFeeCut / 10000;\n    }\n    \n    //@dev returns tournament entrance fee - 3% threshold\n    function getTournamentThresholdFee() public view returns(uint256) {\n        return currentTournamentBank * tournamentEntranceFeeCut * (10000 - THRESHOLD) / 10000 / 10000;\n    }\n    \n    //@dev returns max allowed tournament contenders, public because of internal use\n    function maxTournamentContenders() public view returns(uint256){\n        return tournamentQueue.length / DATA_SIZE;\n    }\n    \n    function canFinishTournament() external view returns(bool) {\n        return tournamentEndBlock <= block.number && tournamentQueueSize > 0;\n    }\n    \n    // @dev Internal utility function to sigin up to tournament, \n    // assumes that all battle requirements have been checked.\n    function _triggerNewTournamentContender(address _owner, uint256[] memory _tournamentData, uint256 _fee) internal {\n        //pack warrior ids into uint256\n        \n        currentTournamentBank += _fee;\n        \n        uint256 packedWarriorIds = CryptoUtils._packWarriorIds(_tournamentData);\n        //make composite warrior out of 5 warriors \n        uint256 combinedWarrior = CryptoUtils._combineWarriors(_tournamentData);\n        \n        //add to queue\n        //icrement tournament queue\n        uint256 size = tournamentQueueSize++ * DATA_SIZE;\n        //record tournament data\n\t\ttournamentQueue[size++] = packedWarriorIds;\n\t\ttournamentQueue[size++] = combinedWarrior;\n\t\twarriorToOwner[CryptoUtils._unpackWarriorId(packedWarriorIds, 0)] = _owner;\n\t\t//\n\t\t//Emit event\n\t\tTournamentNewContender(_owner, packedWarriorIds, _fee);\n    }\n    \n    function addTournamentContender(address _owner, uint256[] _tournamentData) external payable TournamentNotPaused{\n        // Caller must be pvpListener contract\n        require(msg.sender == address(pvpListener));\n        \n        require(_owner != address(0));\n        //\n        //check current tournament bank > 0\n        require(pvpBattleFee == 0 || currentTournamentBank > 0);\n        //\n        //check that there is enough funds to pay entrance fee\n        uint256 fee = getTournamentThresholdFee();\n        require(msg.value >= fee);\n        //owner must withdraw all booty before contending pvp\n        require(ownerToBooty[_owner] == 0);\n        //\n        //check that warriors group is exactly of allowed size\n        require(_tournamentData.length == GROUP_SIZE);\n        //\n        //check that there is enough room for new participants\n        require(tournamentQueueSize < maxTournamentContenders());\n        //\n        //check that admission started\n        require(block.number >= getTournamentAdmissionBlock());\n        //check that admission not ended\n        require(block.number <= tournamentEndBlock);\n        \n        //all checks passed, trigger sign up\n        _triggerNewTournamentContender(_owner, _tournamentData, fee);\n    }\n    \n    //@dev collect all combined warriors data\n    function getCombinedWarriors() internal view returns(uint256[] memory warriorsData) {\n        uint256 length = tournamentQueueSize;\n        warriorsData = new uint256[](length);\n        \n        for(uint256 i = 0; i < length; i ++) {\n            // Grab the combined warrior data in storage.\n            warriorsData[i] = tournamentQueue[i * DATA_SIZE + 1];\n        }\n        return warriorsData;\n    }\n    \n    function getTournamentState() external view returns\n    (uint256 contendersCount, uint256 bank, uint256 admissionStartBlock, uint256 endBlock, uint256 incentiveReward)\n    {\n    \tcontendersCount = tournamentQueueSize;\n    \tbank = currentTournamentBank;\n    \tadmissionStartBlock = getTournamentAdmissionBlock();   \n    \tendBlock = tournamentEndBlock;\n    \tincentiveReward = _computeTournamentIncentiveReward(bank, _computeIncentiveCut(bank, tournamentIncentiveCut));\n    }\n    \n    function _repackToCombinedIds(uint256[] memory _warriorsData) internal view {\n        uint256 length = _warriorsData.length;\n        for(uint256 i = 0; i < length; i ++) {\n            _warriorsData[i] = tournamentQueue[i * DATA_SIZE];\n        }\n    }\n    \n    // @dev Computes warrior pvp reward\n    // @param _totalBet - total bet from both competitors.\n    function _computeTournamentBooty(uint256 _currentBank, uint256 _contenderResult, uint256 _totalBattles) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\n        // _totalBattles is guaranteed to be > 0 and <= 400, and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _reward.\n        // return _currentBank * (10000 - tournamentOwnersCut - _incentiveCut) * _result / 10000 / _totalBattles;\n        return _currentBank * _contenderResult / _totalBattles;\n        \n    }\n    \n    function _grandTournamentBooty(uint256 _warriorIds, uint256 _currentBank, uint256 _contenderResult, uint256 _totalBattles)\n    internal returns (uint256)\n    {\n        uint256 warriorId = CryptoUtils._unpackWarriorId(_warriorIds, 0);\n        address owner = warriorToOwner[warriorId];\n        uint256 booty = _computeTournamentBooty(_currentBank, _contenderResult, _totalBattles);\n        return sendBooty(owner, booty);\n    }\n    \n    function _grandTournamentRewards(uint256 _currentBank, uint256[] memory _warriorsData, uint32[] memory _results) internal returns (uint256){\n        uint256 length = _warriorsData.length;\n        uint256 totalBattles = CryptoUtils._getTournamentBattles(length) * 10000;//*10000 required for booty computation\n        uint256 incentiveCut = _computeIncentiveCut(_currentBank, tournamentIncentiveCut);\n        uint256 contenderCut = _computeTournamentContenderCut(incentiveCut);\n        \n        uint256 failedBooty = 0;\n        for(uint256 i = 0; i < length; i ++) {\n            //grand rewards\n            failedBooty += _grandTournamentBooty(_warriorsData[i], _currentBank, _results[i] * contenderCut, totalBattles);\n        }\n        //send beneficiary fee\n        failedBooty += sendBooty(pvpListener.getBeneficiary(), _computeTournamentBeneficiaryFee(_currentBank));\n        if (failedBooty > 0) {\n            totalBooty += failedBooty;\n        }\n        return _computeTournamentIncentiveReward(_currentBank, incentiveCut);\n    }\n    \n    function _repackToWarriorOwners(uint256[] memory warriorsData) internal view {\n        uint256 length = warriorsData.length;\n        for (uint256 i = 0; i < length; i ++) {\n            warriorsData[i] = uint256(warriorToOwner[CryptoUtils._unpackWarriorId(warriorsData[i], 0)]);\n        }\n    }\n    \n    function _triggerFinishTournament() internal returns(uint256){\n        //hold 10 random battles for each composite warrior\n        uint256[] memory warriorsData = getCombinedWarriors();\n        uint32[] memory results = CryptoUtils.getTournamentBattleResults(warriorsData, tournamentEndBlock - 1);\n        //repack combined warriors id\n        _repackToCombinedIds(warriorsData);\n        //notify pvp listener\n        pvpListener.tournamentFinished(warriorsData);\n        //reschedule\n        //clear tournament\n        tournamentQueueSize = 0;\n        //schedule new tournament\n        _scheduleTournament();\n        \n        uint256 currentBank = currentTournamentBank;\n        currentTournamentBank = 0;//nullify before sending to users\n        //grand rewards, not susceptible to reentry attack\n        //because of require(tournamentEndBlock <= block.number)\n        //and require(tournamentQueueSize > 0) and currentTournamentBank == 0\n        uint256 incentiveReward = _grandTournamentRewards(currentBank, warriorsData, results);\n        \n        currentTournamentBank = nextTournamentBank;\n        nextTournamentBank = 0;\n        \n        _repackToWarriorOwners(warriorsData);\n        \n        //emit event\n        TournamentFinished(warriorsData, results, currentBank);\n\n        return incentiveReward;\n    }\n    \n    function finishTournament() external TournamentNotPaused {\n        //make all the checks\n        // tournament is ready to be executed\n        require(tournamentEndBlock <= block.number);\n        // we have participants\n        require(tournamentQueueSize > 0);\n        \n        uint256 incentiveReward = _triggerFinishTournament();\n        \n        //give reward for incentive\n        safeSend(msg.sender, incentiveReward);\n    }\n    \n    \n    // @dev Remove all PVP contenders from PVP queue \n    //  and return all entrance fees to warrior owners.\n    //  NB: this is emergency method, used only in f%#^@up situation\n    function removeAllTournamentContenders() external onlyOwner TournamentPaused {\n        //remove all pvp contenders\n        uint256 length = tournamentQueueSize;\n        \n        uint256 warriorId;\n        uint256 failedBooty;\n        uint256 i;\n\n        uint256 fee;\n        uint256 bank = currentTournamentBank;\n        \n        uint256[] memory warriorsData = new uint256[](length);\n        //get tournament warriors\n        for(i = 0; i < length; i ++) {\n            warriorsData[i] = tournamentQueue[i * DATA_SIZE];\n        }\n        //notify pvp listener\n        pvpListener.tournamentFinished(warriorsData);\n        //return entrance fee to warrior owners\n     \tcurrentTournamentBank = 0;\n        tournamentQueueSize = 0;\n\n        for(i = length - 1; i >= 0; i --) {\n            //return entrance fee\n            warriorId = CryptoUtils._unpackWarriorId(warriorsData[i], 0);\n            //compute contender entrance fee\n\t\t\tfee = bank - (bank * 10000 / (tournamentEntranceFeeCut * (10000 - THRESHOLD) / 10000 + 10000));\n\t\t\t//return entrance fee to owner\n\t        failedBooty += sendBooty(warriorToOwner[warriorId], fee);\n\t        //subtract fee from bank, for next use\n\t        bank -= fee;\n        }\n        currentTournamentBank = bank;\n        totalBooty += failedBooty;\n    }\n}\n\ncontract BattleProvider is Tournament {\n    \n    function BattleProvider(address _pvpListener, uint256 _pvpCut, uint256 _tournamentCut, uint256 _incentiveCut, \n    uint256 _tournamentOwnersCut, uint256 _tournamentIncentiveCut) public \n    Tournament(_pvpCut, _tournamentCut, _incentiveCut, _tournamentOwnersCut, _tournamentIncentiveCut) \n    {\n        PVPListenerInterface candidateContract = PVPListenerInterface(_pvpListener);\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isPVPListener());\n        // Set the new contract address\n        pvpListener = candidateContract;\n        \n        // the creator of the contract is the initial owner\n        owner = msg.sender;\n    }\n    \n    \n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    // right BattleProvider in our setBattleProviderAddress() call.\n    function isPVPProvider() external pure returns (bool) {\n        return true;\n    }\n    \n    function setSecondsPerBlock(uint256 secs) external onlyOwner {\n        secondsPerBlock = secs;\n    }\n}\n\n\n/* warrior identity generator*/\ncontract WarriorGenerator is Pausable, SanctuaryInterface {\n    \n    CryptoWarriorCore public coreContract;\n    \n    /* LIMITS */\n    uint32[19] public parameters;/*  = [\n        uint32(10),//0_bodyColorMax3\n        uint32(10),//1_eyeshMax4\n        uint32(10),//2_mouthMax5\n        uint32(20),//3_heirMax6\n        uint32(10),//4_heirColorMax7\n        uint32(3),//5_armorMax8\n        uint32(3),//6_weaponMax9\n        uint32(3),//7_hatMax10\n        uint32(4),//8_runesMax11\n        uint32(1),//9_wingsMax12\n        uint32(10),//10_petMax13\n        uint32(6),//11_borderMax14\n        uint32(6),//12_backgroundMax15\n        uint32(10),//13_unique\n        uint32(900),//14_legendary\n        uint32(9000),//15_mythic\n        uint32(90000),//16_rare\n        uint32(900000),//17_uncommon\n        uint32(0)//18_uniqueTotal\n    ];*/\n    \n\n    function changeParameter(uint32 _paramIndex, uint32 _value) external onlyOwner {\n        CryptoUtils._changeParameter(_paramIndex, _value, parameters);\n    }\n\n    // / @dev simply a boolean to indicate this is the contract we expect to be\n    function isSanctuary() public pure returns (bool){\n        return true;\n    }\n\n    // / @dev generate new warrior identity\n    // / @param _heroIdentity Genes of warrior that invoked resurrection, if 0 => Demigod gene that signals to generate unique warrior\n    // / @param _heroLevel Level of the warrior\n    // / @_targetBlock block number from which hash will be taken\n    // / @_perkId special perk id, like MINER(1)\n    // / @return the identity that are supposed to be passed down to newly arisen warrior\n    function generateWarrior(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) \n    public returns (uint256) \n    {\n        //only core contract can call this method\n        require(msg.sender == address(coreContract));\n        \n        return _generateIdentity(_heroIdentity, _heroLevel, _targetBlock, _perkId);\n    }\n    \n    function _generateIdentity(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) internal returns(uint256){\n        \n        //get memory copy, to reduce storage read requests\n        uint32[19] memory memoryParams = parameters;\n        //generate warrior identity\n        uint256 identity = CryptoUtils.generateWarrior(_heroIdentity, _heroLevel, _targetBlock, _perkId, memoryParams);\n        \n        //validate before pushing changes to storage\n        CryptoUtils._validateIdentity(identity, memoryParams);\n        //push changes to storage\n        CryptoUtils._recordWarriorData(identity, parameters);\n        \n        return identity;\n    }\n}\n\ncontract WarriorSanctuary is WarriorGenerator {\n    uint256 internal constant SUMMONING_SICKENESS = 12 hours;\n    uint256 internal constant RITUAL_DURATION = 15 minutes;\n    /// @notice The payment required to use startRitual().\n    uint256 public ritualFee = 10 finney;\n    \n    uint256 public constant RITUAL_COMPENSATION = 2 finney;\n    \n    mapping(address => uint256) public soulCounter;\n    //\n    mapping(address => uint256) public ritualTimeBlock;\n    \n    bool public recoveryAllowed = true;\n    \n    event WarriorBurned(uint256 warriorId, address owner);\n    event RitualStarted(address owner, uint256 numberOfSouls);\n    event RitualFinished(address owner, uint256 numberOfSouls, uint256 newWarriorId);\n    \n    \n    function WarriorSanctuary(address _coreContract, uint32[] _settings) public {\n        uint256 length = _settings.length;\n        require(length == 18);\n        require(_settings[8] == 4);//check runes max\n        require(_settings[10] == 10);//check pets max\n        require(_settings[11] == 5);//check border max\n        require(_settings[12] == 6);//check background max\n        //setup parameters\n        for(uint256 i = 0; i < length; i ++) {\n            parameters[i] = _settings[i];\n        }\t\n        \n        //set core\n        CryptoWarriorCore coreCondidat = CryptoWarriorCore(_coreContract);\n        require(coreCondidat.isPVPListener());\n        coreContract = coreCondidat;\n        \n    }\n    \n    function recoverSouls(address[] owners, uint256[] souls, uint256[] blocks) external onlyOwner {\n        require(recoveryAllowed);\n        \n        uint256 length = owners.length;\n        require(length == souls.length && length == blocks.length);\n        \n        for(uint256 i = 0; i < length; i ++) {\n            soulCounter[owners[i]] = souls[i];\n            ritualTimeBlock[owners[i]] = blocks[i];\n        }\n        \n        recoveryAllowed = false;\n    }\n    \n    \n    //burn warrior\n    function burnWarrior(uint256 _warriorId) whenNotPaused external {\n        coreContract.burnWarrior(_warriorId, msg.sender);\n        \n        soulCounter[msg.sender] ++;\n        \n        WarriorBurned(_warriorId, msg.sender);\n    }\n   \n    \n    function startRitual() whenNotPaused external payable {\n        // Checks for payment.\n        require(msg.value >= ritualFee);\n        \n        uint256 souls = soulCounter[msg.sender];\n        // Check that address has at least 10 burned souls\n        require(souls >= 10);\n        //\n        //Check that no rituals are in progress\n        require(ritualTimeBlock[msg.sender] == 0);\n        \n        ritualTimeBlock[msg.sender] = RITUAL_DURATION / coreContract.secondsPerBlock() + block.number;\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 feeExcess = msg.value - ritualFee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of _isReadyToPVE check\n        // will fail\n        if (feeExcess > 0) {\n            msg.sender.transfer(feeExcess);\n        }\n        //send battle fee to beneficiary\n        coreContract.getBeneficiary().transfer(ritualFee - RITUAL_COMPENSATION);\n        \n        RitualStarted(msg.sender, souls);\n    }\n    \n    \n    //arise warrior\n    function finishRitual(address _owner) whenNotPaused external {\n        // Check ritual time is over\n        uint256 timeBlock = ritualTimeBlock[_owner];\n        require(timeBlock > 0 && timeBlock <= block.number);\n        \n        uint256 souls = soulCounter[_owner];\n        \n        require(souls >= 10);\n        \n        uint256 identity = _generateIdentity(uint256(_owner), souls, timeBlock - 1, 0);\n        \n        uint256 warriorId = coreContract.ariseWarrior(identity, _owner, block.number + (SUMMONING_SICKENESS / coreContract.secondsPerBlock()));\n    \n        soulCounter[_owner] = 0;\n        ritualTimeBlock[_owner] = 0;\n        //send compensation\n        msg.sender.transfer(RITUAL_COMPENSATION);\n        \n        RitualFinished(_owner, 10, warriorId);\n    }\n    \n    function setRitualFee(uint256 _pveRitualFee) external onlyOwner {\n        require(_pveRitualFee > RITUAL_COMPENSATION);\n        ritualFee = _pveRitualFee;\n    }\n}\n\ncontract AuctionBase {\n\tuint256 public constant PRICE_CHANGE_TIME_STEP = 15 minutes;\n    //\n    struct Auction{\n        address seller;\n        uint128 startingPrice;\n        uint128 endingPrice;\n        uint64 duration;\n        uint64 startedAt;\n    }\n    mapping (uint256 => Auction) internal tokenIdToAuction;\n    uint256 public ownerCut;\n    ERC721 public nonFungibleContract;\n\n    event AuctionCreated(uint256 tokenId, address seller, uint256 startingPrice);\n\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner, address seller);\n\n    event AuctionCancelled(uint256 tokenId, address seller);\n\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool){\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n    }\n\n    function _escrow(address _owner, uint256 _tokenId) internal{\n        nonFungibleContract.transferFrom(_owner, address(this), _tokenId);\n    }\n\n    function _transfer(address _receiver, uint256 _tokenId) internal{\n        nonFungibleContract.transfer(_receiver, _tokenId);\n    }\n\n    function _addAuction(uint256 _tokenId, Auction _auction) internal{\n        require(_auction.duration >= 1 minutes);\n        \n        tokenIdToAuction[_tokenId] = _auction;\n        \n        AuctionCreated(uint256(_tokenId), _auction.seller, _auction.startingPrice);\n    }\n\n    function _cancelAuction(uint256 _tokenId, address _seller) internal{\n        _removeAuction(_tokenId);\n        \n        _transfer(_seller, _tokenId);\n        \n        AuctionCancelled(_tokenId, _seller);\n    }\n\n    function _bid(uint256 _tokenId, uint256 _bidAmount) internal returns (uint256){\n        \n        Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        uint256 price = _currentPrice(auction);\n        \n        require(_bidAmount >= price);\n        \n        address seller = auction.seller;\n        \n        _removeAuction(_tokenId);\n        \n        if (price > 0) {\n            uint256 auctioneerCut = _computeCut(price);\n            uint256 sellerProceeds = price - auctioneerCut;\n            seller.transfer(sellerProceeds);\n            nonFungibleContract.getBeneficiary().transfer(auctioneerCut);\n        }\n        \n        uint256 bidExcess = _bidAmount - price;\n        \n        msg.sender.transfer(bidExcess);\n        \n        AuctionSuccessful(_tokenId, price, msg.sender, seller);\n        \n        return price;\n    }\n\n    function _removeAuction(uint256 _tokenId) internal{\n        delete tokenIdToAuction[_tokenId];\n    }\n\n    function _isOnAuction(Auction storage _auction) internal view returns (bool){\n        return (_auction.startedAt > 0);\n    }\n\n    function _currentPrice(Auction storage _auction)\n        internal\n        view\n        returns (uint256){\n        uint256 secondsPassed = 0;\n        \n        if (now > _auction.startedAt) {\n            secondsPassed = now - _auction.startedAt;\n        }\n        \n        return _computeCurrentPrice(_auction.startingPrice,\n            _auction.endingPrice,\n            _auction.duration,\n            secondsPassed);\n    }\n    \n    function _computeCurrentPrice(uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        uint256 _secondsPassed)\n        internal\n        pure\n        returns (uint256){\n        if (_secondsPassed >= _duration) {\n            return _endingPrice;\n        } else {\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\n            \n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed / PRICE_CHANGE_TIME_STEP * PRICE_CHANGE_TIME_STEP) / int256(_duration);\n            \n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\n            \n            return uint256(currentPrice);\n        }\n    }\n\n    function _computeCut(uint256 _price) internal view returns (uint256){\n        \n        return _price * ownerCut / 10000;\n    }\n}\n\ncontract SaleClockAuction is Pausable, AuctionBase {\n    \n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9f40b779);\n    \n    bool public isSaleClockAuction = true;\n    uint256 public minerSaleCount;\n    uint256[5] public lastMinerSalePrices;\n\n    function SaleClockAuction(address _nftAddress, uint256 _cut) public{\n        require(_cut <= 10000);\n        ownerCut = _cut;\n        ERC721 candidateContract = ERC721(_nftAddress);\n        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n        require(candidateContract.getBeneficiary() != address(0));\n        \n        nonFungibleContract = candidateContract;\n    }\n\n    function cancelAuction(uint256 _tokenId)\n        external{\n        \n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        address seller = auction.seller;\n        \n        require(msg.sender == seller);\n        \n        _cancelAuction(_tokenId, seller);\n    }\n\n    function cancelAuctionWhenPaused(uint256 _tokenId)\n        whenPaused\n        onlyOwner\n        external{\n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        _cancelAuction(_tokenId, auction.seller);\n    }\n\n    function getCurrentPrice(uint256 _tokenId)\n        external\n        view\n        returns (uint256){\n        \n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        return _currentPrice(auction);\n    }\n    \n    function createAuction(uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller)\n        whenNotPaused\n        external{\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n        require(msg.sender == address(nonFungibleContract));\n        _escrow(_seller, _tokenId);\n        \n        AuctionBase.Auction memory auction = Auction(_seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now));\n        \n        _addAuction(_tokenId, auction);\n    }\n    \n    function bid(uint256 _tokenId)\n        whenNotPaused\n        external\n        payable{\n        \n        address seller = tokenIdToAuction[_tokenId].seller;\n        \n        uint256 price = _bid(_tokenId, msg.value);\n        \n        _transfer(msg.sender, _tokenId);\n        \n        if (seller == nonFungibleContract.getBeneficiary()) {\n            lastMinerSalePrices[minerSaleCount % 5] = price;\n            minerSaleCount++;\n        }\n    }\n\n    function averageMinerSalePrice() external view returns (uint256){\n        uint256 sum = 0;\n        for (uint256 i = 0; i < 5; i++){\n            sum += lastMinerSalePrices[i];\n        }\n        return sum / 5;\n    }\n    \n    /**getAuctionsById returns packed actions data\n     * @param tokenIds ids of tokens, whose auction's must be active \n     * @return auctionData as uint256 array\n     * @return stepSize number of fields describing auction \n     */\n    function getAuctionsById(uint32[] tokenIds) external view returns(uint256[] memory auctionData, uint32 stepSize) {\n        stepSize = 6;\n        auctionData = new uint256[](tokenIds.length * stepSize);\n        \n        uint32 tokenId;\n        for(uint32 i = 0; i < tokenIds.length; i ++) {\n            tokenId = tokenIds[i];\n            AuctionBase.Auction storage auction = tokenIdToAuction[tokenId];\n            require(_isOnAuction(auction));\n            _setTokenData(auctionData, auction, tokenId, i * stepSize);\n        }\n    }\n    \n    /**getAuctions returns packed actions data\n     * @param fromIndex warrior index from global warrior storage (aka warriorId)\n     * @param count Number of auction's to find, if count == 0, then exact warriorId(fromIndex) will be searched\n     * @return auctionData as uint256 array\n     * @return stepSize number of fields describing auction \n     */\n    function getAuctions(uint32 fromIndex, uint32 count) external view returns(uint256[] memory auctionData, uint32 stepSize) {\n        stepSize = 6;\n        if (count == 0) {\n            AuctionBase.Auction storage auction = tokenIdToAuction[fromIndex];\n\t        \trequire(_isOnAuction(auction));\n\t        \tauctionData = new uint256[](1 * stepSize);\n\t        \t_setTokenData(auctionData, auction, fromIndex, count);\n\t        \treturn (auctionData, stepSize);\n        } else {\n            uint256 totalWarriors = nonFungibleContract.totalSupply();\n\t        if (totalWarriors == 0) {\n\t            // Return an empty array\n\t            return (new uint256[](0), stepSize);\n\t        } else {\n\t\n\t            uint32 totalSize = 0;\n\t            uint32 tokenId;\n\t            uint32 size = 0;\n\t\t\t\tauctionData = new uint256[](count * stepSize);\n\t            for (tokenId = 0; tokenId < totalWarriors && size < count; tokenId++) {\n\t                AuctionBase.Auction storage auction1 = tokenIdToAuction[tokenId];\n\t        \n\t\t        \t\tif (_isOnAuction(auction1)) {\n\t\t        \t\t    totalSize ++;\n\t\t        \t\t    if (totalSize > fromIndex) {\n\t\t        \t\t        _setTokenData(auctionData, auction1, tokenId, size++ * stepSize);//warriorId;\n\t\t        \t\t    }\n\t\t        \t\t}\n\t            }\n\t            \n\t            if (size < count) {\n\t                size *= stepSize;\n\t                uint256[] memory repack = new uint256[](size);\n\t                for(tokenId = 0; tokenId < size; tokenId++) {\n\t                    repack[tokenId] = auctionData[tokenId];\n\t                }\n\t                return (repack, stepSize);\n\t            }\n\t\n\t            return (auctionData, stepSize);\n\t        }\n        }\n    }\n    \n    // @dev Returns auction info for an NFT on auction.\n    // @param _tokenId - ID of NFT on auction.\n    function getAuction(uint256 _tokenId) external view returns(\n        address seller,\n        uint256 startingPrice,\n        uint256 endingPrice,\n        uint256 duration,\n        uint256 startedAt\n        ){\n        \n        Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        return (auction.seller,\n            auction.startingPrice,\n            auction.endingPrice,\n            auction.duration,\n            auction.startedAt);\n    }\n    \n    //pack NFT data into specified array\n    function _setTokenData(uint256[] memory auctionData, \n        AuctionBase.Auction storage auction, uint32 tokenId, uint32 index\n    ) internal view {\n        auctionData[index] = uint256(tokenId);//0\n        auctionData[index + 1] = uint256(auction.seller);//1\n        auctionData[index + 2] = uint256(auction.startingPrice);//2\n        auctionData[index + 3] = uint256(auction.endingPrice);//3\n        auctionData[index + 4] = uint256(auction.duration);//4\n        auctionData[index + 5] = uint256(auction.startedAt);//5\n    }\n    \n}",
  "bytecode": "606060409081526003805460a060020a60ff021916905560c090519081016040908152600a8252601e6020830152603c90820152606460608201526096608082015260fa60a082015262000058906004906006620000e1565b50600f600555662386f26fc10000600d556011805460ff1916600117905534156200008257600080fd5b6003805460018054600160a060020a033316600160a060020a0319918216811790925560a060020a60ff0219909216740100000000000000000000000000000000000000001782168117909255600280549091169091179055620001ab565b600183019183908215620001725791602002820160005b838211156200013e57835183826101000a81548163ffffffff021916908363ffffffff1602179055509260200192600401602081600301049283019260010302620000f8565b8015620001705782816101000a81549063ffffffff02191690556004016020816003010492830192600103026200013e565b505b506200018092915062000184565b5090565b620001a891905b808211156200018057805463ffffffff191681556001016200018b565b90565b613f7780620001bb6000396000f3006060604052600436106103285763ffffffff60e060020a6000350416623ead5f811461032f57806301ffc9a71461034557806306fdde03146103915780630763b78b1461041b578063090d23b914610443578063095ea7b31461046257806311196cc214610484578063115a43e9146104d357806318160ddd1461054457806319d0f54d146105575780631c0888971461056a5780632200cdec1461057d57806323b872dd1461059357806329372ad0146105bb5780632b58e2021461060a5780632f745c591461062f5780633d7d3f5a146106515780633f4ba83a1461067057806340a4437e1461068357806345d6c9db146106a25780634dbdb0fd146106b55780635478786c146106c057806355cc4e57146106d35780635604af49146106f2578063565a2e2c146107215780635663896e146107345780635ae82dfd1461074a5780635b229ae41461076f5780635c975abb1461079e5780635f689fed146107b157806361d3ee95146107bc5780636352211e146107db57806363fd91dc146107f15780636af04a57146108355780636ed84231146108485780636f34a7ff1461085b5780636fbde40d1461086e578063704b6c021461088d578063709eaa93146108ac57806370a08231146108bf57806371587988146108de5780637637da03146108fd5780637822ed49146109105780637a7d49371461092357806382bd5a71146109365780638456cb591461094c5780638462151c1461095f578063856dc78e1461097e578063879a6f7a146109f75780638aabff0614610a2157806395d89b4114610a375780639610f0e614610a4a57806396b01c3714610a5d5780639a49eab514610a73578063a49062d414610a86578063a63234e014610a99578063a9059cbb14610aac578063af791df214610ace578063b639c9ec14610ae1578063c0e9132014610b03578063cef6a39a14610b21578063d7d3c4d514610b34578063dfba3be114610b4a578063e4d9d21214610b9b578063e6cbe35114610bae578063e92f9c1d14610bc1578063f105e23b14610bda578063f6ea625214610bed578063f80d9e5814610c00578063f94f691014610c13578063fc6f946814610c26575b600080fd5b005b341561033a57600080fd5b61032d600435610c39565b341561035057600080fd5b61037d7fffffffff0000000000000000000000000000000000000000000000000000000060043516610c6c565b604051901515815260200160405180910390f35b341561039c57600080fd5b6103a4610ebf565b60405160208082528190810183818151815260200191508051906020019080838360005b838110156103e05780820151838201526020016103c8565b50505050905090810190601f16801561040d5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561042657600080fd5b610431600435610ef6565b60405190815260200160405180910390f35b341561044e57600080fd5b61032d600160a060020a0360043516610f0b565b341561046d57600080fd5b61032d600160a060020a0360043516602435610f5d565b341561048f57600080fd5b61032d600460248135818101908301358060208181020160405190810160405280939291908181526020018383602002808284375094965061102395505050505050565b34156104de57600080fd5b6104f1600480356024810191013561104a565b60405160208082528190810183818151815260200191508051906020019060200280838360005b83811015610530578082015183820152602001610518565b505050509050019250505060405180910390f35b341561054f57600080fd5b6104316110e9565b341561056257600080fd5b61037d6110f0565b341561057557600080fd5b6104316110f9565b341561058857600080fd5b61032d600435611100565b341561059e57600080fd5b61032d600160a060020a03600435811690602435166044356111c4565b34156105c657600080fd5b6105d1600435611287565b60405180878152602001868152602001858152602001848152602001838152602001828152602001965050505050505060405180910390f35b341561061557600080fd5b6104f1600160a060020a036004351660243560443561130b565b341561063a57600080fd5b610431600160a060020a03600435166024356113e0565b341561065c57600080fd5b61032d60043560243560443560643561142e565b341561067b57600080fd5b61032d611536565b341561068e57600080fd5b61032d600160a060020a03600435166115ce565b34156106ad57600080fd5b61043161167d565b61032d600435611682565b34156106cb57600080fd5b6104316117e7565b34156106de57600080fd5b61032d600160a060020a03600435166117ec565b34156106fd57600080fd5b61070561183e565b604051600160a060020a03909116815260200160405180910390f35b341561072c57600080fd5b61070561184d565b341561073f57600080fd5b61032d60043561185c565b341561075557600080fd5b610431600435600160a060020a03602435166044356118b0565b341561077a57600080fd5b6107856004356118fe565b60405163ffffffff909116815260200160405180910390f35b34156107a957600080fd5b61037d61192b565b61032d60043561193b565b34156107c757600080fd5b61032d600160a060020a0360043516611ab4565b34156107e657600080fd5b610705600435611b63565b61032d6004602481358181019083013580602081810201604051908101604052809392919081815260200183836020028082843750949650611b9095505050505050565b341561084057600080fd5b610705611cdb565b341561085357600080fd5b610431611cea565b341561086657600080fd5b610705611cef565b341561087957600080fd5b61032d600160a060020a0360043516611cfe565b341561089857600080fd5b61032d600160a060020a0360043516611dad565b34156108b757600080fd5b610431611e1a565b34156108ca57600080fd5b610431600160a060020a0360043516611e20565b34156108e957600080fd5b61032d600160a060020a0360043516611e3b565b341561090857600080fd5b610431611ec9565b341561091b57600080fd5b610705611ed5565b341561092e57600080fd5b610431611ee4565b341561094157600080fd5b610705600435611eea565b341561095757600080fd5b61032d611f05565b341561096a57600080fd5b6104f1600160a060020a0360043516611f91565b341561098957600080fd5b61099c6004803560248101910135612014565b6040518080602001838152602001828103825284818151815260200191508051906020019060200280838360005b838110156109e25780820151838201526020016109ca565b50505050905001935050505060405180910390f35b3415610a0257600080fd5b61032d602460048035828101929082013591813591820191013561209b565b3415610a2c57600080fd5b6104316004356121bb565b3415610a4257600080fd5b6103a46121ea565b3415610a5557600080fd5b610431612221565b3415610a6857600080fd5b610705600435612227565b3415610a7e57600080fd5b610431612242565b3415610a9157600080fd5b610431612248565b3415610aa457600080fd5b61070561224d565b3415610ab757600080fd5b61032d600160a060020a036004351660243561225c565b3415610ad957600080fd5b61032d612320565b3415610aec57600080fd5b61032d600435600160a060020a0360243516612347565b3415610b0e57600080fd5b61032d6004803560248101910135612418565b3415610b2c57600080fd5b61032d61258f565b3415610b3f57600080fd5b61032d600435612733565b3415610b5557600080fd5b61032d600460248135818101908301358060208181020160405190810160405280939291908181526020018383602002808284375094965050933593506127a592505050565b3415610ba657600080fd5b61037d6127ca565b3415610bb957600080fd5b6107056127cf565b3415610bcc57600080fd5b61099c6004356024356127de565b3415610be557600080fd5b610431612875565b3415610bf857600080fd5b610431612880565b3415610c0b57600080fd5b61043161288b565b3415610c1e57600080fd5b610431612890565b3415610c3157600080fd5b610705612895565b60015433600160a060020a03908116911614610c5457600080fd5b66071afd498d00008111610c6757600080fd5b600d55565b60006040517f737570706f727473496e7465726661636528627974657334290000000000000081526019016040518091039020600160e060020a03191682600160e060020a0319161480610eb957506040517f746f6b656e734f664f776e657228616464726573732900000000000000000000815260160160405180910390206040517f7472616e7366657246726f6d28616464726573732c616464726573732c75696e81527f7432353629000000000000000000000000000000000000000000000000000000602082015260250160405180910390206040517f7472616e7366657228616464726573732c75696e743235362900000000000000815260190160405180910390206040517f617070726f766528616464726573732c75696e74323536290000000000000000815260180160405180910390206040517f6f776e65724f662875696e743235362900000000000000000000000000000000815260100160405180910390206040517f62616c616e63654f662861646472657373290000000000000000000000000000815260120160405180910390206040517f746f74616c537570706c792829000000000000000000000000000000000000008152600d0160405180910390206040517f73796d626f6c2829000000000000000000000000000000000000000000000000815260080160405180910390206040517f6e616d6528290000000000000000000000000000000000000000000000000000815260060160405180910390201818181818181818600160e060020a03191682600160e060020a031916145b92915050565b60408051908101604052600e81527f43727970746f57617272696f7273000000000000000000000000000000000000602082015281565b6000610384610f04836128a4565b0292915050565b60025433600160a060020a03908116911614610f2657600080fd5b600160a060020a0381161515610f3b57600080fd5b60028054600160a060020a031916600160a060020a0392909216919091179055565b60035460a060020a900460ff1615610f7457600080fd5b610f7e33826128b1565b1515610f8957600080fd5b6000600682815481101515610f9a57fe5b600091825260209091206002909102016001015460c060020a900463ffffffff1614610fc557600080fd5b610fcf81836128eb565b7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925338383604051600160a060020a039384168152919092166020820152604080820192909252606001905180910390a15050565b600f5433600160a060020a0390811691161461103e57600080fd5b61104781612919565b50565b611052613e76565b816000816040518059106110635750595b90808252806020026020018201604052509250600090505b818110156110e1576007600086868481811061109357fe5b6020908102929092013583525081019190915260400160002054600160a060020a03168382815181106110c257fe5b600160a060020a0390921660209283029091019091015260010161107b565b505092915050565b6006545b90565b60115460ff1681565b6201518081565b60035460009060a060020a900460ff161561111a57600080fd5b600680548390811061112857fe5b600091825260209091206002909102018054909150151561114857600080fd5b60018181015460c060020a900463ffffffff161461116557600080fd5b600181015467ffffffffffffffff4381169116111561118357600080fd5b61118c82612953565b600160a060020a033316600066071afd498d0000604051600060405180830381858888f1935050505015156111c057600080fd5b5050565b60035460a060020a900460ff16156111db57600080fd5b600160a060020a03821615156111f057600080fd5b30600160a060020a031682600160a060020a03161415151561121157600080fd5b61121b3382612af0565b151561122657600080fd5b61123083826128b1565b151561123b57600080fd5b600060068281548110151561124c57fe5b600091825260209091206002909102016001015460c060020a900463ffffffff161461127757600080fd5b611282838383612b10565b505050565b60008060008060008060006006888154811015156112a157fe5b600091825260209091206002909102018054600190910154909967ffffffffffffffff8083169a50680100000000000000008304169850608060020a8204600790810b900b975063ffffffff60c060020a83048116975060e060020a909204909116945092505050565b611313613e76565b60008060008061132288611e20565b871061132d57600080fd5b600160a060020a0388166000908152600a602090815260408083206008909252909120549094509250868303869010156113695786830361136b565b855b91508160405180591061137b5750595b90808252806020026020018201604052509450600090505b818110156113d557838188018154811015156113ab57fe5b9060005260206000209001548582815181106113c357fe5b60209081029091010152600101611393565b505050509392505050565b60006113eb83611e20565b82106113f657600080fd5b600160a060020a0383166000908152600a6020526040902080548390811061141a57fe5b906000526020600020900154905092915050565b60035460a060020a900460ff161561144557600080fd5b61144f3385612b91565b151561145a57600080fd5b600060068581548110151561146b57fe5b600091825260209091206002909102016001015460c060020a900463ffffffff161461149657600080fd5b600c546114ad908590600160a060020a03166128eb565b600c54600160a060020a03166327ebe40a858585853360405160e060020a63ffffffff88160281526004810195909552602485019390935260448401919091526064830152600160a060020a0316608482015260a401600060405180830381600087803b151561151c57600080fd5b6102c65a03f1151561152d57600080fd5b50505050505050565b60015433600160a060020a0390811691161461155157600080fd5b60035460a060020a900460ff16151561156957600080fd5b600c54600160a060020a0316151561158057600080fd5b600e54600160a060020a0316151561159757600080fd5b600f54600160a060020a031615156115ae57600080fd5b600054600160a060020a0316156115c457600080fd5b6115cc612bea565b565b60015460009033600160a060020a039081169116146115ec57600080fd5b5080600160a060020a03811663f773ab806000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561163457600080fd5b6102c65a03f1151561164557600080fd5b50505060405180519050151561165a57600080fd5b600f8054600160a060020a031916600160a060020a039290921691909117905550565b600281565b6003546000908190819060a060020a900460ff16156116a057600080fd5b6116aa3385612b91565b15156116b557600080fd5b60068054859081106116c357fe5b60009182526020909120600290910201805490935015156116e357600080fd5b600183015460c060020a900463ffffffff16156116ff57600080fd5b600f546001840154600160a060020a039091169063637492259068010000000000000000900467ffffffffffffffff1660006040516020015260405160e060020a63ffffffff841602815267ffffffffffffffff9091166004820152602401602060405180830381600087803b151561177757600080fd5b6102c65a03f1151561178857600080fd5b505050604051805192505034829010156117a157600080fd5b6117ab8483612c3d565b5034819003600160a060020a03331681156108fc0282604051600060405180830381858888f1935050505015156117e157600080fd5b50505050565b600081565b60015433600160a060020a0390811691161461180757600080fd5b600160a060020a038116151561181c57600080fd5b60038054600160a060020a031916600160a060020a0392909216919091179055565b600f54600160a060020a031681565b600254600160a060020a031690565b60035433600160a060020a0390811691161480611887575060015433600160a060020a039081169116145b806118a0575060025433600160a060020a039081169116145b15156118ab57600080fd5b600555565b60035460009060a060020a900460ff16156118ca57600080fd5b600e5433600160a060020a039081169116146118e557600080fd5b6118f6848484600a60646000612d0e565b949350505050565b6004816006811061190b57fe5b60089182820401919006600402915054906101000a900463ffffffff1681565b60035460a060020a900460ff1681565b600354600090819060a060020a900460ff161561195757600080fd5b600d5434101561196657600080fd5b6119703384612b91565b151561197b57600080fd5b600680548490811061198957fe5b60009182526020909120600290910201805490925015156119a957600080fd5b611a268260c060405190810160409081528254825260019092015467ffffffffffffffff80821660208401526801000000000000000082041692820192909252608060020a8204600790810b810b900b606082015263ffffffff60c060020a83048116608083015260e060020a90920490911660a0820152612ee6565b1515611a3157600080fd5b611a3a83612f70565b50600d543403600160a060020a03331681156108fc0282604051600060405180830381858888f193505050501515611a7157600080fd5b600254600d54600160a060020a039091169066071afd498cffff190180156108fc0290604051600060405180830381858888f19350505050151561128257600080fd5b60015460009033600160a060020a03908116911614611ad257600080fd5b5080600160a060020a038116639711f20d6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515611b1a57600080fd5b6102c65a03f11515611b2b57600080fd5b505050604051805190501515611b4057600080fd5b600e8054600160a060020a031916600160a060020a039290921691909117905550565b6006546000908210611b7457600080fd5b50600090815260076020526040902054600160a060020a031690565b600f5460009081908190600160a060020a03166324abfc0282604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515611bde57600080fd5b6102c65a03f11515611bef57600080fd5b50505060405180519350503483901015611c0857600080fd5b6005845114611c1657600080fd5b611c203385613088565b1515611c2b57600080fd5b611c34846130df565b1515611c3f57600080fd5b600091505b6005821015611c9b57611c856006858481518110611c5e57fe5b9060200190602002015181548110611c7257fe5b9060005260206000209060020201613160565b1515611c9057600080fd5b600190910190611c44565b611ca584846131a0565b5034829003600160a060020a03331681156108fc0282604051600060405180830381858888f1935050505015156117e157600080fd5b600054600160a060020a031681565b600381565b600e54600160a060020a031681565b60015460009033600160a060020a03908116911614611d1c57600080fd5b5080600160a060020a0381166385b861886000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515611d6457600080fd5b6102c65a03f11515611d7557600080fd5b505050604051805190501515611d8a57600080fd5b600c8054600160a060020a031916600160a060020a039290921691909117905550565b60015433600160a060020a0390811691161480611dd8575060025433600160a060020a039081169116145b1515611de357600080fd5b600160a060020a0381161515611df857600080fd5b60018054600160a060020a031916600160a060020a0392909216919091179055565b60105481565b600160a060020a031660009081526008602052604090205490565b60015433600160a060020a03908116911614611e5657600080fd5b60035460a060020a900460ff161515611e6e57600080fd5b60008054600160a060020a031916600160a060020a0383161790557f450db8da6efbe9c22f2347f7c2021231df1fc58d3ae9a2fa75d39fa44619930581604051600160a060020a03909116815260200160405180910390a150565b67016345785d8a000081565b600254600160a060020a031681565b60055481565b600960205260009081526040902054600160a060020a031681565b60035433600160a060020a0390811691161480611f30575060015433600160a060020a039081169116145b80611f49575060025433600160a060020a039081169116145b1515611f5457600080fd5b60035460a060020a900460ff1615611f6b57600080fd5b6003805474ff0000000000000000000000000000000000000000191660a060020a179055565b611f99613e76565b600a600083600160a060020a0316600160a060020a0316815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561200857602002820191906000526020600020905b815481526020019060010190808311611ff4575b50505050509050919050565b61201c613e76565b600660008382026040518059106120305750595b90808252806020026020018201604052509250600090505b838110156120935761208b83600687878581811061206257fe5b9050602002013581548110151561207557fe5b90600052602060002090600202018484026132e5565b600101612048565b509250929050565b600154600090819033600160a060020a039081169116146120bb57600080fd5b60035460a060020a900460ff1615156120d357600080fd5b60115460ff1615156120e457600080fd5b8291506005850482146120f657600080fd5b5060005b818110156121b3576121aa86866005840281811061211457fe5b90506020020135858584818110151561212957fe5b90506020020135600160a060020a0316888885600502600101818110151561214d57fe5b90506020020135898986600502600201818110151561216857fe5b905060200201358a8a87600502600301818110151561218357fe5b905060200201358b8b88600502600401818110151561219e57fe5b90506020020135612d0e565b506001016120fa565b505050505050565b6000806121c7836128a4565b9050601981106121dc576212750091506121e4565b80610e100291505b50919050565b60408051908101604052600281527f4357000000000000000000000000000000000000000000000000000000000000602082015281565b600d5481565b600760205260009081526040902054600160a060020a031681565b610b4081565b601981565b600354600160a060020a031681565b60035460a060020a900460ff161561227357600080fd5b600160a060020a038216151561228857600080fd5b30600160a060020a031682600160a060020a0316141515156122a957600080fd5b600c54600160a060020a03838116911614156122c457600080fd5b6122ce33826128b1565b15156122d957600080fd5b60006006828154811015156122ea57fe5b600091825260209091206002909102016001015460c060020a900463ffffffff161461231557600080fd5b6111c0338383612b10565b60015433600160a060020a0390811691161461233b57600080fd5b6011805460ff19169055565b60035460009060a060020a900460ff161561236157600080fd5b600e5433600160a060020a0390811691161461237c57600080fd5b6123868284612b91565b151561239157600080fd5b600680548490811061239f57fe5b60009182526020909120600290910201805490915015156123bf57600080fd5b600181015460c060020a900463ffffffff16156123db57600080fd5b60036123ea82600001546133e4565b11156123f557600080fd5b600161240482600001546133f9565b1061240e57600080fd5b6112828284613430565b60035460009081908190819060a060020a900460ff161561243857600080fd5b849350601484111561244957600080fd5b439250612482868680806020026020016040519081016040528093929190818152602001838360200280828437506130df945050505050565b151561248d57600080fd5b600091505b838210156125215760068686848181106124a857fe5b905060200201358154811015156124bb57fe5b9060005260206000209060020201905080600001546000141580156124f0575060018181015460c060020a900463ffffffff16145b801561250b5750600181015467ffffffffffffffff16839011155b151561251657600080fd5b600190910190612492565b600091505b838210156125545761254986868481811061253d57fe5b90506020020135612953565b600190910190612526565b600160a060020a03331666071afd498d0000850280156108fc0290604051600060405180830381858888f1935050505015156121b357600080fd5b600354600090819033600160a060020a039081169116146125af57600080fd5b601054610b4090106125c057600080fd5b60108054600190810191829055600e54600160a060020a031691639729ec2691600090600019430190826040516020015260405160e060020a63ffffffff87160281526004810194909452602484019290925260448301526064820152608401602060405180830381600087803b151561263957600080fd5b6102c65a03f1151561264a57600080fd5b505050604051805160025490935061267491508390600160a060020a03166000600a606482612d0e565b600c5490915061268e908290600160a060020a03166128eb565b600c54600160a060020a03166327ebe40a826126a8613498565b60025466b1a2bc2ec50000906201518090600160a060020a031660405160e060020a63ffffffff88160281526004810195909552602485019390935260448401919091526064830152600160a060020a0316608482015260a401600060405180830381600087803b151561271b57600080fd5b6102c65a03f1151561272c57600080fd5b5050505050565b600f5460009033600160a060020a0390811691161461275157600080fd5b600680548390811061275f57fe5b60009182526020909120600291820201600181015490925060c060020a900463ffffffff161461278e57600080fd5b600101805460c060020a63ffffffff021916905550565b600f5433600160a060020a039081169116146127c057600080fd5b6111c08282613548565b600190565b600c54600160a060020a031681565b6127e6613e76565b6006805460009081908690038590101561280557600654869003612807565b845b91508282026040518059106128195750595b90808252806020026020018201604052509350600090505b8181101561286c5761286484600683890181548110151561284e57fe5b90600052602060002090600202018584026132e5565b600101612831565b50509250929050565b66071afd498d000081565b66b1a2bc2ec5000081565b600181565b600a81565b600154600160a060020a031681565b6000600a825b0492915050565b6000600160a060020a038316158015906128e45750600082815260076020526040902054600160a060020a038481169116145b9392505050565b6000918252600960205260409091208054600160a060020a031916600160a060020a03909216919091179055565b60008082519150600090505b818110156112825761294b83828151811061293c57fe5b9060200190602002015161359b565b600101612925565b60008060008060068581548110151561296857fe5b6000918252602090912060029091020160018101805460c060020a63ffffffff0219169055600554815491955043916129a090613600565b60018701546129c49068010000000000000000900467ffffffffffffffff166121bb565b8115156129cd57fe5b048115156129d757fe5b60018701805467ffffffffffffffff1916929091049290920167ffffffffffffffff16179081905560e060020a900463ffffffff1692506005831015612a46576001848101805463ffffffff60e060020a808304821690940116909202600160e060020a039092169190911790555b600085815260076020526040902054600160a060020a03169150612a6a8285613625565b60018501549091507f28391d64a7259a49ae308a9637b1bc7c9598bc70986c1be7dc76bfeca776eeb69083908590889067ffffffffffffffff1685604051600160a060020a039095168552602085019390935260408085019290925267ffffffffffffffff166060840152608083019190915260a0909101905180910390a15050505050565b600090815260096020526040902054600160a060020a0391821691161490565b600160a060020a03831615612b3257612b2881613717565b612b328382613752565b612b3c828261386f565b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef838383604051600160a060020a039384168152919092166020820152604080820192909252606001905180910390a1505050565b6000600160a060020a03831615801590612bc45750600082815260076020526040902054600160a060020a038481169116145b80156128e4575050600090815260096020526040902054600160a060020a031615919050565b60015433600160a060020a03908116911614612c0557600080fd5b60035460a060020a900460ff161515612c1d57600080fd5b6003805474ff000000000000000000000000000000000000000019169055565b600080600684815481101515612c4f57fe5b90600052602060002090600202019150612c6984836138ec565b600f54909150600160a060020a031663a99306e784338460405160e060020a63ffffffff8616028152600160a060020a03909216600483015260248201526044016000604051808303818588803b1515612cc257600080fd5b6125ee5a03f11515612cd357600080fd5b50505050600191909101805460c060020a63ffffffff0219167802000000000000000000000000000000000000000000000000179055505050565b6000612d18613e88565b600060c060405190810160409081528a825267ffffffffffffffff808a166020840152881690820152600786900b60608201526000608082015263ffffffff851660a082015260068054919350600191808301612d758382613ebd565b6000928352602090922085916002020181518155602082015160018201805467ffffffffffffffff191667ffffffffffffffff9290921691909117905560408201518160010160086101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555060608201518160010160106101000a81548167ffffffffffffffff021916908360070b67ffffffffffffffff16021790555060808201518160010160186101000a81548163ffffffff021916908363ffffffff16021790555060a08201516001919091018054600160e060020a031660e060020a63ffffffff938416021790559290910392505081168114612e7557600080fd5b7f45c2f8b44389d131c5935d84d0d684b2e2ed61f439b17258ca08abaf935762a388828b6040518084600160a060020a0316600160a060020a03168152602001838152602001828152602001935050505060405180910390a1612eda60008983612b10565b98975050505050505050565b600080826080015163ffffffff16148015612f1957504367ffffffffffffffff16826020015167ffffffffffffffff1611155b8015610eb9575060048260a0015163ffffffff1660068110612f3757fe5b600891828204019190066004029054906101000a900463ffffffff1663ffffffff16826040015167ffffffffffffffff16101592915050565b6000600682815481101515612f8157fe5b600091825260209091206001600290920201908101805460c060020a63ffffffff02191660c060020a1790819055600554919250439190612fd89067ffffffffffffffff6801000000000000000090910416610ef6565b811515612fe157fe5b60018401805467ffffffffffffffff9390920493909301821667ffffffffffffffff1990911617918290557f2beb437cab0f7996c35525f60a5f33b31a35ffa1cd1222de87fabc22dc22df8191339163ffffffff60e060020a83041691869116604051600160a060020a03909416845263ffffffff909216602084015260408084019190915267ffffffffffffffff90911660608301526080909101905180910390a15050565b600080600083519150600090505b818110156130d4576130bd858583815181106130ae57fe5b90602001906020020151612b91565b15156130cc57600092506110e1565b600101613096565b506001949350505050565b60008060008084519250600090505b82811015613153578060010191505b8282101561314b5784828151811061311157fe5b9060200190602002015185828151811061312757fe5b9060200190602002015114156131405760009350613158565b6001909101906130fd565b6001016130ee565b600193505b505050919050565b600181015460009060326801000000000000000090910467ffffffffffffffff1610801590610eb95750506001015460c060020a900463ffffffff161590565b6131a8613e76565b60006131b384613928565b9150600090505b600581101561322857600360068583815181106131d357fe5b90602001906020020151815481106131e757fe5b6000918252602090912060016002909202018101805463ffffffff9390931660c060020a0260c060020a63ffffffff021990931692909217909155016131ba565b600f54600160a060020a031663f8b608a18433856040518463ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200180602001828103825283818151815260200191508051906020019060200280838360005b838110156132a657808201518382015260200161328e565b5050505090500193505050506000604051808303818588803b15156132ca57600080fd5b6125ee5a03f115156132db57600080fd5b5050505050505050565b81548382815181106132f357fe5b6020908102909101015260018083015467ffffffffffffffff1690849083018151811061331c57fe5b60209081029091010152600182015467ffffffffffffffff680100000000000000009091041683600283018151811061335157fe5b602090810290910101526001820154608060020a9004600790810b900b83600383018151811061337d57fe5b60209081029091010152600182015463ffffffff60c060020a909104168360048301815181106133a957fe5b60209081029091010152600182015463ffffffff60e060020a909104168360058301815181106133d557fe5b60209081029091010152505050565b6000612710620186a0835b068115156128aa57fe5b6000751aba4714957d300d0e549208b31adb1000000000000076010b46c6cdd6e3e0828f4db456ff0c8ea0000000000000836133ef565b61343981613717565b6134438282613752565b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef82600083604051600160a060020a039384168152919092166020820152604080820192909252606001905180910390a15050565b600c5460009081908190600160a060020a0316639b311b1782604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156134e657600080fd5b6102c65a03f115156134f757600080fd5b50505060405180519250506fffffffffffffffffffffffffffffffff8216821461352057600080fd5b506002600382020467016345785d8a0000811015610eb9575067016345785d8a000092915050565b60005b818110156112825761357961357484838151811061356557fe5b906020019060200201516139c6565b6139e6565b61359361358e84836001018151811061356557fe5b613ac6565b60020161354b565b60005b60058110156111c057600060066135b58484613c06565b815481106135bf57fe5b6000918252602090912060016002909202018101805463ffffffff9390931660c060020a0260c060020a63ffffffff0219909316929092179091550161359e565b6000600161360d836133f9565b1461361957600161361c565b60045b60ff1692915050565b600e54815460018301546000928392600160a060020a0390911691639729ec2691906136669068010000000000000000900467ffffffffffffffff166128a4565b600187015467ffffffffffffffff16600019016000806040516020015260405160e060020a63ffffffff87160281526004810194909452602484019290925267ffffffffffffffff1660448301526064820152608401602060405180830381600087803b15156136d557600080fd5b6102c65a03f115156136e657600080fd5b5050506040518051905090506118f68185600554600c610e100281151561370957fe5b044301600a60646000612d0e565b600081815260096020526040902054600160a060020a0316156110475760009081526009602052604090208054600160a060020a0319169055565b600160a060020a03821660008181526008602090815260408083208054600019908101909155858452600783528184208054600160a060020a0319169055600b835281842054948452600a909252822080549182019291839081106137b357fe5b6000918252602080832090910154600160a060020a0388168352600a909152604090912080549192508291859081106137e857fe5b6000918252602080832090910192909255600160a060020a0387168152600a9091526040812080548490811061381a57fe5b6000918252602080832090910192909255600160a060020a0387168152600a90915260409020805490613851906000198301613ee9565b506000938452600b6020526040808520859055908452909220555050565b600160a060020a038216600081815260086020908152604080832080546001908101909155858452600783528184208054600160a060020a03191686179055938352600a9091529020805491829081016138c98382613ee9565b506000918252602080832091909101849055928152600b90925260409091205550565b805460018201546000916128e491608060020a8104600790810b900b908490879068010000000000000000900467ffffffffffffffff16613c37565b613930613e76565b60008060056040518059106139425750595b90808252806020026020018201604052509250600090505b60058110156139bf5783818151811061396f57fe5b9060200190602002015191506139a18260068481548110151561398e57fe5b90600052602060002090600202016138ec565b8382815181106139ad57fe5b6020908102909101015260010161395a565b5050919050565b600068056bc75e2d631000006c0c9f2c9cd04674edea40000000836133ef565b6000806006838154811015156139f857fe5b60009182526020909120600290910201600181015490925068010000000000000000900467ffffffffffffffff16905060fa811015613a7057600a0160fa8111613a425780613a45565b60fa5b8260010160086101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505b50600101805460c060020a63ffffffff0219608060020a808304600790810b608201900b67ffffffffffffffff160277ffffffffffffffff00000000000000000000000000000000199092169190911716905550565b600080600080600685815481101515613adb57fe5b60009182526020909120600290910201600181015490945068010000000000000000900467ffffffffffffffff16925082915060fa821015613b53576001840180546fffffffffffffffff000000000000000019166801000000000000000060059490940167ffffffffffffffff8116949094021790555b613b5c836128a4565b613b65836128a4565b11613b7257601d19613b75565b60465b6001850154608060020a9004600790810b900b0190506000811215613b9b576000613bb2565b633b9aca008113613bac5780613bb2565b633b9aca005b6001909401805460c060020a63ffffffff021960079690960b67ffffffffffffffff16608060020a0277ffffffffffffffff0000000000000000000000000000000019909116179490941690935550505050565b6000816402540be4000a826001016402540be4000a84811515613c2557fe5b06811515613c2f57fe5b049392505050565b600080613c448784613c8b565b701d6329f1c35ca4bfabb9f561000000000087026c0c9f2c9cd04674edea40000000870268056bc75e2d631000008702909201919091010191508190505095945050505050565b6000806001613c9985613d1b565b0201600a613ca685613d4e565b0201612710613cb4856133e4565b0201620186a08302016305f5e100613ccb85613d83565b02016402540be400613cdc85613db2565b020164e8d4a51000613ced85613de3565b0201655af3107a4000613cff85613e15565b0201662386f26fc10000613d1285613e4d565b02019392505050565b600073af298d050e4395d69670b12b7f410000000000007406d79f82328ea3da61e066ebb2f88a000000000000836133ef565b60007406d79f82328ea3da61e066ebb2f88a000000000000751aba4714957d300d0e549208b31adb10000000000000836133ef565b6000710b7abc627050305adf14a3d9e4000000000072047bf19673df52e37f2410011d100000000000836133ef565b600072047bf19673df52e37f2410011d1000000000007301c06a5ec5433c60ddaa16406f5a400000000000836133ef565b60007301c06a5ec5433c60ddaa16406f5a40000000000073af298d050e4395d69670b12b7f41000000000000836133ef565b600076010b46c6cdd6e3e0828f4db456ff0c8ea0000000000000766867a5a867f103b2fffa5a71fba0e7b680000000000000836133ef565b60006ec097ce7bc90715b34b9f10000000006f4b3b4ca85a86c47a098a224000000000836133ef565b60206040519081016040526000815290565b60c06040519081016040908152600080835260208301819052908201819052606082018190526080820181905260a082015290565b815481835581811511611282576002028160020283600052602060002091820191016112829190613f0d565b81548183558181151161128257600083815260209020611282918101908301613f31565b6110ed91905b80821115613f2d5760008082556001820155600201613f13565b5090565b6110ed91905b80821115613f2d5760008155600101613f375600a165627a7a723058202777df1a1f35f26798b67f166bf8567557e401f349af30ab0b68ea1fe33cdad10029"
}