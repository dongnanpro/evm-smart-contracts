{
  "address": "0x552f355ccb9b91c8fb47d9c011abad5b72ec30e9",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "GemFab",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2017-12-17\n*/\n\n// hevm: flattened sources of src/fab.sol\npragma solidity ^0.4.18;\n\n////// lib/ds-guard/lib/ds-auth/src/auth.sol\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.13; */\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    function DSAuth() public {\n        owner = msg.sender;\n        LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        LogSetAuthority(authority);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\n////// lib/ds-guard/src/guard.sol\n// guard.sol -- simple whitelist implementation of DSAuthority\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.13; */\n\n/* import \"ds-auth/auth.sol\"; */\n\ncontract DSGuardEvents {\n    event LogPermit(\n        bytes32 indexed src,\n        bytes32 indexed dst,\n        bytes32 indexed sig\n    );\n\n    event LogForbid(\n        bytes32 indexed src,\n        bytes32 indexed dst,\n        bytes32 indexed sig\n    );\n}\n\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\n    bytes32 constant public ANY = bytes32(uint(-1));\n\n    mapping (bytes32 => mapping (bytes32 => mapping (bytes32 => bool))) acl;\n\n    function canCall(\n        address src_, address dst_, bytes4 sig\n    ) public view returns (bool) {\n        var src = bytes32(src_);\n        var dst = bytes32(dst_);\n\n        return acl[src][dst][sig]\n            || acl[src][dst][ANY]\n            || acl[src][ANY][sig]\n            || acl[src][ANY][ANY]\n            || acl[ANY][dst][sig]\n            || acl[ANY][dst][ANY]\n            || acl[ANY][ANY][sig]\n            || acl[ANY][ANY][ANY];\n    }\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public auth {\n        acl[src][dst][sig] = true;\n        LogPermit(src, dst, sig);\n    }\n\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public auth {\n        acl[src][dst][sig] = false;\n        LogForbid(src, dst, sig);\n    }\n\n    function permit(address src, address dst, bytes32 sig) public {\n        permit(bytes32(src), bytes32(dst), sig);\n    }\n    function forbid(address src, address dst, bytes32 sig) public {\n        forbid(bytes32(src), bytes32(dst), sig);\n    }\n\n}\n\ncontract DSGuardFactory {\n    mapping (address => bool)  public  isGuard;\n\n    function newGuard() public returns (DSGuard guard) {\n        guard = new DSGuard();\n        guard.setOwner(msg.sender);\n        isGuard[guard] = true;\n    }\n}\n\n////// lib/ds-roles/src/roles.sol\n// roles.sol - roled based authentication\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.13; */\n\n/* import 'ds-auth/auth.sol'; */\n\ncontract DSRoles is DSAuth, DSAuthority\n{\n    mapping(address=>bool) _root_users;\n    mapping(address=>bytes32) _user_roles;\n    mapping(address=>mapping(bytes4=>bytes32)) _capability_roles;\n    mapping(address=>mapping(bytes4=>bool)) _public_capabilities;\n\n    function getUserRoles(address who)\n        public\n        view\n        returns (bytes32)\n    {\n        return _user_roles[who];\n    }\n\n    function getCapabilityRoles(address code, bytes4 sig)\n        public\n        view\n        returns (bytes32)\n    {\n        return _capability_roles[code][sig];\n    }\n\n    function isUserRoot(address who)\n        public\n        view\n        returns (bool)\n    {\n        return _root_users[who];\n    }\n\n    function isCapabilityPublic(address code, bytes4 sig)\n        public\n        view\n        returns (bool)\n    {\n        return _public_capabilities[code][sig];\n    }\n\n    function hasUserRole(address who, uint8 role)\n        public\n        view\n        returns (bool)\n    {\n        bytes32 roles = getUserRoles(who);\n        bytes32 shifted = bytes32(uint256(uint256(2) ** uint256(role)));\n        return bytes32(0) != roles & shifted;\n    }\n\n    function canCall(address caller, address code, bytes4 sig)\n        public\n        view\n        returns (bool)\n    {\n        if( isUserRoot(caller) || isCapabilityPublic(code, sig) ) {\n            return true;\n        } else {\n            var has_roles = getUserRoles(caller);\n            var needs_one_of = getCapabilityRoles(code, sig);\n            return bytes32(0) != has_roles & needs_one_of;\n        }\n    }\n\n    function BITNOT(bytes32 input) internal pure returns (bytes32 output) {\n        return (input ^ bytes32(uint(-1)));\n    }\n\n    function setRootUser(address who, bool enabled)\n        public\n        auth\n    {\n        _root_users[who] = enabled;\n    }\n\n    function setUserRole(address who, uint8 role, bool enabled)\n        public\n        auth\n    {\n        var last_roles = _user_roles[who];\n        bytes32 shifted = bytes32(uint256(uint256(2) ** uint256(role)));\n        if( enabled ) {\n            _user_roles[who] = last_roles | shifted;\n        } else {\n            _user_roles[who] = last_roles & BITNOT(shifted);\n        }\n    }\n\n    function setPublicCapability(address code, bytes4 sig, bool enabled)\n        public\n        auth\n    {\n        _public_capabilities[code][sig] = enabled;\n    }\n\n    function setRoleCapability(uint8 role, address code, bytes4 sig, bool enabled)\n        public\n        auth\n    {\n        var last_roles = _capability_roles[code][sig];\n        bytes32 shifted = bytes32(uint256(uint256(2) ** uint256(role)));\n        if( enabled ) {\n            _capability_roles[code][sig] = last_roles | shifted;\n        } else {\n            _capability_roles[code][sig] = last_roles & BITNOT(shifted);\n        }\n\n    }\n\n}\n\n////// lib/ds-spell/lib/ds-note/src/note.sol\n/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.13; */\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint              wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\n////// lib/ds-thing/lib/ds-math/src/math.sol\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.13; */\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n////// lib/ds-thing/src/thing.sol\n// thing.sol - `auth` with handy mixins. your things should be DSThings\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.13; */\n\n/* import 'ds-auth/auth.sol'; */\n/* import 'ds-note/note.sol'; */\n/* import 'ds-math/math.sol'; */\n\ncontract DSThing is DSAuth, DSNote, DSMath {\n\n    function S(string s) internal pure returns (bytes4) {\n        return bytes4(keccak256(s));\n    }\n\n}\n\n////// lib/ds-token/lib/ds-stop/src/stop.sol\n/// stop.sol -- mixin for enable/disable functionality\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.13; */\n\n/* import \"ds-auth/auth.sol\"; */\n/* import \"ds-note/note.sol\"; */\n\ncontract DSStop is DSNote, DSAuth {\n\n    bool public stopped;\n\n    modifier stoppable {\n        require(!stopped);\n        _;\n    }\n    function stop() public auth note {\n        stopped = true;\n    }\n    function start() public auth note {\n        stopped = false;\n    }\n\n}\n\n////// lib/ds-token/lib/erc20/src/erc20.sol\n/// erc20.sol -- API for the ERC20 token standard\n\n// See <https://github.com/ethereum/EIPs/issues/20>.\n\n// This file likely does not meet the threshold of originality\n// required for copyright to apply.  As a result, this is free and\n// unencumbered software belonging to the public domain.\n\n/* pragma solidity ^0.4.8; */\n\ncontract ERC20Events {\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n}\n\ncontract ERC20 is ERC20Events {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address guy) public view returns (uint);\n    function allowance(address src, address guy) public view returns (uint);\n\n    function approve(address guy, uint wad) public returns (bool);\n    function transfer(address dst, uint wad) public returns (bool);\n    function transferFrom(\n        address src, address dst, uint wad\n    ) public returns (bool);\n}\n\n////// lib/ds-token/src/base.sol\n/// base.sol -- basic ERC20 implementation\n\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.13; */\n\n/* import \"erc20/erc20.sol\"; */\n/* import \"ds-math/math.sol\"; */\n\ncontract DSTokenBase is ERC20, DSMath {\n    uint256                                            _supply;\n    mapping (address => uint256)                       _balances;\n    mapping (address => mapping (address => uint256))  _approvals;\n\n    function DSTokenBase(uint supply) public {\n        _balances[msg.sender] = supply;\n        _supply = supply;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _supply;\n    }\n    function balanceOf(address src) public view returns (uint) {\n        return _balances[src];\n    }\n    function allowance(address src, address guy) public view returns (uint) {\n        return _approvals[src][guy];\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        if (src != msg.sender) {\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        _approvals[msg.sender][guy] = wad;\n\n        Approval(msg.sender, guy, wad);\n\n        return true;\n    }\n}\n\n////// lib/ds-token/src/token.sol\n/// token.sol -- ERC20 implementation with minting and burning\n\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.13; */\n\n/* import \"ds-stop/stop.sol\"; */\n\n/* import \"./base.sol\"; */\n\ncontract DSToken is DSTokenBase(0), DSStop {\n\n    bytes32  public  symbol;\n    uint256  public  decimals = 18; // standard token precision. override to customize\n\n    function DSToken(bytes32 symbol_) public {\n        symbol = symbol_;\n    }\n\n    event Mint(address indexed guy, uint wad);\n    event Burn(address indexed guy, uint wad);\n\n    function approve(address guy) public stoppable returns (bool) {\n        return super.approve(guy, uint(-1));\n    }\n\n    function approve(address guy, uint wad) public stoppable returns (bool) {\n        return super.approve(guy, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        stoppable\n        returns (bool)\n    {\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function push(address dst, uint wad) public {\n        transferFrom(msg.sender, dst, wad);\n    }\n    function pull(address src, uint wad) public {\n        transferFrom(src, msg.sender, wad);\n    }\n    function move(address src, address dst, uint wad) public {\n        transferFrom(src, dst, wad);\n    }\n\n    function mint(uint wad) public {\n        mint(msg.sender, wad);\n    }\n    function burn(uint wad) public {\n        burn(msg.sender, wad);\n    }\n    function mint(address guy, uint wad) public auth stoppable {\n        _balances[guy] = add(_balances[guy], wad);\n        _supply = add(_supply, wad);\n        Mint(guy, wad);\n    }\n    function burn(address guy, uint wad) public auth stoppable {\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\n        }\n\n        _balances[guy] = sub(_balances[guy], wad);\n        _supply = sub(_supply, wad);\n        Burn(guy, wad);\n    }\n\n    // Optional token name\n    bytes32   public  name = \"\";\n\n    function setName(bytes32 name_) public auth {\n        name = name_;\n    }\n}\n\n////// lib/ds-value/src/value.sol\n/// value.sol - a value is a simple thing, it can be get and set\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.13; */\n\n/* import 'ds-thing/thing.sol'; */\n\ncontract DSValue is DSThing {\n    bool    has;\n    bytes32 val;\n    function peek() public view returns (bytes32, bool) {\n        return (val,has);\n    }\n    function read() public view returns (bytes32) {\n        var (wut, haz) = peek();\n        assert(haz);\n        return wut;\n    }\n    function poke(bytes32 wut) public note auth {\n        val = wut;\n        has = true;\n    }\n    function void() public note auth {  // unset the value\n        has = false;\n    }\n}\n\n////// src/vox.sol\n/// vox.sol -- target price feed\n\n// Copyright (C) 2016, 2017  Nikolai Mushegian <[email protected]>\n// Copyright (C) 2016, 2017  Daniel Brockman <[email protected]>\n// Copyright (C) 2017        Rain Break <[email protected]>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.18; */\n\n/* import \"ds-thing/thing.sol\"; */\n\ncontract SaiVox is DSThing {\n    uint256  _par;\n    uint256  _way;\n\n    uint256  public  fix;\n    uint256  public  how;\n    uint256  public  tau;\n\n    function SaiVox(uint par_) public {\n        _par = fix = par_;\n        _way = RAY;\n        tau  = era();\n    }\n\n    function era() public view returns (uint) {\n        return block.timestamp;\n    }\n\n    function mold(bytes32 param, uint val) public note auth {\n        if (param == 'way') _way = val;\n    }\n\n    // Dai Target Price (ref per dai)\n    function par() public returns (uint) {\n        prod();\n        return _par;\n    }\n    function way() public returns (uint) {\n        prod();\n        return _way;\n    }\n\n    function tell(uint256 ray) public note auth {\n        fix = ray;\n    }\n    function tune(uint256 ray) public note auth {\n        how = ray;\n    }\n\n    function prod() public note {\n        var age = era() - tau;\n        if (age == 0) return;  // optimised\n        tau = era();\n\n        if (_way != RAY) _par = rmul(_par, rpow(_way, age));  // optimised\n\n        if (how == 0) return;  // optimised\n        var wag = int128(how * age);\n        _way = inj(prj(_way) + (fix < _par ? wag : -wag));\n    }\n\n    function inj(int128 x) internal pure returns (uint256) {\n        return x >= 0 ? uint256(x) + RAY\n            : rdiv(RAY, RAY + uint256(-x));\n    }\n    function prj(uint256 x) internal pure returns (int128) {\n        return x >= RAY ? int128(x - RAY)\n            : int128(RAY) - int128(rdiv(RAY, x));\n    }\n}\n\n////// src/tub.sol\n/// tub.sol -- simplified CDP engine (baby brother of `vat')\n\n// Copyright (C) 2017  Nikolai Mushegian <[email protected]>\n// Copyright (C) 2017  Daniel Brockman <[email protected]>\n// Copyright (C) 2017  Rain Break <[email protected]>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.18; */\n\n/* import \"ds-thing/thing.sol\"; */\n/* import \"ds-token/token.sol\"; */\n/* import \"ds-value/value.sol\"; */\n\n/* import \"./vox.sol\"; */\n\ncontract SaiTubEvents {\n    event LogNewCup(address indexed lad, bytes32 cup);\n}\n\ncontract SaiTub is DSThing, SaiTubEvents {\n    DSToken  public  sai;  // Stablecoin\n    DSToken  public  sin;  // Debt (negative sai)\n\n    DSToken  public  skr;  // Abstracted collateral\n    ERC20    public  gem;  // Underlying collateral\n\n    DSToken  public  gov;  // Governance token\n\n    SaiVox   public  vox;  // Target price feed\n    DSValue  public  pip;  // Reference price feed\n    DSValue  public  pep;  // Governance price feed\n\n    address  public  tap;  // Liquidator\n    address  public  pit;  // Governance Vault\n\n    uint256  public  axe;  // Liquidation penalty\n    uint256  public  cap;  // Debt ceiling\n    uint256  public  mat;  // Liquidation ratio\n    uint256  public  tax;  // Stability fee\n    uint256  public  fee;  // Governance fee\n    uint256  public  gap;  // Join-Exit Spread\n\n    bool     public  off;  // Cage flag\n    bool     public  out;  // Post cage exit\n\n    uint256  public  fit;  // REF per SKR (just before settlement)\n\n    uint256  public  rho;  // Time of last drip\n    uint256         _chi;  // Accumulated Tax Rates\n    uint256         _rhi;  // Accumulated Tax + Fee Rates\n    uint256  public  rum;  // Total normalised debt\n\n    uint256                   public  cupi;\n    mapping (bytes32 => Cup)  public  cups;\n\n    struct Cup {\n        address  lad;      // CDP owner\n        uint256  ink;      // Locked collateral (in SKR)\n        uint256  art;      // Outstanding normalised debt (tax only)\n        uint256  ire;      // Outstanding normalised debt\n    }\n\n    function lad(bytes32 cup) public view returns (address) {\n        return cups[cup].lad;\n    }\n    function ink(bytes32 cup) public view returns (uint) {\n        return cups[cup].ink;\n    }\n    function tab(bytes32 cup) public returns (uint) {\n        return rmul(cups[cup].art, chi());\n    }\n    function rap(bytes32 cup) public returns (uint) {\n        return sub(rmul(cups[cup].ire, rhi()), tab(cup));\n    }\n\n    // Total CDP Debt\n    function din() public returns (uint) {\n        return rmul(rum, chi());\n    }\n    // Backing collateral\n    function air() public view returns (uint) {\n        return skr.balanceOf(this);\n    }\n    // Raw collateral\n    function pie() public view returns (uint) {\n        return gem.balanceOf(this);\n    }\n\n    //------------------------------------------------------------------\n\n    function SaiTub(\n        DSToken  sai_,\n        DSToken  sin_,\n        DSToken  skr_,\n        ERC20    gem_,\n        DSToken  gov_,\n        DSValue  pip_,\n        DSValue  pep_,\n        SaiVox   vox_,\n        address  pit_\n    ) public {\n        gem = gem_;\n        skr = skr_;\n\n        sai = sai_;\n        sin = sin_;\n\n        gov = gov_;\n        pit = pit_;\n\n        pip = pip_;\n        pep = pep_;\n        vox = vox_;\n\n        axe = RAY;\n        mat = RAY;\n        tax = RAY;\n        fee = RAY;\n        gap = WAD;\n\n        _chi = RAY;\n        _rhi = RAY;\n\n        rho = era();\n    }\n\n    function era() public constant returns (uint) {\n        return block.timestamp;\n    }\n\n    //--Risk-parameter-config-------------------------------------------\n\n    function mold(bytes32 param, uint val) public note auth {\n        if      (param == 'cap') cap = val;\n        else if (param == 'mat') { require(val >= RAY); mat = val; }\n        else if (param == 'tax') { require(val >= RAY); drip(); tax = val; }\n        else if (param == 'fee') { require(val >= RAY); drip(); fee = val; }\n        else if (param == 'axe') { require(val >= RAY); axe = val; }\n        else if (param == 'gap') { require(val >= WAD); gap = val; }\n        else return;\n    }\n\n    //--Price-feed-setters----------------------------------------------\n\n    function setPip(DSValue pip_) public note auth {\n        pip = pip_;\n    }\n    function setPep(DSValue pep_) public note auth {\n        pep = pep_;\n    }\n    function setVox(SaiVox vox_) public note auth {\n        vox = vox_;\n    }\n\n    //--Tap-setter------------------------------------------------------\n    function turn(address tap_) public note {\n        require(tap  == 0);\n        require(tap_ != 0);\n        tap = tap_;\n    }\n\n    //--Collateral-wrapper----------------------------------------------\n\n    // Wrapper ratio (gem per skr)\n    function per() public view returns (uint ray) {\n        return skr.totalSupply() == 0 ? RAY : rdiv(pie(), skr.totalSupply());\n    }\n    // Join price (gem per skr)\n    function ask(uint wad) public view returns (uint) {\n        return rmul(wad, wmul(per(), gap));\n    }\n    // Exit price (gem per skr)\n    function bid(uint wad) public view returns (uint) {\n        return rmul(wad, wmul(per(), sub(2 * WAD, gap)));\n    }\n    function join(uint wad) public note {\n        require(!off);\n        require(ask(wad) > 0);\n        require(gem.transferFrom(msg.sender, this, ask(wad)));\n        skr.mint(msg.sender, wad);\n    }\n    function exit(uint wad) public note {\n        require(!off || out);\n        require(gem.transfer(msg.sender, bid(wad)));\n        skr.burn(msg.sender, wad);\n    }\n\n    //--Stability-fee-accumulation--------------------------------------\n\n    // Accumulated Rates\n    function chi() public returns (uint) {\n        drip();\n        return _chi;\n    }\n    function rhi() public returns (uint) {\n        drip();\n        return _rhi;\n    }\n    function drip() public note {\n        if (off) return;\n\n        var rho_ = era();\n        var age = rho_ - rho;\n        if (age == 0) return;    // optimised\n        rho = rho_;\n\n        var inc = RAY;\n\n        if (tax != RAY) {  // optimised\n            var _chi_ = _chi;\n            inc = rpow(tax, age);\n            _chi = rmul(_chi, inc);\n            sai.mint(tap, rmul(sub(_chi, _chi_), rum));\n        }\n\n        // optimised\n        if (fee != RAY) inc = rmul(inc, rpow(fee, age));\n        if (inc != RAY) _rhi = rmul(_rhi, inc);\n    }\n\n\n    //--CDP-risk-indicator----------------------------------------------\n\n    // Abstracted collateral price (ref per skr)\n    function tag() public view returns (uint wad) {\n        return off ? fit : wmul(per(), uint(pip.read()));\n    }\n    // Returns true if cup is well-collateralized\n    function safe(bytes32 cup) public returns (bool) {\n        var pro = rmul(tag(), ink(cup));\n        var con = rmul(vox.par(), tab(cup));\n        var min = rmul(con, mat);\n        return pro >= min;\n    }\n\n\n    //--CDP-operations--------------------------------------------------\n\n    function open() public note returns (bytes32 cup) {\n        require(!off);\n        cupi = add(cupi, 1);\n        cup = bytes32(cupi);\n        cups[cup].lad = msg.sender;\n        LogNewCup(msg.sender, cup);\n    }\n    function give(bytes32 cup, address guy) public note {\n        require(msg.sender == cups[cup].lad);\n        require(guy != 0);\n        cups[cup].lad = guy;\n    }\n\n    function lock(bytes32 cup, uint wad) public note {\n        require(!off);\n        cups[cup].ink = add(cups[cup].ink, wad);\n        skr.pull(msg.sender, wad);\n        require(cups[cup].ink == 0 || cups[cup].ink > 0.005 ether);\n    }\n    function free(bytes32 cup, uint wad) public note {\n        require(msg.sender == cups[cup].lad);\n        cups[cup].ink = sub(cups[cup].ink, wad);\n        skr.push(msg.sender, wad);\n        require(safe(cup));\n        require(cups[cup].ink == 0 || cups[cup].ink > 0.005 ether);\n    }\n\n    function draw(bytes32 cup, uint wad) public note {\n        require(!off);\n        require(msg.sender == cups[cup].lad);\n        require(rdiv(wad, chi()) > 0);\n\n        cups[cup].art = add(cups[cup].art, rdiv(wad, chi()));\n        rum = add(rum, rdiv(wad, chi()));\n\n        cups[cup].ire = add(cups[cup].ire, rdiv(wad, rhi()));\n        sai.mint(cups[cup].lad, wad);\n\n        require(safe(cup));\n        require(sai.totalSupply() <= cap);\n    }\n    function wipe(bytes32 cup, uint wad) public note {\n        require(!off);\n\n        var owe = rmul(wad, rdiv(rap(cup), tab(cup)));\n\n        cups[cup].art = sub(cups[cup].art, rdiv(wad, chi()));\n        rum = sub(rum, rdiv(wad, chi()));\n\n        cups[cup].ire = sub(cups[cup].ire, rdiv(add(wad, owe), rhi()));\n        sai.burn(msg.sender, wad);\n\n        var (val, ok) = pep.peek();\n        if (ok && val != 0) gov.move(msg.sender, pit, wdiv(owe, uint(val)));\n    }\n\n    function shut(bytes32 cup) public note {\n        require(!off);\n        require(msg.sender == cups[cup].lad);\n        if (tab(cup) != 0) wipe(cup, tab(cup));\n        if (ink(cup) != 0) free(cup, ink(cup));\n        delete cups[cup];\n    }\n\n    function bite(bytes32 cup) public note {\n        require(!safe(cup) || off);\n\n        // Take on all of the debt, except unpaid fees\n        var rue = tab(cup);\n        sin.mint(tap, rue);\n        rum = sub(rum, cups[cup].art);\n        cups[cup].art = 0;\n        cups[cup].ire = 0;\n\n        // Amount owed in SKR, including liquidation penalty\n        var owe = rdiv(rmul(rmul(rue, axe), vox.par()), tag());\n\n        if (owe > cups[cup].ink) {\n            owe = cups[cup].ink;\n        }\n\n        skr.push(tap, owe);\n        cups[cup].ink = sub(cups[cup].ink, owe);\n    }\n\n    //------------------------------------------------------------------\n\n    function cage(uint fit_, uint jam) public note auth {\n        require(!off && fit_ != 0);\n        off = true;\n        axe = RAY;\n        gap = WAD;\n        fit = fit_;         // ref per skr\n        require(gem.transfer(tap, jam));\n    }\n    function flow() public note auth {\n        require(off);\n        out = true;\n    }\n}\n\n////// src/tap.sol\n/// tap.sol -- liquidation engine (see also `vow`)\n\n// Copyright (C) 2017  Nikolai Mushegian <[email protected]>\n// Copyright (C) 2017  Daniel Brockman <[email protected]>\n// Copyright (C) 2017  Rain Break <[email protected]>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.18; */\n\n/* import \"./tub.sol\"; */\n\ncontract SaiTap is DSThing {\n    DSToken  public  sai;\n    DSToken  public  sin;\n    DSToken  public  skr;\n\n    SaiVox   public  vox;\n    SaiTub   public  tub;\n\n    uint256  public  gap;  // Boom-Bust Spread\n    bool     public  off;  // Cage flag\n    uint256  public  fix;  // Cage price\n\n    // Surplus\n    function joy() public view returns (uint) {\n        return sai.balanceOf(this);\n    }\n    // Bad debt\n    function woe() public view returns (uint) {\n        return sin.balanceOf(this);\n    }\n    // Collateral pending liquidation\n    function fog() public view returns (uint) {\n        return skr.balanceOf(this);\n    }\n\n\n    function SaiTap(SaiTub tub_) public {\n        tub = tub_;\n\n        sai = tub.sai();\n        sin = tub.sin();\n        skr = tub.skr();\n\n        vox = tub.vox();\n\n        gap = WAD;\n    }\n\n    function mold(bytes32 param, uint val) public note auth {\n        if (param == 'gap') gap = val;\n    }\n\n    // Cancel debt\n    function heal() public note {\n        if (joy() == 0 || woe() == 0) return;  // optimised\n        var wad = min(joy(), woe());\n        sai.burn(wad);\n        sin.burn(wad);\n    }\n\n    // Feed price (sai per skr)\n    function s2s() public returns (uint) {\n        var tag = tub.tag();    // ref per skr\n        var par = vox.par();    // ref per sai\n        return rdiv(tag, par);  // sai per skr\n    }\n    // Boom price (sai per skr)\n    function bid(uint wad) public returns (uint) {\n        return rmul(wad, wmul(s2s(), sub(2 * WAD, gap)));\n    }\n    // Bust price (sai per skr)\n    function ask(uint wad) public returns (uint) {\n        return rmul(wad, wmul(s2s(), gap));\n    }\n    function flip(uint wad) internal {\n        require(ask(wad) > 0);\n        skr.push(msg.sender, wad);\n        sai.pull(msg.sender, ask(wad));\n        heal();\n    }\n    function flop(uint wad) internal {\n        skr.mint(sub(wad, fog()));\n        flip(wad);\n        require(joy() == 0);  // can't flop into surplus\n    }\n    function flap(uint wad) internal {\n        heal();\n        sai.push(msg.sender, bid(wad));\n        skr.burn(msg.sender, wad);\n    }\n    function bust(uint wad) public note {\n        require(!off);\n        if (wad > fog()) flop(wad);\n        else flip(wad);\n    }\n    function boom(uint wad) public note {\n        require(!off);\n        flap(wad);\n    }\n\n    //------------------------------------------------------------------\n\n    function cage(uint fix_) public note auth {\n        require(!off);\n        off = true;\n        fix = fix_;\n    }\n    function cash(uint wad) public note {\n        require(off);\n        sai.burn(msg.sender, wad);\n        require(tub.gem().transfer(msg.sender, rmul(wad, fix)));\n    }\n    function mock(uint wad) public note {\n        require(off);\n        sai.mint(msg.sender, wad);\n        require(tub.gem().transferFrom(msg.sender, this, rmul(wad, fix)));\n    }\n    function vent() public note {\n        require(off);\n        skr.burn(fog());\n    }\n}\n\n////// src/top.sol\n/// top.sol -- global settlement manager\n\n// Copyright (C) 2017  Nikolai Mushegian <[email protected]>\n// Copyright (C) 2017  Daniel Brockman <[email protected]>\n// Copyright (C) 2017  Rain Break <[email protected]>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.18; */\n\n/* import \"./tub.sol\"; */\n/* import \"./tap.sol\"; */\n\ncontract SaiTop is DSThing {\n    SaiVox   public  vox;\n    SaiTub   public  tub;\n    SaiTap   public  tap;\n\n    DSToken  public  sai;\n    DSToken  public  sin;\n    DSToken  public  skr;\n    ERC20    public  gem;\n\n    uint256  public  fix;  // sai cage price (gem per sai)\n    uint256  public  fit;  // skr cage price (ref per skr)\n    uint256  public  caged;\n    uint256  public  cooldown = 6 hours;\n\n    function SaiTop(SaiTub tub_, SaiTap tap_) public {\n        tub = tub_;\n        tap = tap_;\n\n        vox = tub.vox();\n\n        sai = tub.sai();\n        sin = tub.sin();\n        skr = tub.skr();\n        gem = tub.gem();\n    }\n\n    function era() public view returns (uint) {\n        return block.timestamp;\n    }\n\n    // force settlement of the system at a given price (sai per gem).\n    // This is nearly the equivalent of biting all cups at once.\n    // Important consideration: the gems associated with free skr can\n    // be tapped to make sai whole.\n    function cage(uint price) internal {\n        require(!tub.off() && price != 0);\n        caged = era();\n\n        tub.drip();  // collect remaining fees\n        tap.heal();  // absorb any pending fees\n\n        fit = rmul(wmul(price, vox.par()), tub.per());\n        // Most gems we can get per sai is the full balance of the tub.\n        // If there is no sai issued, we should still be able to cage.\n        if (sai.totalSupply() == 0) {\n            fix = rdiv(WAD, price);\n        } else {\n            fix = min(rdiv(WAD, price), rdiv(tub.pie(), sai.totalSupply()));\n        }\n\n        tub.cage(fit, rmul(fix, sai.totalSupply()));\n        tap.cage(fix);\n\n        tap.vent();    // burn pending sale skr\n    }\n    // cage by reading the last value from the feed for the price\n    function cage() public note auth {\n        cage(rdiv(uint(tub.pip().read()), vox.par()));\n    }\n\n    function flow() public note {\n        require(tub.off());\n        var empty = tub.din() == 0 && tap.fog() == 0;\n        var ended = era() > caged + cooldown;\n        require(empty || ended);\n        tub.flow();\n    }\n\n    function setCooldown(uint cooldown_) public auth {\n        cooldown = cooldown_;\n    }\n}\n\n////// src/mom.sol\n/// mom.sol -- admin manager\n\n// Copyright (C) 2017  Nikolai Mushegian <[email protected]>\n// Copyright (C) 2017  Daniel Brockman <[email protected]>\n// Copyright (C) 2017  Rain <[email protected]>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.4.18; */\n\n/* import 'ds-thing/thing.sol'; */\n/* import './tub.sol'; */\n/* import './top.sol'; */\n/* import './tap.sol'; */\n\ncontract SaiMom is DSThing {\n    SaiTub  public  tub;\n    SaiTap  public  tap;\n    SaiVox  public  vox;\n\n    function SaiMom(SaiTub tub_, SaiTap tap_, SaiVox vox_) public {\n        tub = tub_;\n        tap = tap_;\n        vox = vox_;\n    }\n    // Debt ceiling\n    function setCap(uint wad) public note auth {\n        tub.mold(\"cap\", wad);\n    }\n    // Liquidation ratio\n    function setMat(uint ray) public note auth {\n        tub.mold(\"mat\", ray);\n        var axe = tub.axe();\n        var mat = tub.mat();\n        require(axe >= RAY && axe <= mat);\n    }\n    // Stability fee\n    function setTax(uint ray) public note auth {\n        tub.mold(\"tax\", ray);\n        var tax = tub.tax();\n        require(RAY <= tax);\n        require(tax < 10002 * 10 ** 23);  // ~200% per hour\n    }\n    // Governance fee\n    function setFee(uint ray) public note auth {\n        tub.mold(\"fee\", ray);\n        var fee = tub.fee();\n        require(RAY <= fee);\n        require(fee < 10002 * 10 ** 23);  // ~200% per hour\n    }\n    // Liquidation fee\n    function setAxe(uint ray) public note auth {\n        tub.mold(\"axe\", ray);\n        var axe = tub.axe();\n        var mat = tub.mat();\n        require(axe >= RAY && axe <= mat);\n    }\n    // Join/Exit Spread\n    function setTubGap(uint wad) public note auth {\n        tub.mold(\"gap\", wad);\n    }\n    // ETH/USD Feed\n    function setPip(DSValue pip_) public note auth {\n        tub.setPip(pip_);\n    }\n    // MKR/USD Feed\n    function setPep(DSValue pep_) public note auth {\n        tub.setPep(pep_);\n    }\n    // TRFM\n    function setVox(SaiVox vox_) public note auth {\n        tub.setVox(vox_);\n    }\n    // Boom/Bust Spread\n    function setTapGap(uint wad) public note auth {\n        tap.mold(\"gap\", wad);\n        var gap = tap.gap();\n        require(gap <= 1.05 ether);\n        require(gap >= 0.95 ether);\n    }\n    // Rate of change of target price (per second)\n    function setWay(uint ray) public note auth {\n        require(ray < 10002 * 10 ** 23);  // ~200% per hour\n        require(ray > 9998 * 10 ** 23);\n        vox.mold(\"way\", ray);\n    }\n    function setHow(uint ray) public note auth {\n        vox.tune(ray);\n    }\n}\n\n////// src/fab.sol\n/* pragma solidity ^0.4.18; */\n\n/* import \"ds-auth/auth.sol\"; */\n/* import 'ds-token/token.sol'; */\n/* import 'ds-guard/guard.sol'; */\n/* import 'ds-roles/roles.sol'; */\n/* import 'ds-value/value.sol'; */\n\n/* import './mom.sol'; */\n\ncontract GemFab {\n    function newTok(bytes32 name) public returns (DSToken token) {\n        token = new DSToken(name);\n        token.setOwner(msg.sender);\n    }\n}\n\ncontract VoxFab {\n    function newVox() public returns (SaiVox vox) {\n        vox = new SaiVox(10 ** 27);\n        vox.setOwner(msg.sender);\n    }\n}\n\ncontract TubFab {\n    function newTub(DSToken sai, DSToken sin, DSToken skr, ERC20 gem, DSToken gov, DSValue pip, DSValue pep, SaiVox vox, address pit) public returns (SaiTub tub) {\n        tub = new SaiTub(sai, sin, skr, gem, gov, pip, pep, vox, pit);\n        tub.setOwner(msg.sender);\n    }\n}\n\ncontract TapFab {\n    function newTap(SaiTub tub) public returns (SaiTap tap) {\n        tap = new SaiTap(tub);\n        tap.setOwner(msg.sender);\n    }\n}\n\ncontract TopFab {\n    function newTop(SaiTub tub, SaiTap tap) public returns (SaiTop top) {\n        top = new SaiTop(tub, tap);\n        top.setOwner(msg.sender);\n    }\n}\n\ncontract MomFab {\n    function newMom(SaiTub tub, SaiTap tap, SaiVox vox) public returns (SaiMom mom) {\n        mom = new SaiMom(tub, tap, vox);\n        mom.setOwner(msg.sender);\n    }\n}\n\ncontract DadFab {\n    function newDad() public returns (DSGuard dad) {\n        dad = new DSGuard();\n        dad.setOwner(msg.sender);\n    }\n}\n\ncontract DaiFab is DSAuth {\n    GemFab public gemFab;\n    VoxFab public voxFab;\n    TapFab public tapFab;\n    TubFab public tubFab;\n    TopFab public topFab;\n    MomFab public momFab;\n    DadFab public dadFab;\n\n    DSToken public sai;\n    DSToken public sin;\n    DSToken public skr;\n\n    SaiVox public vox;\n    SaiTub public tub;\n    SaiTap public tap;\n    SaiTop public top;\n\n    SaiMom public mom;\n    DSGuard public dad;\n\n    uint8 public step = 0;\n\n    function DaiFab(GemFab gemFab_, VoxFab voxFab_, TubFab tubFab_, TapFab tapFab_, TopFab topFab_, MomFab momFab_, DadFab dadFab_) public {\n        gemFab = gemFab_;\n        voxFab = voxFab_;\n        tubFab = tubFab_;\n        tapFab = tapFab_;\n        topFab = topFab_;\n        momFab = momFab_;\n        dadFab = dadFab_;\n    }\n\n    function makeTokens() public auth {\n        require(step == 0);\n        sai = gemFab.newTok('sai');\n        sin = gemFab.newTok('sin');\n        skr = gemFab.newTok('skr');\n        step += 1;\n    }\n\n    function makeVoxTub(ERC20 gem, DSToken gov, DSValue pip, DSValue pep, address pit) public auth {\n        require(step == 1);\n        require(address(gem) != 0x0);\n        require(address(gov) != 0x0);\n        require(address(pip) != 0x0);\n        require(address(pep) != 0x0);\n        require(pit != 0x0);\n        vox = voxFab.newVox();\n        tub = tubFab.newTub(sai, sin, skr, gem, gov, pip, pep, vox, pit);\n        step += 1;\n    }\n\n    function makeTapTop() public auth {\n        require(step == 2);\n        tap = tapFab.newTap(tub);\n        tub.turn(tap);\n        top = topFab.newTop(tub, tap);\n        step += 1;\n    }\n\n    function S(string s) internal pure returns (bytes4) {\n        return bytes4(keccak256(s));\n    }\n\n    function ray(uint256 wad) internal pure returns (uint256) {\n        return wad * 10 ** 9;\n    }\n\n    // Liquidation Ratio   150%\n    // Liquidation Penalty 13%\n    // Stability Fee       0.05%\n    // PETH Fee            0%\n    // Boom/Bust Spread   -3%\n    // Join/Exit Spread    0%\n    // Debt Ceiling        0\n    function configParams() public auth {\n        require(step == 3);\n\n        tub.mold(\"cap\", 0);\n        tub.mold(\"mat\", ray(1.5  ether));\n        tub.mold(\"axe\", ray(1.13 ether));\n        tub.mold(\"fee\", 1000000000158153903837946257);  // 0.5% / year\n        tub.mold(\"tax\", ray(1 ether));\n        tub.mold(\"gap\", 1 ether);\n\n        tap.mold(\"gap\", 0.97 ether);\n\n        step += 1;\n    }\n\n    function verifyParams() public auth {\n        require(step == 4);\n\n        require(tub.cap() == 0);\n        require(tub.mat() == 1500000000000000000000000000);\n        require(tub.axe() == 1130000000000000000000000000);\n        require(tub.fee() == 1000000000158153903837946257);\n        require(tub.tax() == 1000000000000000000000000000);\n        require(tub.gap() == 1000000000000000000);\n\n        require(tap.gap() == 970000000000000000);\n\n        require(vox.par() == 1000000000000000000000000000);\n        require(vox.how() == 0);\n\n        step += 1;\n    }\n\n    function configAuth(DSAuthority authority) public auth {\n        require(step == 5);\n        require(address(authority) != 0x0);\n\n        mom = momFab.newMom(tub, tap, vox);\n        dad = dadFab.newDad();\n\n        vox.setAuthority(dad);\n        vox.setOwner(0);\n        tub.setAuthority(dad);\n        tub.setOwner(0);\n        tap.setAuthority(dad);\n        tap.setOwner(0);\n        sai.setAuthority(dad);\n        sai.setOwner(0);\n        sin.setAuthority(dad);\n        sin.setOwner(0);\n        skr.setAuthority(dad);\n        skr.setOwner(0);\n\n        top.setAuthority(authority);\n        top.setOwner(0);\n        mom.setAuthority(authority);\n        mom.setOwner(0);\n\n        dad.permit(top, tub, S(\"cage(uint256,uint256)\"));\n        dad.permit(top, tub, S(\"flow()\"));\n        dad.permit(top, tap, S(\"cage(uint256)\"));\n\n        dad.permit(tub, skr, S('mint(address,uint256)'));\n        dad.permit(tub, skr, S('burn(address,uint256)'));\n\n        dad.permit(tub, sai, S('mint(address,uint256)'));\n        dad.permit(tub, sai, S('burn(address,uint256)'));\n\n        dad.permit(tub, sin, S('mint(address,uint256)'));\n\n        dad.permit(tap, sai, S('mint(address,uint256)'));\n        dad.permit(tap, sai, S('burn(address,uint256)'));\n        dad.permit(tap, sai, S('burn(uint256)'));\n        dad.permit(tap, sin, S('burn(uint256)'));\n\n        dad.permit(tap, skr, S('mint(uint256)'));\n        dad.permit(tap, skr, S('burn(uint256)'));\n        dad.permit(tap, skr, S('burn(address,uint256)'));\n\n        dad.permit(mom, vox, S(\"mold(bytes32,uint256)\"));\n        dad.permit(mom, vox, S(\"tune(uint256)\"));\n        dad.permit(mom, tub, S(\"mold(bytes32,uint256)\"));\n        dad.permit(mom, tap, S(\"mold(bytes32,uint256)\"));\n        dad.permit(mom, tub, S(\"setPip(address)\"));\n        dad.permit(mom, tub, S(\"setPep(address)\"));\n        dad.permit(mom, tub, S(\"setVox(address)\"));\n\n        dad.setOwner(0);\n        step += 1;\n    }\n}",
  "bytecode": "6060604052341561000f57600080fd5b610f558061001e6000396000f3006060604052600436106100405763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663b476ae3e8114610045575b600080fd5b341561005057600080fd5b61005b600435610084565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b60008161008f610147565b908152602001604051809103906000f08015156100ab57600080fd5b90508073ffffffffffffffffffffffffffffffffffffffff166313af4035336040517c010000000000000000000000000000000000000000000000000000000063ffffffff841602815273ffffffffffffffffffffffffffffffffffffffff9091166004820152602401600060405180830381600087803b151561012e57600080fd5b6102c65a03f1151561013f57600080fd5b505050919050565b604051610dd280610158833901905600606060405260126006556000600755341561001957600080fd5b604051602080610dd283398101604052808051600160a060020a03331660008181526001602052604080822082905590805560048054600160a060020a0319168317905591935091507fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94905160405180910390a2600555610d338061009f6000396000f3006060604052600436106101485763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166306fdde03811461014d57806307da68f514610172578063095ea7b31461018757806313af4035146101bd57806318160ddd146101dc57806323b872dd146101ef578063313ce5671461021757806340c10f191461022a57806342966c681461024c5780635ac801fe1461026257806370a082311461027857806375f12b21146102975780637a9e5e4b146102aa5780638da5cb5b146102c957806395d89b41146102f85780639dc29fac1461030b578063a0712d681461032d578063a9059cbb14610343578063b753a98c14610365578063bb35783b14610387578063be9a6555146103af578063bf7e214f146103c2578063daea85c5146103d5578063dd62ed3e146103f4578063f2d5d56b14610419575b600080fd5b341561015857600080fd5b61016061043b565b60405190815260200160405180910390f35b341561017d57600080fd5b610185610441565b005b341561019257600080fd5b6101a9600160a060020a03600435166024356104e0565b604051901515815260200160405180910390f35b34156101c857600080fd5b610185600160a060020a036004351661050d565b34156101e757600080fd5b61016061058c565b34156101fa57600080fd5b6101a9600160a060020a0360043581169060243516604435610592565b341561022257600080fd5b610160610707565b341561023557600080fd5b610185600160a060020a036004351660243561070d565b341561025757600080fd5b6101856004356107d3565b341561026d57600080fd5b6101856004356107e0565b341561028357600080fd5b610160600160a060020a0360043516610806565b34156102a257600080fd5b6101a9610821565b34156102b557600080fd5b610185600160a060020a0360043516610831565b34156102d457600080fd5b6102dc6108b0565b604051600160a060020a03909116815260200160405180910390f35b341561030357600080fd5b6101606108bf565b341561031657600080fd5b610185600160a060020a03600435166024356108c5565b341561033857600080fd5b610185600435610a33565b341561034e57600080fd5b6101a9600160a060020a0360043516602435610a3d565b341561037057600080fd5b610185600160a060020a0360043516602435610a4a565b341561039257600080fd5b610185600160a060020a0360043581169060243516604435610a5a565b34156103ba57600080fd5b610185610a6b565b34156103cd57600080fd5b6102dc610b04565b34156103e057600080fd5b6101a9600160a060020a0360043516610b13565b34156103ff57600080fd5b610160600160a060020a0360043581169060243516610b39565b341561042457600080fd5b610185600160a060020a0360043516602435610b64565b60075481565b61045733600035600160e060020a031916610b6f565b151561046257600080fd5b600435602435808233600160a060020a031660008035600160e060020a0319169034903660405183815260406020820181815290820183905260608201848480828437820191505094505050505060405180910390a450506004805474ff0000000000000000000000000000000000000000191660a060020a179055565b60045460009060a060020a900460ff16156104fa57600080fd5b6105048383610c7b565b90505b92915050565b61052333600035600160e060020a031916610b6f565b151561052e57600080fd5b6004805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038381169190911791829055167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a250565b60005490565b60045460009060a060020a900460ff16156105ac57600080fd5b33600160a060020a031684600160a060020a0316141580156105f65750600160a060020a038085166000908152600260209081526040808320339094168352929052205460001914155b1561065457600160a060020a038085166000908152600260209081526040808320339094168352929052205461062c9083610ce7565b600160a060020a03808616600090815260026020908152604080832033909416835292905220555b600160a060020a0384166000908152600160205260409020546106779083610ce7565b600160a060020a0380861660009081526001602052604080822093909355908516815220546106a69083610cf7565b600160a060020a03808516600081815260016020526040908190209390935591908616907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a35060019392505050565b60065481565b61072333600035600160e060020a031916610b6f565b151561072e57600080fd5b60045460a060020a900460ff161561074557600080fd5b600160a060020a0382166000908152600160205260409020546107689082610cf7565b600160a060020a0383166000908152600160205260408120919091555461078f9082610cf7565b600055600160a060020a0382167f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d41213968858260405190815260200160405180910390a25050565b6107dd33826108c5565b50565b6107f633600035600160e060020a031916610b6f565b151561080157600080fd5b600755565b600160a060020a031660009081526001602052604090205490565b60045460a060020a900460ff1681565b61084733600035600160e060020a031916610b6f565b151561085257600080fd5b6003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038381169190911791829055167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a250565b600454600160a060020a031681565b60055481565b6108db33600035600160e060020a031916610b6f565b15156108e657600080fd5b60045460a060020a900460ff16156108fd57600080fd5b33600160a060020a031682600160a060020a0316141580156109475750600160a060020a038083166000908152600260209081526040808320339094168352929052205460001914155b156109a557600160a060020a038083166000908152600260209081526040808320339094168352929052205461097d9082610ce7565b600160a060020a03808416600090815260026020908152604080832033909416835292905220555b600160a060020a0382166000908152600160205260409020546109c89082610ce7565b600160a060020a038316600090815260016020526040812091909155546109ef9082610ce7565b600055600160a060020a0382167fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca58260405190815260200160405180910390a25050565b6107dd338261070d565b6000610504338484610592565b610a55338383610592565b505050565b610a65838383610592565b50505050565b610a8133600035600160e060020a031916610b6f565b1515610a8c57600080fd5b600435602435808233600160a060020a031660008035600160e060020a0319169034903660405183815260406020820181815290820183905260608201848480828437820191505094505050505060405180910390a450506004805474ff000000000000000000000000000000000000000019169055565b600354600160a060020a031681565b60045460009060a060020a900460ff1615610b2d57600080fd5b61050782600019610c7b565b600160a060020a03918216600090815260026020908152604080832093909416825291909152205490565b610a55823383610592565b600030600160a060020a031683600160a060020a03161415610b9357506001610507565b600454600160a060020a0384811691161415610bb157506001610507565b600354600160a060020a03161515610bcb57506000610507565b600354600160a060020a031663b70096138430856000604051602001526040517c010000000000000000000000000000000000000000000000000000000063ffffffff8616028152600160a060020a039384166004820152919092166024820152600160e060020a03199091166044820152606401602060405180830381600087803b1515610c5957600080fd5b6102c65a03f11515610c6a57600080fd5b505050604051805190509050610507565b600160a060020a03338116600081815260026020908152604080832094871680845294909152808220859055909291907f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259085905190815260200160405180910390a350600192915050565b8082038281111561050757600080fd5b8082018281101561050757600080fd00a165627a7a723058200877df264aa5d498c61a45dfe4fc04c68d11820448cf0cc7a275283a271173b40029a165627a7a723058207c9191226a86d78a13e166f79571f27eb09e019fe6108f7da957e98f66fec89c0029"
}