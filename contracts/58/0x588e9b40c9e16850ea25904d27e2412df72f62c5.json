{
  "address": "0x588e9b40c9e16850ea25904d27e2412df72f62c5",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Token",
  "compilerVersion": "v0.4.20+commit.3155dd80",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-05-18\n*/\n\npragma solidity ^0.4.18;\n\n// File: contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: contracts/InvestedProvider.sol\n\ncontract InvestedProvider is Ownable {\n\n  uint public invested;\n\n}\n\n// File: contracts/AddressesFilterFeature.sol\n\ncontract AddressesFilterFeature is Ownable {\n\n  mapping(address => bool) public allowedAddresses;\n\n  function addAllowedAddress(address allowedAddress) public onlyOwner {\n    allowedAddresses[allowedAddress] = true;\n  }\n\n  function removeAllowedAddress(address allowedAddress) public onlyOwner {\n    allowedAddresses[allowedAddress] = false;\n  }\n\n}\n\n// File: contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/token/ERC20Basic.sol\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: contracts/token/BasicToken.sol\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n// File: contracts/token/ERC20.sol\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/token/StandardToken.sol\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: contracts/MintableToken.sol\n\ncontract MintableToken is AddressesFilterFeature, StandardToken {\n\n  event Mint(address indexed to, uint256 amount);\n\n  event MintFinished();\n\n  bool public mintingFinished = false;\n\n  address public saleAgent;\n\n  mapping (address => uint) public initialBalances;\n\n  modifier notLocked(address _from) {\n    require(_from == owner || _from == saleAgent || allowedAddresses[_from] || mintingFinished);\n    _;\n  }\n\n  function setSaleAgent(address newSaleAgnet) public {\n    require(msg.sender == saleAgent || msg.sender == owner);\n    saleAgent = newSaleAgnet;\n  }\n\n  function mint(address _to, uint256 _amount) public returns (bool) {\n    require((msg.sender == saleAgent || msg.sender == owner) && !mintingFinished);\n    \n    totalSupply = totalSupply.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n\n    initialBalances[_to] = balances[_to];\n\n    Mint(_to, _amount);\n    Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function finishMinting() public returns (bool) {\n    require((msg.sender == saleAgent || msg.sender == owner) && !mintingFinished);\n    mintingFinished = true;\n    MintFinished();\n    return true;\n  }\n\n  function transfer(address _to, uint256 _value) public notLocked(msg.sender)  returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address from, address to, uint256 value) public notLocked(from) returns (bool) {\n    return super.transferFrom(from, to, value);\n  }\n\n}\n\n// File: contracts/TokenProvider.sol\n\ncontract TokenProvider is Ownable {\n\n  MintableToken public token;\n\n  function setToken(address newToken) public onlyOwner {\n    token = MintableToken(newToken);\n  }\n\n}\n\n// File: contracts/MintTokensInterface.sol\n\ncontract MintTokensInterface is TokenProvider {\n\n  function mintTokens(address to, uint tokens) internal;\n\n}\n\n// File: contracts/MintTokensFeature.sol\n\ncontract MintTokensFeature is MintTokensInterface {\n\n  function mintTokens(address to, uint tokens) internal {\n    token.mint(to, tokens);\n  }\n\n}\n\n// File: contracts/PercentRateProvider.sol\n\ncontract PercentRateProvider {\n\n  uint public percentRate = 100;\n\n}\n\n// File: contracts/PercentRateFeature.sol\n\ncontract PercentRateFeature is Ownable, PercentRateProvider {\n\n  function setPercentRate(uint newPercentRate) public onlyOwner {\n    percentRate = newPercentRate;\n  }\n\n}\n\n// File: contracts/RetrieveTokensFeature.sol\n\ncontract RetrieveTokensFeature is Ownable {\n\n  function retrieveTokens(address to, address anotherToken) public onlyOwner {\n    ERC20 alienToken = ERC20(anotherToken);\n    alienToken.transfer(to, alienToken.balanceOf(this));\n  }\n\n}\n\n// File: contracts/WalletProvider.sol\n\ncontract WalletProvider is Ownable {\n\n  address public wallet;\n\n  function setWallet(address newWallet) public onlyOwner {\n    wallet = newWallet;\n  }\n\n}\n\n// File: contracts/CommonSale.sol\n\ncontract CommonSale is InvestedProvider, WalletProvider, PercentRateFeature, RetrieveTokensFeature, MintTokensFeature {\n\n  using SafeMath for uint;\n\n  address public directMintAgent;\n\n  uint public price;\n\n  uint public start;\n\n  uint public minInvestedLimit;\n\n  //MintableToken public token;\n\n  uint public hardcap;\n\n  modifier isUnderHardcap() {\n    require(invested < hardcap);\n    _;\n  }\n\n  function setHardcap(uint newHardcap) public onlyOwner {\n    hardcap = newHardcap;\n  }\n\n  modifier onlyDirectMintAgentOrOwner() {\n    require(directMintAgent == msg.sender || owner == msg.sender);\n    _;\n  }\n\n  modifier minInvestLimited(uint value) {\n    require(value >= minInvestedLimit);\n    _;\n  }\n\n  function setStart(uint newStart) public onlyOwner {\n    start = newStart;\n  }\n\n  function setMinInvestedLimit(uint newMinInvestedLimit) public onlyOwner {\n    minInvestedLimit = newMinInvestedLimit;\n  }\n\n  function setDirectMintAgent(address newDirectMintAgent) public onlyOwner {\n    directMintAgent = newDirectMintAgent;\n  }\n\n  function setPrice(uint newPrice) public onlyOwner {\n    price = newPrice;\n  }\n\n  /*\n  function setToken(address newToken) public onlyOwner {\n    token = MintableToken(newToken);\n  }\n  */\n\n  function calculateTokens(uint _invested) internal returns(uint);\n\n  function mintTokensExternal(address to, uint tokens) public onlyDirectMintAgentOrOwner {\n    mintTokens(to, tokens);\n  }\n/*\n  function mintTokens(address to, uint tokens) internal {\n    token.mint(this, tokens);\n    token.transfer(to, tokens);\n  }\n*/\n  function endSaleDate() public view returns(uint);\n\n  function mintTokensByETHExternal(address to, uint _invested) public onlyDirectMintAgentOrOwner returns(uint) {\n    return mintTokensByETH(to, _invested);\n  }\n\n  function mintTokensByETH(address to, uint _invested) internal isUnderHardcap returns(uint) {\n    invested = invested.add(_invested);\n    uint tokens = calculateTokens(_invested);\n    mintTokens(to, tokens);\n    return tokens;\n  }\n\n  function fallback() internal minInvestLimited(msg.value) returns(uint) {\n    require(now >= start && now < endSaleDate());\n    wallet.transfer(msg.value);\n    return mintTokensByETH(msg.sender, msg.value);\n  }\n\n  function () public payable {\n    fallback();\n  }\n\n}\n\n// File: contracts/TimeCountBonusFeature.sol\n\ncontract TimeCountBonusFeature is CommonSale {\n\n  struct Milestone {\n    uint hardcap;\n    uint price;\n    uint period;\n    uint invested;\n    uint closed;\n  }\n\n  uint public period;\n\n  Milestone[] public milestones;\n\n  function milestonesCount() public constant returns(uint) {\n    return milestones.length;\n  }\n\n  function addMilestone(uint _hardcap, uint _price, uint _period) public onlyOwner {\n    require(_hardcap > 0 && _price > 0 && _period > 0);\n    Milestone memory milestone = Milestone(_hardcap.mul(1 ether), _price, _period, 0, 0);\n    milestones.push(milestone);\n    hardcap = hardcap.add(milestone.hardcap);\n    period = period.add(milestone.period);\n  }\n\n  function removeMilestone(uint8 number) public onlyOwner {\n    require(number >=0 && number < milestones.length);\n    Milestone storage milestone = milestones[number];\n    hardcap = hardcap.sub(milestone.hardcap);    \n    period = period.sub(milestone.period);    \n    delete milestones[number];\n    for (uint i = number; i < milestones.length - 1; i++) {\n      milestones[i] = milestones[i+1];\n    }\n    milestones.length--;\n  }\n\n  function changeMilestone(uint8 number, uint _hardcap, uint _price, uint _period) public onlyOwner {\n    require(number >= 0 &&number < milestones.length);\n    Milestone storage milestone = milestones[number];\n    hardcap = hardcap.sub(milestone.hardcap);    \n    period = period.sub(milestone.period);    \n    milestone.hardcap = _hardcap.mul(1 ether);\n    milestone.price = _price;\n    milestone.period = _period;\n    hardcap = hardcap.add(milestone.hardcap);    \n    period = period.add(milestone.period);    \n  }\n\n  function insertMilestone(uint8 numberAfter, uint _hardcap, uint _price, uint _period) public onlyOwner {\n    require(numberAfter < milestones.length);\n    Milestone memory milestone = Milestone(_hardcap.mul(1 ether), _price, _period, 0, 0);\n    hardcap = hardcap.add(milestone.hardcap);\n    period = period.add(milestone.period);\n    milestones.length++;\n    for (uint i = milestones.length - 2; i > numberAfter; i--) {\n      milestones[i + 1] = milestones[i];\n    }\n    milestones[numberAfter + 1] = milestone;\n  }\n\n  function clearMilestones() public onlyOwner {\n    for (uint i = 0; i < milestones.length; i++) {\n      delete milestones[i];\n    }\n    milestones.length = 0;\n    hardcap = 0;\n    period = 0;\n  }\n\n  function endSaleDate() public view returns(uint) {\n    return start.add(period * 1 days);\n  }\n\n  function currentMilestone() public constant returns(uint) {\n    uint closeTime = start;\n    for(uint i=0; i < milestones.length; i++) {\n      closeTime += milestones[i].period.mul(1 days);\n      if(milestones[i].closed == 0 && now < closeTime) {\n        return i;\n      }\n    }\n    revert();\n  }\n\n  function calculateTokens(uint _invested) internal returns(uint) {\n    uint milestoneIndex = currentMilestone();\n    Milestone storage milestone = milestones[milestoneIndex];\n    uint tokens = milestone.price.mul(_invested).div(1 ether);\n\n    // update milestone\n    milestone.invested = milestone.invested.add(_invested);\n    if(milestone.invested >= milestone.hardcap) {\n      milestone.closed = now;\n    }\n\n    return tokens;\n  }\n\n\n}\n\n// File: contracts/AssembledCommonSale.sol\n\ncontract AssembledCommonSale is TimeCountBonusFeature {\n\n}\n\n// File: contracts/WalletsPercents.sol\n\ncontract WalletsPercents is Ownable {\n\n  address[] public wallets;\n\n  mapping (address => uint) percents;\n\n  function addWallet(address wallet, uint percent) public onlyOwner {\n    wallets.push(wallet);\n    percents[wallet] = percent;\n  }\n \n  function cleanWallets() public onlyOwner {\n    wallets.length = 0;\n  }\n\n\n}\n\n// File: contracts/ExtendedWalletsMintTokensFeature.sol\n\n//import './PercentRateProvider.sol';\n\ncontract ExtendedWalletsMintTokensFeature is /*PercentRateProvider,*/ MintTokensInterface, WalletsPercents {\n\n  using SafeMath for uint;\n\n  uint public percentRate = 100;\n\n  function mintExtendedTokens() public onlyOwner {\n    uint summaryTokensPercent = 0;\n    for(uint i = 0; i < wallets.length; i++) {\n      summaryTokensPercent = summaryTokensPercent.add(percents[wallets[i]]);\n    }\n    uint mintedTokens = token.totalSupply();\n    uint allTokens = mintedTokens.mul(percentRate).div(percentRate.sub(summaryTokensPercent));\n    for(uint k = 0; k < wallets.length; k++) {\n      mintTokens(wallets[k], allTokens.mul(percents[wallets[k]]).div(percentRate));\n    }\n\n  }\n\n}\n\n// File: contracts/SoftcapFeature.sol\n\ncontract SoftcapFeature is InvestedProvider, WalletProvider {\n\n  using SafeMath for uint;\n\n  mapping(address => uint) public balances;\n\n  bool public softcapAchieved;\n\n  bool public refundOn;\n\n  bool public feePayed;\n\n  uint public softcap;\n\n  uint public constant devLimit = 7500000000000000000;\n\n  address public constant devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770;\n\n  function setSoftcap(uint newSoftcap) public onlyOwner {\n    softcap = newSoftcap;\n  }\n\n  function withdraw() public {\n    require(msg.sender == owner || msg.sender == devWallet);\n    require(softcapAchieved);\n    if(!feePayed) {\n      devWallet.transfer(devLimit);\n      feePayed = true;\n    }\n    wallet.transfer(this.balance);\n  }\n\n  function updateBalance(address to, uint amount) internal {\n    balances[to] = balances[to].add(amount);\n    if (!softcapAchieved && invested >= softcap) {\n      softcapAchieved = true;\n    }\n  }\n\n  function refund() public {\n    require(refundOn && balances[msg.sender] > 0);\n    uint value = balances[msg.sender];\n    balances[msg.sender] = 0;\n    msg.sender.transfer(value);\n  }\n\n  function updateRefundState() internal returns(bool) {\n    if (!softcapAchieved) {\n      refundOn = true;\n    }\n    return refundOn;\n  }\n\n}\n\n// File: contracts/TeamWallet.sol\n\ncontract TeamWallet is Ownable{\n\t\n  address public token;\n\n  address public crowdsale;\n\n  uint public lockPeriod;\n\n  uint public endLock;\n\n  bool public started;\n\n  modifier onlyCrowdsale() {\n    require(crowdsale == msg.sender);\n    _;\n  }\n\n  function setToken (address _token) public onlyOwner{\n  \ttoken = _token;\n  }\n\n  function setCrowdsale (address _crowdsale) public onlyOwner{\n    crowdsale = _crowdsale;\n  }\n\n  function setLockPeriod (uint _lockDays) public onlyOwner{\n  \trequire(!started);\n  \tlockPeriod = 1 days * _lockDays;\n  }\n\n  function start () public onlyCrowdsale{\n  \tstarted = true;\n  \tendLock = now + lockPeriod;\n  }\n\n  function withdrawTokens (address _to) public onlyOwner{\n  \trequire(now > endLock);\n  \tERC20 ERC20token = ERC20(token);\n    ERC20token.transfer(_to, ERC20token.balanceOf(this));  \n  }\n  \n}\n\n// File: contracts/ITO.sol\n\ncontract ITO is ExtendedWalletsMintTokensFeature, SoftcapFeature, AssembledCommonSale {\n\n  address public teamWallet;\n\n  bool public paused;\n\n  function setTeamWallet (address _teamWallet) public onlyOwner{\n    teamWallet = _teamWallet;\n  }\n\n  function mintTokensByETH(address to, uint _invested) internal returns(uint) {\n    uint _tokens = super.mintTokensByETH(to, _invested);\n    updateBalance(to, _invested);\n    return _tokens;\n  }\n\n  function finish() public onlyOwner {\n    if (updateRefundState()) {\n      token.finishMinting();\n    } else {\n      withdraw();\n      mintExtendedTokens();\n      token.finishMinting();\n      TeamWallet tWallet = TeamWallet(teamWallet);\n      tWallet.start();\n    }\n  }\n\n  function fallback() internal minInvestLimited(msg.value) returns(uint) {\n    require(now >= start && now < endSaleDate());\n    require(!paused);\n    return mintTokensByETH(msg.sender, msg.value);\n  }\n\n  function pauseITO() public onlyOwner {\n    paused = true;\n  }\n\n  function continueITO() public onlyOwner {\n    paused = false;\n  }\n\n}\n\n// File: contracts/ReceivingContractCallback.sol\n\ncontract ReceivingContractCallback {\n\n  function tokenFallback(address _from, uint _value) public;\n\n}\n\n// File: contracts/Token.sol\n\ncontract Token is MintableToken {\n\n  string public constant name = \"HelixHill\";\n\n  string public constant symbol = \"HILL\";\n\n  uint32 public constant decimals = 18;\n\n  mapping(address => bool)  public registeredCallbacks;\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    return processCallback(super.transfer(_to, _value), msg.sender, _to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    return processCallback(super.transferFrom(_from, _to, _value), _from, _to, _value);\n  }\n\n  function registerCallback(address callback) public onlyOwner {\n    registeredCallbacks[callback] = true;\n  }\n\n  function deregisterCallback(address callback) public onlyOwner {\n    registeredCallbacks[callback] = false;\n  }\n\n  function processCallback(bool result, address from, address to, uint value) internal returns(bool) {\n    if (result && registeredCallbacks[to]) {\n      ReceivingContractCallback targetCallback = ReceivingContractCallback(to);\n      targetCallback.tokenFallback(from, value);\n    }\n    return result;\n  }\n\n}\n\n// File: contracts/Configurator.sol\n\ncontract Configurator is Ownable {\n\n  Token public token;\n  ITO public ito;\n  TeamWallet public teamWallet;\n\n  function deploy() public onlyOwner {\n\n    address manager = 0xd6561BF111dAfe86A896D6c844F82AE4a5bbc707;\n\n    token = new Token();\n    ito = new ITO();\n    teamWallet = new TeamWallet();\n\n    token.setSaleAgent(ito);\n\n    ito.setStart(1530622800);\n    ito.addMilestone(2000, 5000000000000000000000, 146);\n    ito.addMilestone(1000, 2000000000000000000000, 30);\n    ito.addMilestone(1000, 1950000000000000000000, 30);\n    ito.addMilestone(2000, 1800000000000000000000, 30);\n    ito.addMilestone(3000, 1750000000000000000000, 30);\n    ito.addMilestone(3500, 1600000000000000000000, 30);\n    ito.addMilestone(4000, 1550000000000000000000, 30);\n    ito.addMilestone(4500, 1500000000000000000000, 30);\n    ito.addMilestone(5000, 1450000000000000000000, 30);\n    ito.addMilestone(6000, 1400000000000000000000, 30);\n    ito.addMilestone(8000, 1000000000000000000000, 30);\n    ito.setSoftcap(2000000000000000000000);\n    ito.setMinInvestedLimit(100000000000000000);\n    ito.setWallet(0x3047e47EfC33cF8f6F9C3bdD1ACcaEda75B66f2A);\n    ito.addWallet(0xe129b76dF45bFE35FE4a3fA52986CC8004538C98, 6);\n    ito.addWallet(0x26Db091BF1Bcc2c439A2cA7140D76B4e909C7b4e, 2);\n    ito.addWallet(teamWallet, 15);\n    ito.addWallet(0x2A3b94CB5b9E10E12f97c72d6B5E09BD5A0E6bF1, 12);\n    ito.setPercentRate(100);\n    ito.setToken(token);\n    ito.setTeamWallet(teamWallet);\n\n    teamWallet.setToken(token);\n    teamWallet.setCrowdsale(ito);\n    teamWallet.setLockPeriod(180);\n\n    token.transferOwnership(manager);\n    ito.transferOwnership(manager);\n    teamWallet.transferOwnership(manager);\n  }\n\n}",
  "bytecode": "60606040526005805460ff1916905560008054600160a060020a033316600160a060020a03199091161790556110938061003a6000396000f3006060604052600436106101485763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166305d2035b811461014d57806306fdde0314610174578063095ea7b3146101fe57806314133a7c1461022057806318160ddd1461024157806323b872dd14610266578063313ce5671461028e5780633c9d93b8146102ba57806340c10f19146102d95780634120657a146102fb5780634c66326d1461031a578063661884631461033957806370a082311461035b5780637d64bcb41461037a57806381788e2b1461038d5780638ce1e6a2146103ac5780638da5cb5b146103cb57806395d89b41146103fa578063a9059cbb1461040d578063b1d6a2f01461042f578063cf1b037c14610442578063d73dd62314610461578063dd62ed3e14610483578063f2fde38b146104a8578063f308846f146104c7575b600080fd5b341561015857600080fd5b6101606104e6565b604051901515815260200160405180910390f35b341561017f57600080fd5b6101876104ef565b60405160208082528190810183818151815260200191508051906020019080838360005b838110156101c35780820151838201526020016101ab565b50505050905090810190601f1680156101f05780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561020957600080fd5b610160600160a060020a0360043516602435610526565b341561022b57600080fd5b61023f600160a060020a0360043516610592565b005b341561024c57600080fd5b610254610602565b60405190815260200160405180910390f35b341561027157600080fd5b610160600160a060020a0360043581169060243516604435610608565b341561029957600080fd5b6102a1610628565b60405163ffffffff909116815260200160405180910390f35b34156102c557600080fd5b61023f600160a060020a036004351661062d565b34156102e457600080fd5b610160600160a060020a0360043516602435610669565b341561030657600080fd5b610160600160a060020a036004351661079c565b341561032557600080fd5b61023f600160a060020a03600435166107b1565b341561034457600080fd5b610160600160a060020a03600435166024356107ed565b341561036657600080fd5b610254600160a060020a03600435166108e7565b341561038557600080fd5b610160610902565b341561039857600080fd5b61023f600160a060020a036004351661098e565b34156103b757600080fd5b610254600160a060020a03600435166109d0565b34156103d657600080fd5b6103de6109e2565b604051600160a060020a03909116815260200160405180910390f35b341561040557600080fd5b6101876109f1565b341561041857600080fd5b610160600160a060020a0360043516602435610a28565b341561043a57600080fd5b6103de610a46565b341561044d57600080fd5b61023f600160a060020a0360043516610a5a565b341561046c57600080fd5b610160600160a060020a0360043516602435610a99565b341561048e57600080fd5b610254600160a060020a0360043581169060243516610b3d565b34156104b357600080fd5b61023f600160a060020a0360043516610b68565b34156104d257600080fd5b610160600160a060020a0360043516610c03565b60055460ff1681565b60408051908101604052600981527f48656c697848696c6c0000000000000000000000000000000000000000000000602082015281565b600160a060020a03338116600081815260046020908152604080832094871680845294909152808220859055909291907f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259085905190815260200160405180910390a350600192915050565b60055433600160a060020a039081166101009092041614806105c2575060005433600160a060020a039081169116145b15156105cd57600080fd5b60058054600160a060020a039092166101000274ffffffffffffffffffffffffffffffffffffffff0019909216919091179055565b60025481565b6000610620610618858585610c18565b858585610c98565b949350505050565b601281565b60005433600160a060020a0390811691161461064857600080fd5b600160a060020a03166000908152600160205260409020805460ff19169055565b60055460009033600160a060020a0390811661010090920416148061069c575060005433600160a060020a039081169116145b80156106ab575060055460ff16155b15156106b657600080fd5b6002546106c9908363ffffffff610d5316565b600255600160a060020a0383166000908152600360205260409020546106f5908363ffffffff610d5316565b600160a060020a038416600081815260036020908152604080832085905560069091529081902092909255907f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d41213968859084905190815260200160405180910390a2600160a060020a03831660007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405190815260200160405180910390a350600192915050565b60016020526000908152604090205460ff1681565b60005433600160a060020a039081169116146107cc57600080fd5b600160a060020a03166000908152600760205260409020805460ff19169055565b600160a060020a0333811660009081526004602090815260408083209386168352929052908120548083111561084a57600160a060020a033381166000908152600460209081526040808320938816835292905290812055610881565b61085a818463ffffffff610d6216565b600160a060020a033381166000908152600460209081526040808320938916835292905220555b600160a060020a0333811660008181526004602090815260408083209489168084529490915290819020547f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925915190815260200160405180910390a35060019392505050565b600160a060020a031660009081526003602052604090205490565b60055460009033600160a060020a03908116610100909204161480610935575060005433600160a060020a039081169116145b8015610944575060055460ff16155b151561094f57600080fd5b6005805460ff191660011790557fae5184fba832cb2b1f702aca6117b8d265eaf03ad33eb133f19dde0f5920fa0860405160405180910390a150600190565b60005433600160a060020a039081169116146109a957600080fd5b600160a060020a03166000908152600160208190526040909120805460ff19169091179055565b60066020526000908152604090205481565b600054600160a060020a031681565b60408051908101604052600481527f48494c4c00000000000000000000000000000000000000000000000000000000602082015281565b6000610a3f610a378484610d74565b338585610c98565b9392505050565b6005546101009004600160a060020a031681565b60005433600160a060020a03908116911614610a7557600080fd5b600160a060020a03166000908152600760205260409020805460ff19166001179055565b600160a060020a033381166000908152600460209081526040808320938616835292905290812054610ad1908363ffffffff610d5316565b600160a060020a0333811660008181526004602090815260408083209489168084529490915290819020849055919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591905190815260200160405180910390a350600192915050565b600160a060020a03918216600090815260046020908152604080832093909416825291909152205490565b60005433600160a060020a03908116911614610b8357600080fd5b600160a060020a0381161515610b9857600080fd5b600054600160a060020a0380831691167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60076020526000908152604090205460ff1681565b600080548490600160a060020a0380831691161480610c495750600554600160a060020a0382811661010090920416145b80610c6c5750600160a060020a03811660009081526001602052604090205460ff165b80610c79575060055460ff165b1515610c8457600080fd5b610c8f858585610dea565b95945050505050565b600080858015610cc05750600160a060020a03841660009081526007602052604090205460ff165b15610d49575082600160a060020a038116633b66d02b86856040517c010000000000000000000000000000000000000000000000000000000063ffffffff8516028152600160a060020a0390921660048301526024820152604401600060405180830381600087803b1515610d3457600080fd5b6102c65a03f11515610d4557600080fd5b5050505b5093949350505050565b600082820183811015610a3f57fe5b600082821115610d6e57fe5b50900390565b600080543390600160a060020a0380831691161480610da55750600554600160a060020a0382811661010090920416145b80610dc85750600160a060020a03811660009081526001602052604090205460ff165b80610dd5575060055460ff165b1515610de057600080fd5b6106208484610f6c565b6000600160a060020a0383161515610e0157600080fd5b600160a060020a038416600090815260036020526040902054821115610e2657600080fd5b600160a060020a0380851660009081526004602090815260408083203390941683529290522054821115610e5957600080fd5b600160a060020a038416600090815260036020526040902054610e82908363ffffffff610d6216565b600160a060020a038086166000908152600360205260408082209390935590851681522054610eb7908363ffffffff610d5316565b600160a060020a03808516600090815260036020908152604080832094909455878316825260048152838220339093168252919091522054610eff908363ffffffff610d6216565b600160a060020a03808616600081815260046020908152604080832033861684529091529081902093909355908516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a35060019392505050565b6000600160a060020a0383161515610f8357600080fd5b600160a060020a033316600090815260036020526040902054821115610fa857600080fd5b600160a060020a033316600090815260036020526040902054610fd1908363ffffffff610d6216565b600160a060020a033381166000908152600360205260408082209390935590851681522054611006908363ffffffff610d5316565b600160a060020a0380851660008181526003602052604090819020939093559133909116907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a3506001929150505600a165627a7a72305820f765092226122938b8289396ef49d030153cb85cb3362d7bef9f739c2a8a6f810029"
}