{
  "address": "0xfe53d681d34cf379782d25af69990f6a707d30d8",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "MonsterAuction",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-02-17\n*/\n\npragma solidity ^0.4.18;\n\n/// @title Interface for contracts conforming to ERC-721: Deed Standard\n/// @author William Entriken (https://phor.net), et. al.\n/// @dev Specification at https://github.com/ethereum/eips/XXXFinalUrlXXX\ninterface ERC721 {\n\n    // COMPLIANCE WITH ERC-165 (DRAFT) /////////////////////////////////////////\n\n    /// @dev ERC-165 (draft) interface signature for itself\n    // bytes4 internal constant INTERFACE_SIGNATURE_ERC165 = // 0x01ffc9a7\n    //     bytes4(keccak256('supportsInterface(bytes4)'));\n\n    /// @dev ERC-165 (draft) interface signature for ERC721\n    // bytes4 internal constant INTERFACE_SIGNATURE_ERC721 = // 0xda671b9b\n    //     bytes4(keccak256('ownerOf(uint256)')) ^\n    //     bytes4(keccak256('countOfDeeds()')) ^\n    //     bytes4(keccak256('countOfDeedsByOwner(address)')) ^\n    //     bytes4(keccak256('deedOfOwnerByIndex(address,uint256)')) ^\n    //     bytes4(keccak256('approve(address,uint256)')) ^\n    //     bytes4(keccak256('takeOwnership(uint256)'));\n\n    /// @notice Query a contract to see if it supports a certain interface\n    /// @dev Returns `true` the interface is supported and `false` otherwise,\n    ///  returns `true` for INTERFACE_SIGNATURE_ERC165 and\n    ///  INTERFACE_SIGNATURE_ERC721, see ERC-165 for other interface signatures.\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool);\n\n    // PUBLIC QUERY FUNCTIONS //////////////////////////////////////////////////\n\n    /// @notice Find the owner of a deed\n    /// @param _deedId The identifier for a deed we are inspecting\n    /// @dev Deeds assigned to zero address are considered invalid, and\n    ///  queries about them do throw.\n    /// @return The non-zero address of the owner of deed `_deedId`, or `throw`\n    ///  if deed `_deedId` is not tracked by this contract\n    function ownerOf(uint256 _deedId) external view returns (address _owner);\n\n    /// @notice Count deeds tracked by this contract\n    /// @return A count of valid deeds tracked by this contract, where each one of\n    ///  them has an assigned and queryable owner not equal to the zero address\n    function countOfDeeds() external view returns (uint256 _count);\n\n    /// @notice Count all deeds assigned to an owner\n    /// @dev Throws if `_owner` is the zero address, representing invalid deeds.\n    /// @param _owner An address where we are interested in deeds owned by them\n    /// @return The number of deeds owned by `_owner`, possibly zero\n    function countOfDeedsByOwner(address _owner) external view returns (uint256 _count);\n\n    /// @notice Enumerate deeds assigned to an owner\n    /// @dev Throws if `_index` >= `countOfDeedsByOwner(_owner)` or if\n    ///  `_owner` is the zero address, representing invalid deeds.\n    /// @param _owner An address where we are interested in deeds owned by them\n    /// @param _index A counter less than `countOfDeedsByOwner(_owner)`\n    /// @return The identifier for the `_index`th deed assigned to `_owner`,\n    ///   (sort order not specified)\n    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId);\n\n    // TRANSFER MECHANISM //////////////////////////////////////////////////////\n\n    /// @dev This event emits when ownership of any deed changes by any\n    ///  mechanism. This event emits when deeds are created (`from` == 0) and\n    ///  destroyed (`to` == 0). Exception: during contract creation, any\n    ///  transfers may occur without emitting `Transfer`. At the time of any transfer,\n    ///  the \"approved taker\" is implicitly reset to the zero address.\n    event Transfer(address indexed from, address indexed to, uint256 indexed deedId);\n\n    /// @dev The Approve event emits to log the \"approved taker\" for a deed -- whether\n    ///  set for the first time, reaffirmed by setting the same value, or setting to\n    ///  a new value. The \"approved taker\" is the zero address if nobody can take the\n    ///  deed now or it is an address if that address can call `takeOwnership` to attempt\n    ///  taking the deed. Any change to the \"approved taker\" for a deed SHALL cause\n    ///  Approve to emit. However, an exception, the Approve event will not emit when\n    ///  Transfer emits, this is because Transfer implicitly denotes the \"approved taker\"\n    ///  is reset to the zero address.\n    event Approval(address indexed owner, address indexed approved, uint256 indexed deedId);\n\n    /// @notice Set the \"approved taker\" for your deed, or revoke approval by\n    ///  setting the zero address. You may `approve` any number of times while\n    ///  the deed is assigned to you, only the most recent approval matters. Emits\n    ///  an Approval event.\n    /// @dev Throws if `msg.sender` does not own deed `_deedId` or if `_to` ==\n    ///  `msg.sender` or if `_deedId` is not a valid deed.\n    /// @param _deedId The deed for which you are granting approval\n    function approve(address _to, uint256 _deedId) external payable;\n\n    /// @notice Become owner of a deed for which you are currently approved\n    /// @dev Throws if `msg.sender` is not approved to become the owner of\n    ///  `deedId` or if `msg.sender` currently owns `_deedId` or if `_deedId is not a\n    ///  valid deed.\n    /// @param _deedId The deed that is being transferred\n    function takeOwnership(uint256 _deedId) external payable;\n}\n\ncontract Ownable {\n    address public owner;\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    function Ownable() public {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n\ncontract MonsterAccessControl {\n    event ContractUpgrade(address newContract);\n\n     // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public adminAddress;\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier onlyAdmin() {\n        require(msg.sender == adminAddress);\n        _;\n    }\n}\n\n// This contract stores all data on the blockchain\n// only our other contracts can interact with this\n// the data here will be valid for all eternity even if other contracts get updated\n// this way we can make sure that our Monsters have a hard-coded value attached to them\n// that no one including us can change(!)\ncontract MonstersData {\n    address coreContract;\n\n    struct Monster {\n        // timestamp of block when this monster was spawned/created\n        uint64 birthTime;\n\n        // generation number\n        // gen0 is the very first generation - the later monster spawn the less likely they are to have\n        // special attributes and stats\n        uint16 generation;\n\n        uint16 mID; // this id (from 1 to 151) is responsible for everything visually like showing the real deal!\n        bool tradeable;\n\n        // breeding\n        bool female;\n\n        // is this monster exceptionally rare?\n        bool shiny;\n    }\n\n    // lv1 base stats\n    struct MonsterBaseStats {\n        uint16 hp;\n        uint16 attack;\n        uint16 defense;\n        uint16 spAttack;\n        uint16 spDefense;\n        uint16 speed;\n    }\n\n    struct Trainer {\n        // timestamp of block when this player/trainer was created\n        uint64 birthTime;\n\n        // add username\n        string username;\n\n        // current area in the \"world\"\n        uint16 currArea;\n\n        address owner;\n    }\n\n    // take timestamp of block this game was created on the blockchain\n    uint64 creationBlock = uint64(now);\n}\n\ncontract MonstersBase is MonsterAccessControl, MonstersData {\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a monster\n    ///  ownership is assigned, including births.\n    event Transfer(address from, address to, uint256 tokenId);\n\n    bool lockedMonsterCreator = false;\n\n    MonsterAuction public monsterAuction;\n    MonsterCreatorInterface public monsterCreator;\n\n    function setMonsterCreatorAddress(address _address) external onlyAdmin {\n        // only set this once so we (the devs) can't cheat!\n        require(!lockedMonsterCreator);\n        MonsterCreatorInterface candidateContract = MonsterCreatorInterface(_address);\n\n        monsterCreator = candidateContract;\n        lockedMonsterCreator = true;\n    }\n\n    // An approximation of currently how many seconds are in between blocks.\n    uint256 public secondsPerBlock = 15;\n\n    // array containing all monsters in existence\n    Monster[] monsters;\n\n    uint8[] areas;\n    uint8 areaIndex = 0;\n\n    mapping(address => Trainer) public addressToTrainer;\n    /// @dev A mapping from monster IDs to the address that owns them. All monster have\n    ///  some valid owner address, even gen0 monster are created with a non-zero owner.\n    mapping (uint256 => address) public monsterIndexToOwner;\n    // @dev A mapping from owner address to count of tokens that address owns.\n    // Used internally inside balanceOf() to resolve ownership count.\n    mapping (address => uint256) ownershipTokenCount;\n    mapping (uint256 => address) public monsterIndexToApproved;\n    mapping (uint256 => string) public monsterIdToNickname;\n    mapping (uint256 => bool) public monsterIdToTradeable;\n    mapping (uint256 => uint256) public monsterIdToGeneration;\n    \n    mapping (uint256 => uint8[7]) public monsterIdToIVs;\n\n    // adds new area to world\n    function _createArea() internal {\n        areaIndex++;\n        areas.push(areaIndex);\n    }\n\n    function _createMonster(uint256 _generation, address _owner, uint256 _mID, bool _tradeable,\n        bool _female, bool _shiny) internal returns (uint)\n    {\n\n        Monster memory _monster = Monster({\n            generation: uint16(_generation),\n            birthTime: uint64(now),\n            mID: uint16(_mID),\n            tradeable: _tradeable,\n            female: _female,\n            shiny: _shiny\n        });\n\n        uint256 newMonsterId = monsters.push(_monster) - 1;\n\n        require(newMonsterId == uint256(uint32(newMonsterId)));\n\n        monsterIdToNickname[newMonsterId] = \"\";\n\n        _transfer(0, _owner, newMonsterId);\n\n        return newMonsterId;\n    }\n\n    function _createTrainer(string _username, uint16 _starterId, address _owner) internal returns (uint mon) {\n        Trainer memory _trainer = Trainer({\n            birthTime: uint64(now),\n            username: string(_username),\n             // sets to first area!,\n            currArea: uint16(1),\n            owner: address(_owner)\n        });\n\n        addressToTrainer[_owner] = _trainer;\n\n        bool gender = monsterCreator.getMonsterGender();\n\n        // starters cannot be traded and are not shiny\n        if (_starterId == 1) {\n            mon = _createMonster(0, _owner, 1, false, gender, false);\n        } else if (_starterId == 2) {\n            mon = _createMonster(0, _owner, 4, false, gender, false);\n        } else if (_starterId == 3) {\n            mon = _createMonster(0, _owner, 7, false, gender, false);\n        }\n    }\n\n    function _moveToArea(uint16 _newArea, address player) internal {\n        addressToTrainer[player].currArea = _newArea;\n    }\n\n    // assigns ownership of monster to address\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n        ownershipTokenCount[_to]++;\n        monsterIndexToOwner[_tokenId] = _to;\n\n        if (_from != address(0)) {\n            ownershipTokenCount[_from]--;\n\n            // clear any previously approved ownership exchange\n            delete monsterIndexToApproved[_tokenId];\n        }\n\n        // Emit Transfer event\n        Transfer(_from, _to, _tokenId);\n    }\n\n    // Only admin can fix how many seconds per blocks are currently observed.\n    function setSecondsPerBlock(uint256 secs) external onlyAdmin {\n        //require(secs < cooldowns[0]);\n        secondsPerBlock = secs;\n    }\n}\n\ncontract MonsterOwnership is MonstersBase, ERC721 {\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return monsterIndexToOwner[_tokenId] == _claimant;\n    }\n\n    function _isTradeable(uint256 _tokenId) public view returns (bool) {\n        return monsterIdToTradeable[_tokenId];\n    }\n\n    /// @dev Checks if a given address currently has transferApproval for a particular monster.\n    /// @param _claimant the address we are confirming monster is approved for.\n    /// @param _tokenId monster id, only valid when > 0\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return monsterIndexToApproved[_tokenId] == _claimant;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 count) {\n        return ownershipTokenCount[_owner];\n    }\n\n    function transfer(address _to, uint256 _tokenId) public payable {\n        transferFrom(msg.sender, _to, _tokenId);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) public payable {\n        require(monsterIdToTradeable[_tokenId]);\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any monsters (except very briefly\n        // after a gen0 monster is created and before it goes on auction).\n        require(_to != address(this));\n        // Check for approval and valid ownership\n        \n        require(_owns(_from, _tokenId));\n        // checks if _to was aproved\n        require(_from == msg.sender || msg.sender == address(monsterAuction) || _approvedFor(_to, _tokenId));\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _tokenId);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return monsters.length;\n    }\n\n    function tokensOfOwner(address _owner) public view returns (uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount > 0) {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalMonsters = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 monsterId;\n\n            for (monsterId = 0; monsterId <= totalMonsters; monsterId++) {\n                if (monsterIndexToOwner[monsterId] == _owner) {\n                    result[resultIndex] = monsterId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n\n        return new uint256[](0);\n    }\n\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC165 =\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\n\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC721 =\n        bytes4(keccak256(\"ownerOf(uint256)\")) ^\n        bytes4(keccak256(\"countOfDeeds()\")) ^\n        bytes4(keccak256(\"countOfDeedsByOwner(address)\")) ^\n        bytes4(keccak256(\"deedOfOwnerByIndex(address,uint256)\")) ^\n        bytes4(keccak256(\"approve(address,uint256)\")) ^\n        bytes4(keccak256(\"takeOwnership(uint256)\"));\n\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\n        return _interfaceID == INTERFACE_SIGNATURE_ERC165 || _interfaceID == INTERFACE_SIGNATURE_ERC721;\n    }\n\n    function ownerOf(uint256 _deedId) external view returns (address _owner) {\n        var owner = monsterIndexToOwner[_deedId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    function _approve(uint256 _tokenId, address _approved) internal {\n        monsterIndexToApproved[_tokenId] = _approved;\n    }\n\n    function countOfDeeds() external view returns (uint256 _count) {\n        return totalSupply();\n    }\n\n    function countOfDeedsByOwner(address _owner) external view returns (uint256 _count) {\n        var arr = tokensOfOwner(_owner);\n        return arr.length;\n    }\n\n    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId) {\n        return tokensOfOwner(_owner)[_index];\n    }\n\n    function approve(address _to, uint256 _tokenId) external payable {\n        // Only an owner can grant transfer approval.\n        require(_owns(msg.sender, _tokenId));\n\n        // Register the approval (replacing any previous approval).\n        monsterIndexToApproved[_tokenId] = _to;\n\n        // Emit approval event.\n        Approval(msg.sender, _to, _tokenId);\n    }\n\n    function takeOwnership(uint256 _deedId) external payable {\n        transferFrom(this.ownerOf(_deedId), msg.sender, _deedId);\n    }\n}\n\ncontract MonsterAuctionBase {\n\n    // Reference to contract tracking NFT ownership\n    MonsterOwnership public nonFungibleContract;\n    ChainMonstersCore public core;\n\n    struct Auction {\n        // current owner\n        address seller;\n        // price in wei\n        uint256 price;\n        // time when auction started\n        uint64 startedAt;\n        uint256 id;\n    }\n\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\n    // Values 0-10,000 map to 0%-100%\n    uint256 public ownerCut;\n\n    // Map from token ID to their corresponding auction.\n    mapping(uint256 => Auction) tokenIdToAuction;\n    mapping(uint256 => address) public auctionIdToSeller;\n    mapping (address => uint256) public ownershipAuctionCount;\n\n    event AuctionCreated(uint256 tokenId, uint256 price, uint256 uID, address seller);\n    event AuctionSuccessful(uint256 tokenId, uint256 price, address newOwner, uint256 uID);\n    event AuctionCancelled(uint256 tokenId, uint256 uID);\n\n    function _transfer(address _receiver, uint256 _tokenId) internal {\n        // it will throw if transfer fails\n        nonFungibleContract.transfer(_receiver, _tokenId);\n    }\n\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\n        tokenIdToAuction[_tokenId] = _auction;\n\n        AuctionCreated(\n            uint256(_tokenId),\n            uint256(_auction.price),\n            uint256(_auction.id),\n            address(_auction.seller)\n        );\n    }\n\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\n        Auction storage _auction = tokenIdToAuction[_tokenId];\n\n        uint256 uID = _auction.id;\n\n        _removeAuction(_tokenId);\n        ownershipAuctionCount[_seller]--;\n        _transfer(_seller, _tokenId);\n\n        AuctionCancelled(_tokenId, uID);\n    }\n\n    function _buy(uint256 _tokenId, uint256 _bidAmount) internal returns (uint256) {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n\n        require(_isOnAuction(auction));\n\n        uint256 price = auction.price;\n        require(_bidAmount >= price);\n\n        address seller = auction.seller;\n        uint256 uID = auction.id;\n\n        // Auction Bid looks fine! so remove\n        _removeAuction(_tokenId);\n\n        ownershipAuctionCount[seller]--;\n\n        if (price > 0) {\n            uint256 auctioneerCut = _computeCut(price);\n            uint256 sellerProceeds = price - auctioneerCut;\n\n            // NOTE: Doing a transfer() in the middle of a complex\n            // method like this is generally discouraged because of\n            // reentrancy attacks and DoS attacks if the seller is\n            // a contract with an invalid fallback function. We explicitly\n            // guard against reentrancy attacks by removing the auction\n            // before calling transfer(), and the only thing the seller\n            // can DoS is the sale of their own asset! (And if it's an\n            // accident, they can call cancelAuction(). )\n            if (seller != address(core)) {\n                seller.transfer(sellerProceeds);\n            }\n        }\n\n        // Calculate any excess funds included with the bid. If the excess\n        // is anything worth worrying about, transfer it back to bidder.\n        // NOTE: We checked above that the bid amount is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 bidExcess = _bidAmount - price;\n\n        // Return the funds. Similar to the previous transfer, this is\n        // not susceptible to a re-entry attack because the auction is\n        // removed before any transfers occur.\n        msg.sender.transfer(bidExcess);\n\n        // Tell the world!\n        AuctionSuccessful(_tokenId, price, msg.sender, uID);\n\n        return price;\n    }\n\n    function _removeAuction(uint256 _tokenId) internal {\n        delete tokenIdToAuction[_tokenId];\n    }\n\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\n        return (_auction.startedAt > 0);\n    }\n\n     function _computeCut(uint256 _price) internal view returns (uint256) {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our entry functions carefully cap the maximum values for\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n        //  statement in the ClockAuction constructor). The result of this\n        //  function is always guaranteed to be <= _price.\n        return _price * ownerCut / 10000;\n    }\n}\n\ncontract MonsterAuction is  MonsterAuctionBase, Ownable {\n    bool public isMonsterAuction = true;\n    uint256 public auctionIndex = 0;\n\n    function MonsterAuction(address _nftAddress, uint256 _cut) public {\n        require(_cut <= 10000);\n        ownerCut = _cut;\n\n        var candidateContract = MonsterOwnership(_nftAddress);\n\n        nonFungibleContract = candidateContract;\n        ChainMonstersCore candidateCoreContract = ChainMonstersCore(_nftAddress);\n        core = candidateCoreContract;\n    }\n\n    // only possible to decrease ownerCut!\n    function setOwnerCut(uint256 _cut) external onlyOwner {\n        require(_cut <= ownerCut);\n        ownerCut = _cut;\n    }\n\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n    }\n\n    function _escrow(address _owner, uint256 _tokenId) internal {\n        // it will throw if transfer fails\n        nonFungibleContract.transferFrom(_owner, this, _tokenId);\n    }\n\n    function withdrawBalance() external onlyOwner {\n        uint256 balance = this.balance;\n        owner.transfer(balance);\n    }\n\n    function tokensInAuctionsOfOwner(address _owner) external view returns(uint256[] auctionTokens) {\n        uint256 numAuctions = ownershipAuctionCount[_owner];\n\n        uint256[] memory result = new uint256[](numAuctions);\n        uint256 totalAuctions = core.totalSupply();\n        uint256 resultIndex = 0;\n\n        uint256 auctionId;\n\n        for (auctionId = 0; auctionId <= totalAuctions; auctionId++) {\n            Auction storage auction = tokenIdToAuction[auctionId];\n            if (auction.seller == _owner) {\n                result[resultIndex] = auctionId;\n                resultIndex++;\n            }\n        }\n\n        return result;\n    }\n\n    function createAuction(uint256 _tokenId, uint256 _price, address _seller) external {\n        require(_seller != address(0));\n        require(_price == uint256(_price));\n        require(core._isTradeable(_tokenId));\n        require(_owns(msg.sender, _tokenId));\n\n        \n        _escrow(msg.sender, _tokenId);\n\n        Auction memory auction = Auction(\n            _seller,\n            uint256(_price),\n            uint64(now),\n            uint256(auctionIndex)\n        );\n\n        auctionIdToSeller[auctionIndex] = _seller;\n        ownershipAuctionCount[_seller]++;\n\n        auctionIndex++;\n        _addAuction(_tokenId, auction);\n    }\n\n    function buy(uint256 _tokenId) external payable {\n        //delete auctionIdToSeller[_tokenId];\n        // buy will throw if the bid or funds transfer fails\n        _buy (_tokenId, msg.value);\n        _transfer(msg.sender, _tokenId);\n    }\n\n    function cancelAuction(uint256 _tokenId) external {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n\n        address seller = auction.seller;\n        require(msg.sender == seller);\n\n        _cancelAuction(_tokenId, seller);\n    }\n\n    function getAuction(uint256 _tokenId) external view returns (address seller, uint256 price, uint256 startedAt) {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n\n        return (\n            auction.seller,\n            auction.price,\n            auction.startedAt\n        );\n    }\n\n    function getPrice(uint256 _tokenId) external view returns (uint256) {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        return auction.price;\n    }\n}\n\ncontract ChainMonstersAuction is MonsterOwnership {\n    bool lockedMonsterAuction = false;\n\n    function setMonsterAuctionAddress(address _address) external onlyAdmin {\n        require(!lockedMonsterAuction);\n        MonsterAuction candidateContract = MonsterAuction(_address);\n\n        require(candidateContract.isMonsterAuction());\n\n        monsterAuction = candidateContract;\n        lockedMonsterAuction = true;\n    }\n\n    uint256 public constant PROMO_CREATION_LIMIT = 5000;\n    uint256 public constant GEN0_CREATION_LIMIT = 5000;\n\n    // Counts the number of monster the contract owner has created.\n    uint256 public promoCreatedCount;\n    uint256 public gen0CreatedCount;\n\n    // its stats are completely dependent on the spawn alghorithm\n    function createPromoMonster(uint256 _mId, address _owner) external onlyAdmin {\n        // during generation we have to keep in mind that we have only 10,000 tokens available\n        // which have to be divided by 151 monsters, some rarer than others\n        // see WhitePaper for gen0/promo monster plan\n        \n        // sanity check that this monster ID is actually in game yet\n        require(monsterCreator.baseStats(_mId, 1) > 0);\n        \n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\n\n        promoCreatedCount++;\n\n        uint8[7] memory ivs = uint8[7](monsterCreator.getGen0IVs());\n\n        bool gender = monsterCreator.getMonsterGender();\n        \n        bool shiny = false;\n        if (ivs[6] == 1) {\n            shiny = true;\n        }\n        uint256 monsterId = _createMonster(0, _owner, _mId, true, gender, shiny);\n        monsterIdToTradeable[monsterId] = true;\n\n        monsterIdToIVs[monsterId] = ivs;\n    }\n\n    function createGen0Auction(uint256 _mId, uint256 price) external onlyAdmin {\n         // sanity check that this monster ID is actually in game yet\n        require(monsterCreator.baseStats(_mId, 1) > 0);\n        \n        require(gen0CreatedCount < GEN0_CREATION_LIMIT);\n\n        uint8[7] memory ivs = uint8[7](monsterCreator.getGen0IVs());\n\n        bool gender = monsterCreator.getMonsterGender();\n        \n        bool shiny = false;\n        if (ivs[6] == 1) {\n            shiny = true;\n        }\n        \n        uint256 monsterId = _createMonster(0, this, _mId, true, gender, shiny);\n        monsterIdToTradeable[monsterId] = true;\n\n        _approve(monsterId, monsterAuction);\n\n        monsterIdToIVs[monsterId] = ivs;\n\n        monsterAuction.createAuction(monsterId, price, address(this));\n\n        gen0CreatedCount++;\n    }\n}\n\n// used during launch for world championship\n// can and will be upgraded during development with new battle system!\n// this is just to give players something to do and test their monsters\n// also demonstrates how we can build up more mechanics on top of our locked core contract!\ncontract MonsterChampionship is Ownable {\n\n    bool public isMonsterChampionship = true;\n\n    ChainMonstersCore core;\n\n    // list of top ten\n    address[10] topTen;\n\n    // holds the address current \"world\" champion\n    address public currChampion;\n\n    mapping (address => uint256) public addressToPowerlevel;\n    mapping (uint256 => address) public rankToAddress;\n\n    // try to beat every other player in the top10 with your strongest monster!\n    // effectively looping through all top10 players, beating them one by one\n    // and if strong enough placing your in the top10 as well\n    function contestChampion(uint256 _tokenId) external {\n        uint maxIndex = 9;\n\n        // fail tx if player is already champion!\n        // in theory players could increase their powerlevel by contesting themselves but\n        // this check stops that from happening so other players have the chance to\n        // become the temporary champion!\n        if (currChampion == msg.sender) {\n            revert();\n        }\n\n        require(core.isTrainer(msg.sender));\n        require(core.monsterIndexToOwner(_tokenId) == msg.sender);\n\n        uint myPowerlevel = 10; // todo add calculation method to this contract!\n\n        // checks if this transaction is useless\n        // since we can't fight against ourself!\n        // also stops reentrancy attacks\n        require(myPowerlevel > addressToPowerlevel[msg.sender]);\n\n        uint myRank = 0;\n\n        for (uint i = 0; i <= maxIndex; i++) {\n            if (myPowerlevel > addressToPowerlevel[topTen[i]]) {\n                // you have beaten this one so increase temporary rank\n                myRank = i;\n\n                if (myRank == maxIndex) {\n                    currChampion = msg.sender;\n                }\n            }\n        }\n\n        addressToPowerlevel[msg.sender] = myPowerlevel;\n\n        address[10] storage newTopTen = topTen;\n\n        if (currChampion == msg.sender) {\n            for (uint j = 0; j < maxIndex; j++) {\n                // remove ourselves from this list in case\n                if (newTopTen[j] == msg.sender) {\n                    newTopTen[j] = 0x0;\n                    break;\n                }\n            }\n        }\n\n        for (uint x = 0; x <= myRank; x++) {\n            if (x == myRank) {\n                newTopTen[x] = msg.sender;\n            } else {\n                if (x < maxIndex)\n                    newTopTen[x] = topTen[x+1];\n            }\n        }\n\n        topTen = newTopTen;\n    }\n\n    function getTopPlayers() external view returns (address[10] players) {\n        players = topTen;\n    }\n\n    function MonsterChampionship(address coreContract) public {\n        core = ChainMonstersCore(coreContract);\n    }\n\n    function withdrawBalance() external onlyOwner {\n        uint256 balance = this.balance;\n        owner.transfer(balance);\n    }\n}\n\n\n// where the not-so-much \"hidden\" magic happens\ncontract MonsterCreatorInterface is Ownable {\n    uint8 public lockedMonsterStatsCount = 0;\n    uint nonce = 0;\n\n    function rand(uint16 min, uint16 max) public returns (uint16) {\n        nonce++;\n        uint16 result = (uint16(keccak256(block.blockhash(block.number-1), nonce))%max);\n\n        if (result < min) {\n            result = result+min;\n        }\n\n        return result;\n    }\n\n    mapping(uint256 => uint8[8]) public baseStats;\n\n    function addBaseStats(uint256 _mId, uint8[8] data) external onlyOwner {\n        // lock\" the stats down forever\n        // since hp is never going to be 0 this is a valid check\n        // so we have to be extra careful when adding new baseStats!\n        require(data[0] > 0);\n        require(baseStats[_mId][0] == 0);\n        baseStats[_mId] = data;\n    }\n\n    function _addBaseStats(uint256 _mId, uint8[8] data) internal {\n        baseStats[_mId] = data;\n        lockedMonsterStatsCount++;\n    }\n\n    function MonsterCreatorInterface() public {\n       // these monsters are already down and \"locked\" down stats/design wise\n        _addBaseStats(1, [45, 49, 49, 65, 65, 45, 12, 4]);\n        _addBaseStats(2, [60, 62, 63, 80, 80, 60, 12, 4]);\n        _addBaseStats(3, [80, 82, 83, 100, 100, 80, 12, 4]);\n        _addBaseStats(4, [39, 52, 43, 60, 50, 65, 10, 6]);\n        _addBaseStats(5, [58, 64, 58, 80, 65, 80, 10, 6]);\n        _addBaseStats(6, [78, 84, 78, 109, 85, 100, 10, 6]);\n        _addBaseStats(7, [44, 48, 65, 50, 64, 43, 11, 14]);\n        _addBaseStats(8, [59, 63, 80, 65, 80, 58, 11, 14]);\n        _addBaseStats(9, [79, 83, 100, 85, 105, 78, 11, 14]);\n        _addBaseStats(10, [40, 35, 30, 20, 20, 50, 7, 4]);\n\n        _addBaseStats(149, [55, 50, 45, 135, 95, 120, 8, 14]);\n        _addBaseStats(150, [91, 134, 95, 100, 100, 80, 2, 5]);\n        _addBaseStats(151, [100, 100, 100, 100, 100, 100, 5, 19]);\n    }\n\n    // this serves as a lookup for new monsters to be generated since all monsters\n    // of the same id share the base stats\n    // also makes it possible to only store the monsterId on core and change this one\n    // during evolution process to save gas and additional transactions\n    function getMonsterStats( uint256 _mID) external constant returns(uint8[8] stats) {\n        stats[0] = baseStats[_mID][0];\n        stats[1] = baseStats[_mID][1];\n        stats[2] = baseStats[_mID][2];\n        stats[3] = baseStats[_mID][3];\n        stats[4] = baseStats[_mID][4];\n        stats[5] = baseStats[_mID][5];\n        stats[6] = baseStats[_mID][6];\n        stats[7] = baseStats[_mID][7];\n    }\n\n    function getMonsterGender () external returns(bool female) {\n        uint16 femaleChance = rand(0, 100);\n\n        if (femaleChance >= 50) {\n            female = true;\n        }\n    }\n\n    // generates randomized IVs for a new monster\n    function getMonsterIVs() external returns(uint8[7] ivs) {\n        bool shiny = false;\n\n        uint16 chance = rand(1, 8192);\n\n        if (chance == 42) {\n            shiny = true;\n        }\n\n        // IVs range between 0 and 31\n        // stat range modified for shiny monsters!\n        if (shiny) {\n            ivs[0] = uint8(rand(10, 31));\n            ivs[1] = uint8(rand(10, 31));\n            ivs[2] = uint8(rand(10, 31));\n            ivs[3] = uint8(rand(10, 31));\n            ivs[4] = uint8(rand(10, 31));\n            ivs[5] = uint8(rand(10, 31));\n            ivs[6] = 1;\n\n        } else {\n            ivs[0] = uint8(rand(0, 31));\n            ivs[1] = uint8(rand(0, 31));\n            ivs[2] = uint8(rand(0, 31));\n            ivs[3] = uint8(rand(0, 31));\n            ivs[4] = uint8(rand(0, 31));\n            ivs[5] = uint8(rand(0, 31));\n            ivs[6] = 0;\n        }\n    }\n\n    // gen0 monsters profit from shiny boost while shiny gen0s have potentially even higher IVs!\n    // further increasing the rarity by also doubling the shiny chance!\n    function getGen0IVs() external returns (uint8[7] ivs) {\n        bool shiny = false;\n\n        uint16 chance = rand(1, 4096);\n\n        if (chance == 42) {\n            shiny = true;\n        }\n\n        if (shiny) {\n            ivs[0] = uint8(rand(15, 31));\n            ivs[1] = uint8(rand(15, 31));\n            ivs[2] = uint8(rand(15, 31));\n            ivs[3] = uint8(rand(15, 31));\n            ivs[4] = uint8(rand(15, 31));\n            ivs[5] = uint8(rand(15, 31));\n            ivs[6] = 1;\n        } else {\n            ivs[0] = uint8(rand(10, 31));\n            ivs[1] = uint8(rand(10, 31));\n            ivs[2] = uint8(rand(10, 31));\n            ivs[3] = uint8(rand(10, 31));\n            ivs[4] = uint8(rand(10, 31));\n            ivs[5] = uint8(rand(10, 31));\n            ivs[6] = 0;\n        }\n    }\n\n    function withdrawBalance() external onlyOwner {\n        uint256 balance = this.balance;\n        owner.transfer(balance);\n    }\n}\n\ncontract GameLogicContract {\n    bool public isGameLogicContract = true;\n\n    function GameLogicContract() public {\n\n    }\n}\n\n\ncontract OmegaContract {\n    bool public isOmegaContract = true;\n\n    function OmegaContract() public {\n\n    }\n}\n\ncontract ChainMonstersCore is ChainMonstersAuction, Ownable {\n    // using a bool to enable us to prepare the game\n    bool hasLaunched = false;\n\n    // this address will hold future gamelogic in place\n    address gameContract;\n\n    // this contract\n    address omegaContract;\n\n    function ChainMonstersCore() public {\n        adminAddress = msg.sender;\n\n        _createArea(); // area 1\n        _createArea(); // area 2\n    }\n\n    // we don't know the exact interfaces yet so use the lockedMonsterStats value to determine if the game is \"ready\"\n    // see WhitePaper for explaination for our upgrade and development roadmap\n    function setGameLogicContract(address _candidateContract) external onlyOwner {\n        require(monsterCreator.lockedMonsterStatsCount() == 151);\n\n        require(GameLogicContract(_candidateContract).isGameLogicContract());\n\n        gameContract = _candidateContract;\n    }\n\n    function setOmegaContract(address _candidateContract) external onlyOwner {\n        require(OmegaContract(_candidateContract).isOmegaContract());\n        omegaContract = _candidateContract;\n    }\n\n    // omega contract takes care of all neccessary checks so assume that this is correct(!)\n    function evolveMonster(uint256 _tokenId, uint16 _toMonsterId) external {\n        require(msg.sender == omegaContract);\n\n        // retrieve current monster struct\n        Monster storage mon = monsters[_tokenId];\n\n        // evolving only changes monster ID since this is responsible for base Stats\n        // an evolved monster keeps its gender, generation, IVs and EVs\n        mon.mID = _toMonsterId;\n    }\n\n    // only callable by gameContract after the full game is launched\n    // since all additional monsters after the promo/gen0 ones need to use this coreContract\n    // contract as well we have to prepare this core for our future updates where\n    // players can freely roam the world and hunt ChainMonsters thus generating more\n    function spawnMonster(uint256 _mId, address _owner) external {\n        require(msg.sender == gameContract);\n\n        uint8[7] memory ivs = uint8[7](monsterCreator.getMonsterIVs());\n\n        bool gender = monsterCreator.getMonsterGender();\n\n        bool shiny = false;\n        if (ivs[6] == 1) {\n            shiny = true;\n        }\n        \n        // important to note that the IV generators do not use Gen0 methods and are Generation 1\n        // this means there won't be more than the 10,000 Gen0 monsters sold during the development through the marketplace\n        uint256 monsterId = _createMonster(1, _owner, _mId, false, gender, shiny);\n        monsterIdToTradeable[monsterId] = true;\n\n        monsterIdToIVs[monsterId] = ivs;\n    }\n\n    // used to add playable content to the game\n    // monsters will only spawn in certain areas so some are locked on release\n    // due to the game being in active development on \"launch\"\n    // each monster has a maximum number of 3 areas where it can appear\n    function createArea() public onlyAdmin {\n        _createArea();\n    }\n\n    function createTrainer(string _username, uint16 _starterId) public {\n        require(hasLaunched);\n\n        // only one trainer/account per ethereum address\n        require(addressToTrainer[msg.sender].owner == 0);\n\n        // valid input check\n        require(_starterId == 1 || _starterId == 2 || _starterId == 3);\n\n        uint256 mon = _createTrainer(_username, _starterId, msg.sender);\n\n        // due to stack limitations we have to assign the IVs here:\n        monsterIdToIVs[mon] = monsterCreator.getMonsterIVs();\n    }\n\n    function changeUsername(string _name) public {\n        require(addressToTrainer[msg.sender].owner == msg.sender);\n        addressToTrainer[msg.sender].username = _name;\n    }\n\n    function changeMonsterNickname(uint256 _tokenId, string _name) public {\n        // users won't be able to rename a monster that is part of an auction\n        require(_owns(msg.sender, _tokenId));\n\n        // some string checks...?\n        monsterIdToNickname[_tokenId] = _name;\n    }\n\n    function moveToArea(uint16 _newArea) public {\n        require(addressToTrainer[msg.sender].currArea > 0);\n\n        // never allow anyone to move to area 0 or below since this is used\n        // to determine if a trainer profile exists in another method!\n        require(_newArea > 0);\n\n        // make sure that this area exists yet!\n        require(areas.length >= _newArea);\n\n        // when player is not stuck doing something else he can move freely!\n        _moveToArea(_newArea, msg.sender);\n    }\n\n    // to be changed to retrieve current stats!\n    function getMonster(uint256 _id) external view returns (\n        uint256 birthTime, uint256 generation, uint8[8] stats,\n        uint256 mID, bool tradeable, uint256 uID)\n    {\n        Monster storage mon = monsters[_id];\n        birthTime = uint256(mon.birthTime);\n        generation = mon.generation; // hardcoding due to stack too deep error\n        mID = uint256(mon.mID);\n        tradeable = bool(mon.tradeable);\n\n        // these values are retrieved from monsterCreator\n        stats = uint8[8](monsterCreator.getMonsterStats(uint256(mon.mID)));\n\n        // hack to overcome solidity's stack limitation in monster struct....\n        uID = _id;\n    }\n\n    function isTrainer(address _check) external view returns (bool isTrainer) {\n        Trainer storage trainer = addressToTrainer[_check];\n\n        return (trainer.currArea > 0);\n    }\n\n    function withdrawBalance() external onlyOwner {\n        uint256 balance = this.balance;\n\n        owner.transfer(balance);\n    }\n\n    // after we have setup everything we can unlock the game\n    // for public\n    function launchGame() external onlyOwner {\n        hasLaunched = true;\n    }\n}",
  "bytecode": "60606040526006805460a060020a60ff021916740100000000000000000000000000000000000000001790556000600755341561003b57600080fd5b604051604080610da1833981016040528080519190602001805160068054600160a060020a03191633600160a060020a03161790559150600090508061271083111561008657600080fd5b505060025560008054600160a060020a03909216600160a060020a0319928316811790915560018054909216179055610cdd806100c46000396000f3006060604052600436106100d75763ffffffff60e060020a6000350416631a02af4081146100dc5780632fe29c781461014e57806354279bdd146101805780635fd8c710146101a7578063757de573146101ba57806378bd7935146101d05780637aacf03c1461021c57806383b5ff8b146102415780638da5cb5b1461025457806396b5a75514610267578063bfab4f8b1461027d578063d96a094a146102a4578063dd1b7a0f146102af578063e7572230146102c2578063e7751e48146102d8578063f2f4eb26146102f7578063f2fde38b1461030a575b600080fd5b34156100e757600080fd5b6100fb600160a060020a0360043516610329565b60405160208082528190810183818151815260200191508051906020019060200280838360005b8381101561013a578082015183820152602001610122565b505050509050019250505060405180910390f35b341561015957600080fd5b61016460043561044a565b604051600160a060020a03909116815260200160405180910390f35b341561018b57600080fd5b6101a5600435602435600160a060020a0360443516610465565b005b34156101b257600080fd5b6101a56105a9565b34156101c557600080fd5b6101a5600435610603565b34156101db57600080fd5b6101e6600435610632565b6040518084600160a060020a0316600160a060020a03168152602001838152602001828152602001935050505060405180910390f35b341561022757600080fd5b61022f610685565b60405190815260200160405180910390f35b341561024c57600080fd5b61022f61068b565b341561025f57600080fd5b610164610691565b341561027257600080fd5b6101a56004356106a0565b341561028857600080fd5b6102906106ee565b604051901515815260200160405180910390f35b6101a560043561070f565b34156102ba57600080fd5b610164610724565b34156102cd57600080fd5b61022f600435610733565b34156102e357600080fd5b61022f600160a060020a036004351661075f565b341561030257600080fd5b610164610771565b341561031557600080fd5b6101a5600160a060020a0360043516610780565b610331610c78565b600061033b610c78565b600160a060020a03841660009081526005602052604080822054935081908190819086905180591061036a5750595b9080825280602002602001820160405250600154909550600160a060020a03166318160ddd6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156103c657600080fd5b6102c65a03f115156103d757600080fd5b5050506040518051945060009350839250505b83821161043e575060008181526003602052604090208054600160a060020a0389811691161415610433578185848151811061042257fe5b602090810290910101526001909201915b6001909101906103ea565b50929695505050505050565b600460205260009081526040902054600160a060020a031681565b61046d610c8a565b600160a060020a038216151561048257600080fd5b600154600160a060020a0316634c8bae938560006040516020015260405160e060020a63ffffffff84160281526004810191909152602401602060405180830381600087803b15156104d357600080fd5b6102c65a03f115156104e457600080fd5b5050506040518051905015156104f957600080fd5b61050333856107d7565b151561050e57600080fd5b6105183385610859565b60806040519081016040908152600160a060020a038416808352602080840187905267ffffffffffffffff4216838501526007805460608601819052600090815260048352848120805473ffffffffffffffffffffffffffffffffffffffff191685179055928352600590915291902080546001908101909155815401905590506105a384826108d4565b50505050565b60065460009033600160a060020a039081169116146105c757600080fd5b50600654600160a060020a0330811631911681156108fc0282604051600060405180830381858888f19350505050151561060057600080fd5b50565b60065433600160a060020a0390811691161461061e57600080fd5b60025481111561062d57600080fd5b600255565b60008181526003602052604081208190819061064d816109b2565b151561065857600080fd5b80546001820154600290920154600160a060020a039091169691955067ffffffffffffffff169350915050565b60075481565b60025481565b600654600160a060020a031681565b6000818152600360205260408120906106b8826109b2565b15156106c357600080fd5b508054600160a060020a0390811690331681146106df57600080fd5b6106e983826109c8565b505050565b60065474010000000000000000000000000000000000000000900460ff1681565b6107198134610a50565b506106003382610bcd565b600054600160a060020a031681565b600081815260036020526040812061074a816109b2565b151561075557600080fd5b6001015492915050565b60056020526000908152604090205481565b600154600160a060020a031681565b60065433600160a060020a0390811691161461079b57600080fd5b600160a060020a038116156106005760068054600160a060020a03831673ffffffffffffffffffffffffffffffffffffffff1990911617905550565b60008054600160a060020a038085169116636352211e84846040516020015260405160e060020a63ffffffff84160281526004810191909152602401602060405180830381600087803b151561082c57600080fd5b6102c65a03f1151561083d57600080fd5b50505060405180519050600160a060020a031614905092915050565b600054600160a060020a03166323b872dd83308460405160e060020a63ffffffff8616028152600160a060020a0393841660048201529190921660248201526044810191909152606401600060405180830381600087803b15156108bc57600080fd5b6102c65a03f115156108cd57600080fd5b5050505050565b600082815260036020526040902081908151815473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a039190911617815560208201518160010155604082015160028201805467ffffffffffffffff191667ffffffffffffffff929092169190911790556060820151600390910155507f31601d099683117d912ba8d2e0a9265379e3e1325353b6effa37c6ef86a9cb03826020830151836060015184516040519384526020840192909252604080840191909152600160a060020a0390911660608301526080909101905180910390a15050565b60020154600067ffffffffffffffff9091161190565b6000828152600360208190526040909120908101546109e684610c23565b600160a060020a03831660009081526005602052604090208054600019019055610a108385610bcd565b7fdb9cc99dc874f9afbae71151f737e51547d3d412b52922793437d86607050c3c848260405191825260208201526040908101905180910390a150505050565b6000828152600360205260408120818080808080610a6d876109b2565b1515610a7857600080fd5b6001870154955085891015610a8c57600080fd5b86546003880154600160a060020a0390911695509350610aab8a610c23565b600160a060020a03851660009081526005602052604081208054600019019055861115610b2957610adb86610c6c565b6001549093508387039250600160a060020a03868116911614610b2957600160a060020a03851682156108fc0283604051600060405180830381858888f193505050501515610b2957600080fd5b50848803600160a060020a03331681156108fc0282604051600060405180830381858888f193505050501515610b5e57600080fd5b7f34fee3e4a1e9469d637a0d1a15f76a747dd26789fb1e59cb62a2dbfc54fcf9798a8733876040518085815260200184815260200183600160a060020a0316600160a060020a0316815260200182815260200194505050505060405180910390a1509398975050505050505050565b600054600160a060020a031663a9059cbb838360405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401600060405180830381600087803b15156108bc57600080fd5b60009081526003602081905260408220805473ffffffffffffffffffffffffffffffffffffffff191681556001810183905560028101805467ffffffffffffffff191690550155565b60025461271091020490565b60206040519081016040526000815290565b608060405190810160409081526000808352602083018190529082018190526060820152905600a165627a7a72305820ddb947aa1a3115ebbfa3c33d0149c0896bfea1927d1675321861f87cae1a3ef00029000000000000000000000000f7f6c2836293a661be2690fbacae97f3f027e9c400000000000000000000000000000000000000000000000000000000000003e8",
  "constructorArguments": "000000000000000000000000f7f6c2836293a661be2690fbacae97f3f027e9c400000000000000000000000000000000000000000000000000000000000003e8"
}