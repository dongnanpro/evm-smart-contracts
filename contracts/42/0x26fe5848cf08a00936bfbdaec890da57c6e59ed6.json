{
  "address": "0x26fe5848cf08a00936bfbdaec890da57c6e59ed6",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Conversion",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2017-11-30\n*/\n\npragma solidity ^0.4.18;\n\ncontract useContractWeb {\n\n  ContractWeb internal web = ContractWeb(0x5F9489D7FfC63ce0bDCD282D14E595A865B259d7);\n\n}\n\ncontract Owned {\n\n  address public owner = msg.sender;\n\n  function transferOwner(address _newOwner) onlyOwner public returns (bool) {\n    owner = _newOwner;\n    return true;\n  }\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n}\n\ncontract CheckPayloadSize {\n\n  modifier onlyPayloadSize(uint256 _size) {\n    require(msg.data.length >= _size + 4);\n    _;\n  }\n\n}\n\ncontract CanTransferTokens is CheckPayloadSize, Owned {\n\n  function transferCustomToken(address _token, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyOwner public returns (bool) {\n    Token tkn = Token(_token);\n    return tkn.transfer(_to, _value);\n  }\n\n}\n\ncontract SafeMath {\n\n  function add(uint256 x, uint256 y) pure internal returns (uint256) {\n    require(x <= x + y);\n    return x + y;\n  }\n\n  function sub(uint256 x, uint256 y) pure internal returns (uint256) {\n    require(x >= y);\n    return x - y;\n  }\n\n}\n\ncontract CheckIfContract {\n\n  function isContract(address _addr) view internal returns (bool) {\n    uint256 length;\n    if (_addr == address(0x0)) return false;\n    assembly {\n      length := extcodesize(_addr)\n    }\n    if(length > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\ncontract ContractReceiver {\n\n  TKN internal fallback;\n\n  struct TKN {\n    address sender;\n    uint256 value;\n    bytes data;\n    bytes4 sig;\n  }\n\n  function getFallback() view public returns (TKN) {\n    return fallback;\n  }\n\n\n  function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool) {\n    TKN memory tkn;\n    tkn.sender = _from;\n    tkn.value = _value;\n    tkn.data = _data;\n    uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n    tkn.sig = bytes4(u);\n    fallback = tkn;\n    return true;\n  }\n\n}\n\ncontract Token1st {\n\n  address public currentTradingSystem;\n  address public currentExchangeSystem;\n\n  mapping(address => uint) public balanceOf;\n  mapping(address => mapping (address => uint)) public allowance;\n  mapping(address => mapping (address => uint)) public tradingBalanceOf;\n  mapping(address => mapping (address => uint)) public exchangeBalanceOf;\n\n  /* @notice get balance of a specific address */\n  function getBalanceOf(address _address) view public returns (uint amount){\n    return balanceOf[_address];\n  }\n\n  event Transfer (address _to, address _from, uint _decimalAmount);\n\n  /* A contract or user attempts to get the coins */\n  function transferDecimalAmountFrom(address _from, address _to, uint _value) public returns (bool success) {\n    require(balanceOf[_from]\n      - tradingBalanceOf[_from][currentTradingSystem]\n      - exchangeBalanceOf[_from][currentExchangeSystem] >= _value);                 // Check if the sender has enough\n    require(balanceOf[_to] + (_value) >= balanceOf[_to]);  // Check for overflows\n    require(_value <= allowance[_from][msg.sender]);   // Check allowance\n    balanceOf[_from] -= _value;                          // Subtract from the sender\n    balanceOf[_to] += _value;                            // Add the same to the recipient\n    allowance[_from][msg.sender] -= _value;\n    Transfer(_to, _from, _value);\n    return true;\n  }\n\n    /* Allow another contract or user to spend some tokens in your behalf */\n  function approveSpenderDecimalAmount(address _spender, uint _value) public returns (bool success) {\n    allowance[msg.sender][_spender] = _value;\n    return true;\n  }\n\n}\n\ncontract ContractWeb is CanTransferTokens, CheckIfContract {\n\n      //contract name | contract info\n  mapping(string => contractInfo) internal contracts;\n\n  event ContractAdded(string _name, address _referredTo);\n  event ContractEdited(string _name, address _referredTo);\n  event ContractMadePermanent(string _name);\n\n  struct contractInfo {\n    address contractAddress;\n    bool isPermanent;\n  }\n\n  function getContractAddress(string _name) view public returns (address) {\n    return contracts[_name].contractAddress;\n  }\n\n  function isContractPermanent(string _name) view public returns (bool) {\n    return contracts[_name].isPermanent;\n  }\n\n  function setContract(string _name, address _address) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) {\n    require(isContract(_address));\n    require(this != _address);\n    require(contracts[_name].contractAddress != _address);\n    require(contracts[_name].isPermanent == false);\n    address oldAddress = contracts[_name].contractAddress;\n    contracts[_name].contractAddress = _address;\n    if(oldAddress == address(0x0)) {\n      ContractAdded(_name, _address);\n    } else {\n      ContractEdited(_name, _address);\n    }\n    return true;\n  }\n\n  function makeContractPermanent(string _name) onlyOwner public returns (bool) {\n    require(contracts[_name].contractAddress != address(0x0));\n    require(contracts[_name].isPermanent == false);\n    contracts[_name].isPermanent = true;\n    ContractMadePermanent(_name);\n    return true;\n  }\n\n  function tokenSetup(address _Tokens1st, address _Balancecs, address _Token, address _Conversion, address _Distribution) onlyPayloadSize(5 * 32) onlyOwner public returns (bool) {\n    setContract(\"Token1st\", _Tokens1st);\n    setContract(\"Balances\", _Balancecs);\n    setContract(\"Token\", _Token);\n    setContract(\"Conversion\", _Conversion);\n    setContract(\"Distribution\", _Distribution);\n    return true;\n  }\n\n}\n\ncontract Balances is CanTransferTokens, SafeMath, useContractWeb {\n\n  mapping(address => uint256) internal _balances;\n\n  function get(address _account) view public returns (uint256) {\n    return _balances[_account];\n  }\n\n  function tokenContract() view internal returns (address) {\n    return web.getContractAddress(\"Token\");\n  }\n\n  function Balances() public {\n    _balances[msg.sender] = 190 * 1000000 * 1000000000000000000;\n  }\n\n  modifier onlyToken {\n    require(msg.sender == tokenContract());\n    _;\n  }\n\n  function transfer(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyToken public returns (bool success) {\n  _balances[_from] = sub(_balances[_from], _value);\n  _balances[_to] = add(_balances[_to], _value);\n  return true;\n  }\n\n}\n\ncontract Token is CanTransferTokens, SafeMath, CheckIfContract, useContractWeb {\n\n  string public symbol = \"SHC\";\n  string public name = \"ShineCoin\";\n  uint8 public decimals = 18;\n  uint256 public totalSupply = 190 * 1000000 * 1000000000000000000;\n\n  mapping (address => mapping (address => uint256)) internal _allowance;\n\n    // ERC20 Events\n  event Approval(address indexed from, address indexed to, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // ERC223 Event\n  event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\n\n  function balanceOf(address _account) view public returns (uint256) {\n    return Balances(balancesContract()).get(_account);\n  }\n\n  function allowance(address _from, address _to) view public returns (uint256 remaining) {\n    return _allowance[_from][_to];\n  }\n\n  function balancesContract() view internal returns (address) {\n    return web.getContractAddress(\"Balances\");\n  }\n\n  function Token() public {\n    bytes memory empty;\n    Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000);\n    Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000, empty);\n  }\n\n  function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {\n    if(isContract(_to)) {\n      require(Balances(balancesContract()).get(msg.sender) >= _value);\n      Balances(balancesContract()).transfer(msg.sender, _to, _value);\n      ContractReceiver receiver = ContractReceiver(_to);\n      require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\n      Transfer(msg.sender, _to, _value);\n      Transfer(msg.sender, _to, _value, _data);\n      return true;\n    } else {\n      return transferToAddress(_to, _value, _data);\n    }\n  }\n\n  function transfer(address _to, uint256 _value, bytes _data) onlyPayloadSize(3 * 32) public returns (bool success) {\n    if(isContract(_to)) {\n      return transferToContract(_to, _value, _data);\n    }\n    else {\n      return transferToAddress(_to, _value, _data);\n    }\n  }\n\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) {\n    bytes memory empty;\n    if(isContract(_to)) {\n      return transferToContract(_to, _value, empty);\n    }\n    else {\n      return transferToAddress(_to, _value, empty);\n    }\n  }\n\n  function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) {\n    require(Balances(balancesContract()).get(msg.sender) >= _value);\n    Balances(balancesContract()).transfer(msg.sender, _to, _value);\n    Transfer(msg.sender, _to, _value);\n    Transfer(msg.sender, _to, _value, _data);\n    return true;\n  }\n\n  function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) {\n    require(Balances(balancesContract()).get(msg.sender) >= _value);\n    Balances(balancesContract()).transfer(msg.sender, _to, _value);\n    ContractReceiver receiver = ContractReceiver(_to);\n    receiver.tokenFallback(msg.sender, _value, _data);\n    Transfer(msg.sender, _to, _value);\n    Transfer(msg.sender, _to, _value, _data);\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool) {\n    bytes memory empty;\n    require(_value > 0 && _allowance[_from][msg.sender] >= _value && Balances(balancesContract()).get(_from) >= _value);\n    _allowance[_from][msg.sender] = sub(_allowance[_from][msg.sender], _value);\n    if(msg.sender != _to && isContract(_to)) {\n      Balances(balancesContract()).transfer(_from, _to, _value);\n      ContractReceiver receiver = ContractReceiver(_to);\n      receiver.tokenFallback(_from, _value, empty);\n    } else {\n      Balances(balancesContract()).transfer(_from, _to, _value);\n    }\n    Transfer(_from, _to, _value);\n    Transfer(_from, _to, _value, empty);\n    return true;\n  }\n\n  function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) {\n    _allowance[msg.sender][_spender] = add(_allowance[msg.sender][_spender], _value);\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n}\n\ncontract Conversion is CanTransferTokens, useContractWeb {\n\n  function token1stContract() view internal returns (address) {\n    return web.getContractAddress(\"Token1st\");\n  }\n\n  function tokenContract() view internal returns (address) {\n    return web.getContractAddress(\"Token\");\n  }\n\n  function deposit() onlyOwner public returns (bool) {\n    require(Token(tokenContract()).allowance(owner, this) > 0);\n    return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this));\n  }\n\n  function convert() public returns (bool) {\n    uint256 senderBalance = Token1st(token1stContract()).getBalanceOf(msg.sender);\n    require(Token1st(token1stContract()).allowance(msg.sender, this) >= senderBalance);\n    Token1st(token1stContract()).transferDecimalAmountFrom(msg.sender, owner, senderBalance);\n    return Token(tokenContract()).transfer(msg.sender, senderBalance * 10000000000);\n  }\n\n}\n\ncontract Distribution is CanTransferTokens, SafeMath, useContractWeb {\n\n  uint256 public liveSince;\n  uint256 public withdrawn;\n\n  function withdrawnReadable() view public returns (uint256) {\n    return withdrawn / 1000000000000000000;\n  }\n\n  function secondsLive() view public returns (uint256) {\n    if(liveSince != 0) {\n      return now - liveSince;\n    }\n  }\n\n  function allowedSince() view public returns (uint256) {\n    return secondsLive() * 380265185769276972;\n  }\n\n  function allowedSinceReadable() view public returns (uint256) {\n    return secondsLive() * 380265185769276972 / 1000000000000000000;\n  }\n\n  function stillAllowed() view public returns (uint256) {\n    return allowedSince() - withdrawn;\n  }\n\n  function stillAllowedReadable() view public returns (uint256) {\n    uint256 _1 = allowedSince() - withdrawn;\n    return _1 / 1000000000000000000;\n  }\n\n  function tokenContract() view internal returns (address) {\n    return web.getContractAddress(\"Token\");\n  }\n\n  function makeLive() onlyOwner public returns (bool) {\n    require(liveSince == 0);\n    liveSince = now;\n    return true;\n  }\n\n  function deposit() onlyOwner public returns (bool) {\n    require(Token(tokenContract()).allowance(owner, this) > 0);\n    return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this));\n  }\n\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) {\n    require(stillAllowed() >= _value && _value > 0 && liveSince != 0);\n    withdrawn = add(withdrawn, _value);\n    return Token(tokenContract()).transfer(_to, _value);\n  }\n\n  function transferReadable(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) {\n    require(stillAllowed() >= _value * 1000000000000000000 && stillAllowed() != 0 && liveSince != 0);\n    withdrawn = add(withdrawn, _value * 1000000000000000000);\n    return Token(tokenContract()).transfer(_to, _value * 1000000000000000000);\n  }\n\n}",
  "bytecode": "606060405260008054600160a060020a033316600160a060020a03199182161790915560018054909116735f9489d7ffc63ce0bdcd282d14e595a865b259d7179055341561004c57600080fd5b6107528061005b6000396000f3006060604052600436106100535763ffffffff60e060020a6000350416634fb2e45d81146100585780638da5cb5b1461008b57806391bbdcc7146100ba578063d0e30db0146100cd578063eee78595146100e0575b600080fd5b341561006357600080fd5b610077600160a060020a0360043516610108565b604051901515815260200160405180910390f35b341561009657600080fd5b61009e610156565b604051600160a060020a03909116815260200160405180910390f35b34156100c557600080fd5b610077610165565b34156100d857600080fd5b61007761039e565b34156100eb57600080fd5b610077600160a060020a0360043581169060243516604435610572565b6000805433600160a060020a0390811691161461012457600080fd5b5060008054600160a060020a03831673ffffffffffffffffffffffffffffffffffffffff199091161790556001919050565b600054600160a060020a031681565b600080610170610624565b600160a060020a0316639b96eece3360006040516020015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b15156101c657600080fd5b6102c65a03f115156101d757600080fd5b505050604051805190509050806101ec610624565b600160a060020a031663dd62ed3e333060006040516020015260405160e060020a63ffffffff8516028152600160a060020a03928316600482015291166024820152604401602060405180830381600087803b151561024a57600080fd5b6102c65a03f1151561025b57600080fd5b505050604051805190501015151561027257600080fd5b61027a610624565b600160a060020a0316635f1845f6336000809054906101000a9004600160a060020a03168460006040516020015260405160e060020a63ffffffff8616028152600160a060020a0393841660048201529190921660248201526044810191909152606401602060405180830381600087803b15156102f757600080fd5b6102c65a03f1151561030857600080fd5b505050604051805190505061031b6106a5565b600160a060020a031663a9059cbb33836402540be4000260006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561037e57600080fd5b6102c65a03f1151561038f57600080fd5b50505060405180519250505090565b6000805433600160a060020a039081169116146103ba57600080fd5b60006103c46106a5565b60008054600160a060020a039283169263dd62ed3e9291169030906040516020015260405160e060020a63ffffffff8516028152600160a060020a03928316600482015291166024820152604401602060405180830381600087803b151561042b57600080fd5b6102c65a03f1151561043c57600080fd5b5050506040518051905011151561045257600080fd5b61045a6106a5565b600054600160a060020a03918216916323b872dd9116306104796106a5565b60008054600160a060020a039283169263dd62ed3e9291169030906040516020015260405160e060020a63ffffffff8516028152600160a060020a03928316600482015291166024820152604401602060405180830381600087803b15156104e057600080fd5b6102c65a03f115156104f157600080fd5b5050506040518051905060006040516020015260405160e060020a63ffffffff8616028152600160a060020a0393841660048201529190921660248201526044810191909152606401602060405180830381600087803b151561055357600080fd5b6102c65a03f1151561056457600080fd5b505050604051805191505090565b6000806060606436101561058557600080fd5b60005433600160a060020a039081169116146105a057600080fd5b85915081600160a060020a031663a9059cbb868660006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561060057600080fd5b6102c65a03f1151561061157600080fd5b5050506040518051979650505050505050565b600154600090600160a060020a03166304433bbc826040516020015260405160e060020a63ffffffff8316028152602060048201819052600860248301527f546f6b656e317374000000000000000000000000000000000000000000000000604483015260649091019060405180830381600087803b151561055357600080fd5b600154600090600160a060020a03166304433bbc826040516020015260405160e060020a63ffffffff8316028152602060048201819052600560248301527f546f6b656e000000000000000000000000000000000000000000000000000000604483015260649091019060405180830381600087803b151561055357600080fd00a165627a7a72305820722bc47aa30b8425884494ec4350c1bd23ca9419e7285f60f737dee17b668fc50029"
}